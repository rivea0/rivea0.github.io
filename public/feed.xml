<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[rivea0]]></title>
        <description><![CDATA[My blog, projects, etc.]]></description>
        <link>https://rivea0.github.io</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Fri, 24 May 2024 19:46:28 GMT</lastBuildDate>
        <atom:link href="https://rivea0.github.io/feed.xml" rel="self" type="application/rss+xml"/>
        <language><![CDATA[en]]></language>
        <item>
            <title><![CDATA[LeetCode Meditations: Implement Trie (Prefix Tree)]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-24/49-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/implement-trie-prefix-tree" target="_blank" rel="noopener noreferrer">this problem</a> is:</p>
<blockquote>
<p>A <a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener noreferrer"><strong>trie</strong></a> (pronounced as &quot;try&quot;) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>
<p>Implement the Trie class:</p>
<ul>
<li><code>Trie()</code> Initializes the trie object.</li>
<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>
<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>
<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>
</ul>
</blockquote>
<p>For example: </p>
<pre><code>Input
[&#39;Trie&#39;, &#39;insert&#39;, &#39;search&#39;, &#39;search&#39;, &#39;startsWith&#39;, &#39;insert&#39;, &#39;search&#39;]
[[], [&#39;apple&#39;], [&#39;apple&#39;], [&#39;app&#39;], [&#39;app&#39;], [&#39;app&#39;], [&#39;app&#39;]]

Output
[null, null, true, false, true, null, true]

Explanation
Trie trie = new Trie();
trie.insert(&#39;apple&#39;);
trie.search(&#39;apple&#39;);   // return True
trie.search(&#39;app&#39;);     // return False
trie.startsWith(&#39;app&#39;); // return True
trie.insert(&#39;app&#39;);
trie.search(&#39;app&#39;);     // return True
</code></pre>
<hr>
<p>We have seen in <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-10-tries" target="_blank" rel="noopener noreferrer">the previous article</a> how to create a trie, insert a word, and search for a word, as well as deleting a word.</p>
<p>This problem requires only the first three of them, and additionally a <code>startsWith</code> method to search for a prefix.</p>
<p>In the previous version, we&#39;ve created our trie using an array, but let&#39;s use another approach here. We&#39;ll make use of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#instance_methods" target="_blank" rel="noopener noreferrer">the <code>Map</code> object</a>, which is slightly more readable and efficient.</p>
<p><em>We used JavaScript in the previous article, but for this solution we&#39;ll continue using TypeScript.</em></p>
<hr>
<p>Let&#39;s start with a trie node.</p>
<p>We&#39;ll create a <code>TrieNode</code> class that has <code>children</code> which is initiated as a <code>Map</code> whose keys are <code>string</code>s and the values are <code>TrieNode</code>s. </p>
<p>Our node will also have an <code>isEndOfWord</code> flag to indicate whether it represents the end character of a word:</p>
<pre><code class="language-ts">class TrieNode {
  public children: Map&lt;string, TrieNode&gt;;
  public isEndOfWord: boolean;

  constructor() {
    this.children = new Map();
    this.isEndOfWord = false;    
  }
}
</code></pre>
<p>Now, on to the <code>Trie</code> itself.</p>
<p>We&#39;ll start with creating an empty root note in our <code>constructor</code>:</p>
<pre><code class="language-ts">class Trie {
  public root: TrieNode;

  constructor() {
    this.root = new TrieNode();
  }
  ...
}
</code></pre>
<p>To insert a word, we&#39;ll traverse each character, and starting with our root node, insert them one by one. </p>
<p>First, we&#39;ll initialize a <code>currentNode</code> variable which points to our root node, and we&#39;ll update it each time we add a character. Once we add all the characters, we&#39;ll mark that node&#39;s <code>isEndOfWord</code> as <code>true</code>:</p>
<pre><code class="language-ts">insert(word: string): void {
  let currentNode = this.root;
  for (const char of word) {
    if (!currentNode.children.has(char)) {
      currentNode.children.set(char, new TrieNode());
    }
    currentNode = currentNode.children.get(char) as TrieNode;
  }

  currentNode.isEndOfWord = true;
}
</code></pre>
<Note>
We'll be casting `currentNode.children.get(char)` as a `TrieNode`, because TypeScript thinks that it might be `undefined`. This is one of those times that we know more than the TS compiler, so we're using a [type assertion](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions).

<p>Alternatively, we could&#39;ve also used a <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix" target="_blank" rel="noopener noreferrer">non-null assertion operator</a> that asserts values as non <code>null</code> or <code>undefined</code>, like this:</p>
<pre><code class="language-ts">currentNode = currentNode.children.get(char)!;
</code></pre>
</Note>

<p>To search a word, we&#39;ll do a similar thing. We&#39;ll iterate through each character, and check if it&#39;s in our trie. If not, we can immediately return <code>false</code>. Otherwise, we&#39;ll return <code>isEndOfWord</code> of the last node we reach. So, if that character is indeed the end of a word, that word is in our trie:</p>
<pre><code class="language-ts">search(word: string): boolean {
  let currentNode = this.root;
  for (const char of word) {
    if (!currentNode.children.has(char)) {
      return false;
    }
    currentNode = currentNode.children.get(char) as TrieNode;
  }

  return currentNode.isEndOfWord;
}
</code></pre>
<p>The <code>startsWith</code> method also looks very similar, only that we don&#39;t need to check <code>isEndOfWord</code> of any node. We&#39;re just checking for the existence of the prefix we&#39;re given, so we&#39;ll traverse all the characters in it, and once we reach the end (<em>that all characters are in our trie</em>), we can return <code>true</code>: </p>
<pre><code class="language-ts">startsWith(prefix: string): boolean {
  let currentNode = this.root;
  for (const char of prefix) {
    if (!currentNode.children.has(char)) {
      return false;
    }
    currentNode = currentNode.children.get(char) as TrieNode;
  }

  return true;
}
</code></pre>
<p>And, here is the whole solution:</p>
<pre><code class="language-ts">class TrieNode {
  public children: Map&lt;string, TrieNode&gt;;
  public isEndOfWord: boolean;

  constructor() {
    this.children = new Map();
    this.isEndOfWord = false;    
  }
}

class Trie {
  public root: TrieNode;

  constructor() {
    this.root = new TrieNode();
  }

  insert(word: string): void {
    let currentNode = this.root;
    for (const char of word) {
      if (!currentNode.children.has(char)) {
        currentNode.children.set(char, new TrieNode());
      }
      currentNode = currentNode.children.get(char) as TrieNode;
    }

    currentNode.isEndOfWord = true;
  }

  search(word: string): boolean {
    let currentNode = this.root;
    for (const char of word) {
      if (!currentNode.children.has(char)) {
        return false;
      }
      currentNode = currentNode.children.get(char) as TrieNode;
    }

    return currentNode.isEndOfWord;
  }

  startsWith(prefix: string): boolean {
    let currentNode = this.root;
    for (const char of prefix) {
      if (!currentNode.children.has(char)) {
        return false;
      }
      currentNode = currentNode.children.get(char) as TrieNode;
    }

    return true;
  }
}

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
</code></pre>
<h4>Time and space complexity</h4>
<p>Both the time and space complexity of inserting a word are $O(n)$ where $n$ is the number of characters — we traverse through each of them once, and the space requirements will grow as the number of characters of the word grows.</p>
<p><code>search</code> and <code>startsWith</code> both have $O(n)$ time complexity, as we&#39;re iterating through each character in a given string input. They also both have $O(1)$ space complexity because we don&#39;t need any additional space.</p>
<hr>
<p>Next up is the problem <a href="https://leetcode.com/problems/design-add-and-search-words-data-structure" target="_blank" rel="noopener noreferrer">Design Add and Search Words Data Structure</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-implement-trie-prefix-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-implement-trie-prefix-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 24 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 10: Tries]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-23/48-lm-ch10.png" alt="Cover image"></p>
<p>The trie data structure <a href="https://en.wikipedia.org/wiki/Trie#History,_etymology,_and_pronunciation" target="_blank" rel="noopener noreferrer">gets its name from the word <em>re<strong>trie</strong>val</em></a> — and it&#39;s usually pronounced as &quot;try,&quot; so that we don&#39;t get confused with another familiar and friendly data structure, &quot;tree.&quot;</p>
<p>However, a trie is still a tree (or tree-like) data structure whose nodes usually store individual letters. So, by traversing the nodes in a trie, we can retrieve strings.</p>
<p>Tries are useful for applications such as autocompletion and spellchecking — and the larger our trie is, the less work we have to do for inserting a new value. </p>
<hr>
<p><strong>An important note before we start: using arrays is not very memory-efficient, and we&#39;ll see another way of creating tries in the next article for <a href="https://leetcode.com/problems/implement-trie-prefix-tree" target="_blank" rel="noopener noreferrer">Implement Trie (Prefix Tree)</a>. For now, we&#39;ll stick to the array implementation.</strong></p>
<p>First, let&#39;s see what a trie looks like:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-23/tries.gif" alt="Example of a trie"></p>
<p><em>In this trie, we can retrieve the strings &quot;sea&quot; and &quot;see&quot; — but not &quot;sew&quot; for example.</em></p>
<p>There is a lot going on, but we can try to understand it piece by piece.</p>
<p>Let&#39;s look at a trie node.</p>
<p>We&#39;ll create a <code>TrieNode</code> class that has <code>children</code>, which is an array of length 26 (so that each index corresponds to a letter in the English alphabet), and a flag variable <code>isEndOfWord</code> to indicate whether that node represents the last character of a word:</p>
<pre><code class="language-js">class TrieNode {
  constructor() {
    this.children = Array.from({ length: 26 }, () =&gt; null);
    this.isEndOfWord = false;
  }
}
</code></pre>
<p>We&#39;re initializing <code>children</code> with <code>null</code> values. As we add a character to our trie, the index that corresponds to that character will be filled.</p>
<Note>
We're not storing the actual character itself in this implementation, it's implicit in the usage of indices.
</Note>

<p>In a trie, we start with an empty root node.</p>
<pre><code class="language-js">class Trie {
  constructor() {
    this.root = new TrieNode();
  }
  ...
}
</code></pre>
<p>To insert a word, we&#39;re going to loop through each character, and initialize a new <code>TrieNode</code> to the corresponding index.</p>
<pre><code class="language-js">insert(word) {
  let currentNode = this.root;
  for (const char of word) {
    let idx = char.charCodeAt(0) - &#39;a&#39;.charCodeAt(0);
    if (currentNode.children[idx] === null) {
      currentNode.children[idx] = new TrieNode();
    }
    currentNode = currentNode.children[idx];
  }

  currentNode.isEndOfWord = true;
}
</code></pre>
<p>Once we reach the node that indicates the last character of the word we inserted, we also mark the <code>isEndOfWord</code> variable as <code>true</code>.</p>
<Note>
`word` is going to be lowercase in these examples, otherwise, we have to convert it, such as:

<pre><code class="language-js">word = word.toLowerCase();
</code></pre>
</Note>

<p>For searching a word&#39;s existence in the trie, we&#39;ll do a similar thing. We&#39;ll look at the nodes for each character, and if we reach the last one that has <code>isEndOfWord</code> marked as <code>true</code>, that means we&#39;ve found the word:</p>
<pre><code class="language-js">search(word) {
  let currentNode = this.root;
  for (const char of word) {
    let idx = char.charCodeAt(0) - &#39;a&#39;.charCodeAt(0);
    if (currentNode.children[idx] === null) {
      return false;
    }      
    currentNode = currentNode.children[idx];
  }

  return currentNode.isEndOfWord;
}
</code></pre>
<Note>
If we find the word we're looking for, then it's called a **search hit**; otherwise, we have a **search miss** and the word doesn't exist in our trie.
</Note>

<p>Removing a word is a bit more challenging. Let&#39;s say that we want to remove the word &quot;see.&quot; But, there is also another word &quot;sea,&quot; with the same prefix (&#39;s&#39; and &#39;e&#39;). So, we should remove only the nodes that we&#39;re allowed to.</p>
<p>For this reason, we&#39;ll define a recursive function.<br>Once we reach the last character of the word we want to remove, we&#39;ll back up and remove the characters we can remove:</p>
<pre><code class="language-js">const removeRecursively = (node, word, depth) =&gt; {
  if (node === null) {
    return null;
  }

  if (depth === word.length) {
    if (node.isEndOfWord) {
      node.isEndOfWord = false;
    }
    if (node.children.every(child =&gt; child === null)) {
      node = null;
    }

    return node;
  }

  let idx = word[depth].charCodeAt(0) - &#39;a&#39;.charCodeAt(0);
  node.children[idx] = removeRecursively(node.children[idx], word, depth + 1);

  if (node.children.every(child =&gt; child === null) &amp;&amp; !node.isEndOfWord) {
    node = null;
  }

  return node;
}
</code></pre>
<p><code>depth</code> indicates the index of the word, or <em>the depth of the trie we reach</em>.</p>
<p>Once <code>depth</code> is equal to the word&#39;s length (one past the last character), we check if it&#39;s the end of the word, if that&#39;s the case, we&#39;ll mark it as <code>false</code> now, because that word won&#39;t exist from here on. Then, we can only mark the node as <code>null</code> if it doesn&#39;t have any children (in other words, if all of them are <code>null</code>). We&#39;ll apply this logic to each child node recursively until the word is removed as far as it can be removed.</p>
<p>Here is the final example implementation of a trie:</p>
<pre><code class="language-js">class TrieNode {
  constructor() {
    this.children = Array.from({ length: 26 }, () =&gt; null);
    this.isEndOfWord = false;
  }
}

class Trie {
  constructor() {
    this.root = new TrieNode();
  }

  insert(word) {
    let currentNode = this.root;
    for (const char of word) {
      let idx = char.charCodeAt(0) - &#39;a&#39;.charCodeAt(0);
      if (currentNode.children[idx] === null) {
        currentNode.children[idx] = new TrieNode();
      }
      currentNode = currentNode.children[idx];
    }

    currentNode.isEndOfWord = true;
  }

  search(word) {
    let currentNode = this.root;
    for (const char of word) {
      let idx = char.charCodeAt(0) - &#39;a&#39;.charCodeAt(0);
      if (currentNode.children[idx] === null) {
        return false;
      }      
      currentNode = currentNode.children[idx];
    }

    return currentNode.isEndOfWord;
  }
    
  remove(word) {
    const removeRecursively = (node, word, depth) =&gt; {
      if (node === null) {
        return null;
      }

      if (depth === word.length) {
        if (node.isEndOfWord) {
          node.isEndOfWord = false;
        }
        if (node.children.every(child =&gt; child === null)) {
          node = null;
        }

        return node;
      }

      let idx = word[depth].charCodeAt(0) - &#39;a&#39;.charCodeAt(0);
      node.children[idx] = removeRecursively(node.children[idx], word, depth + 1);

      if (node.children.every(child =&gt; child === null) &amp;&amp; !node.isEndOfWord) {
        node = null;
      }

      return node;
    }

    removeRecursively(this.root, word, 0);
  }
}

let t = new Trie();

t.insert(&#39;sea&#39;);
t.insert(&#39;see&#39;);

console.log(t.search(&#39;sea&#39;)); // true
console.log(t.search(&#39;see&#39;)); // true

console.log(t.search(&#39;hey&#39;)); // false
console.log(t.search(&#39;sew&#39;)); // false

t.remove(&#39;see&#39;);

console.log(t.search(&#39;see&#39;)); // false 
console.log(t.search(&#39;sea&#39;)); // true
</code></pre>
<hr>
<h4>Time and space complexity</h4>
<p>The time complexity of creating a trie is going to be $O(m * n)$ where $m$ is the longest word and $n$ is the total number of words.<br>Inserting, searching, and deleting a word is $O(a * n)$ where $a$ is the length of the word and $n$ is the total number of words.</p>
<p>When it comes to space complexity, in the worst case, each node can have children for all the characters in the alphabet we&#39;re representing. But, the size of the alphabet is constant, so the growth of storage needs will be proportionate to the number of nodes we have, which is $O(n)$ where $n$ is the number of nodes.</p>
<hr>
<p>We have already done most of the work for <a href="https://leetcode.com/problems/implement-trie-prefix-tree" target="_blank" rel="noopener noreferrer">the next problem</a>, but next time we&#39;ll be slightly more efficient. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-10-tries</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-10-tries</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 23 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Word Search]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-20/47-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/word-search" target="_blank" rel="noopener noreferrer">Word Search</a> is:</p>
<blockquote>
<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>
<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
</blockquote>
<p>For example: </p>
<img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="Example 1" />

<pre><code>Input: board = [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;], [&#39;S&#39;, &#39;F&#39;, &#39;C&#39;, &#39;S&#39;], [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;]], word = &#39;ABCCED&#39;

Output: true
</code></pre>
<hr>
<p>We somehow have to look at each cell, and explore our options to see if we can find the word. This <em>exploration</em> lends itself perfectly to a <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#dfs" target="_blank" rel="noopener noreferrer">depth-first search</a>.  </p>
<p>But, we can&#39;t explore other cells if <mark>the current row and column we&#39;re looking at are out of bounds</mark>, and <mark>the current character is not the character we want</mark>.</p>
<p>In these cases, we have to return <code>false</code>:</p>
<pre><code class="language-ts">if (outOfBounds(row, col) || word[idx] !== board[row][col]) {
  return false;
}
</code></pre>
<Note>
`idx` is the index of the current character in `word` that we're looking for.
</Note>

<p>This is one base case. Another base case is when we actually find the word.</p>
<p>Since we&#39;ll be keeping track of the index of the word for the current character we&#39;re exploring, once it reaches the word&#39;s length, we know that we have found the word:</p>
<pre><code class="language-ts">if (idx === word.length) {
  return true;
}
</code></pre>
<p>Now that the base cases are out of the way, the first thing we can do for the cell we&#39;re looking at is to mark it as visited. We can use the <code>*</code> character to indicate that:</p>
<pre><code class="language-ts">let currentCell = board[row][col];
board[row][col] = &#39;*&#39;; 
</code></pre>
<p>Now, we can do the exploring for the cell we&#39;re looking at:</p>
<pre><code class="language-ts">dfs(row + 1, col, idx + 1) || // down
dfs(row - 1, col, idx + 1) || // up
dfs(row, col + 1, idx + 1) || // right
dfs(row, col - 1, idx + 1);   // left
</code></pre>
<Note>
We'll pass `idx + 1` as our new index, because we'll be looking for the next character in `word`.
</Note>

<p>All these explorations are not for nothing of course, so we have to keep the result we have:</p>
<pre><code class="language-ts">let result = dfs(row + 1, col, idx + 1) || // down
             dfs(row - 1, col, idx + 1) || // up
             dfs(row, col + 1, idx + 1) || // right
             dfs(row, col - 1, idx + 1);   // left
</code></pre>
<p>Before returning this result, we need to reset the marked cell to its original value, otherwise, in our other explorations, we would have it wrongly marked:</p>
<pre><code class="language-ts">board[row][col] = currentCell;
</code></pre>
<p>This is all for our depth-first search function:</p>
<pre><code class="language-ts">function dfs(row: number, col: number, idx: number): boolean {
  if (idx === word.length) {
    return true;
  }
  if (outOfBounds(row, col) || word[idx] !== board[row][col]) {
    return false;
  }

  // Mark the current cell as visited
  let currentCell = board[row][col];
  board[row][col] = &#39;*&#39;; 

  // Pass idx + 1 because we&#39;re looking for 
  // the next character in the word now
  let result = dfs(row + 1, col, idx + 1) || // down
               dfs(row - 1, col, idx + 1) || // up
               dfs(row, col + 1, idx + 1) || // right
               dfs(row, col - 1, idx + 1);   // left

  // Reset the current cell to its original value 
  // because we&#39;re done visiting it
  board[row][col] = currentCell;

  return result;
}
</code></pre>
<p>We&#39;ll apply depth-first search for each cell on the board:</p>
<pre><code class="language-ts">for (let i = 0; i &lt; rowsLength; i++) {
  for (let j = 0; j &lt; colsLength; j++) {
    if (dfs(i, j, 0)) {
      return true;
    }
  }
}
</code></pre>
<p>If <code>dfs</code> returns true for that cell, we can return <code>true</code> immediately. Otherwise, we&#39;ll return <code>false</code> at the end. </p>
<p>The final solution looks like this in TypeScript:</p>
<pre><code class="language-ts">function exist(board: string[][], word: string): boolean {
  const rowsLength = board.length;
  const colsLength = board[0].length;

  function outOfBounds(r: number, c: number) {
    return r &lt; 0 || c &lt; 0 || r &gt;= rowsLength || c &gt;= colsLength;
  }

  // idx: the index of the current character in the word we&#39;re looking for
  function dfs(row: number, col: number, idx: number): boolean {
    if (idx === word.length) {
      return true;
    }
    if (outOfBounds(row, col) || word[idx] !== board[row][col]) {
      return false;
    }

    // Mark the current cell as visited
    let currentCell = board[row][col];
    board[row][col] = &#39;*&#39;; 

    // Pass idx + 1 because we&#39;re looking for 
    // the next character in the word now
    let result = dfs(row + 1, col, idx + 1) || // down
                 dfs(row - 1, col, idx + 1) || // up
                 dfs(row, col + 1, idx + 1) || // right
                 dfs(row, col - 1, idx + 1);   // left

    // Reset the current cell to its original value 
    // because we&#39;re done visiting it
    board[row][col] = currentCell;

    return result;
  }

  // For each cell, do a depth-first search
  for (let i = 0; i &lt; rowsLength; i++) {
    for (let j = 0; j &lt; colsLength; j++) {
      if (dfs(i, j, 0)) {
        return true;
      }
    }
  }

  return false;
}
</code></pre>
<p><em>This version is adapted from <a href="https://www.youtube.com/watch?v=pfiQ_PS1g8E" target="_blank" rel="noopener noreferrer">NeetCode&#39;s solution</a></em>.</p>
<hr>
<p>Now, let&#39;s look at a very simple example.</p>
<p>Our board looks like this, and the word we&#39;re looking for is <code>PIE</code>:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-20/word-search-pie.png" alt="Word search board highlighted for the word PIE"></p>
<pre><code class="language-ts">board = [[&#39;A&#39;, &#39;P&#39;], [&#39;E&#39;, &#39;I&#39;]]

word = &#39;PIE&#39;
</code></pre>
<p>Let&#39;s modify the code a little bit, and use some helpful <code>console.log</code>s:</p>
<pre><code class="language-ts">function exist(board: string[][], word: string): boolean {
  const rowsLength = board.length;
  const colsLength = board[0].length;

  function outOfBounds(r: number, c: number) {
    return r &lt; 0 || c &lt; 0 || r &gt;= rowsLength || c &gt;= colsLength;
  }

  // idx: the index of the current character in the word we&#39;re looking for
  function dfs(row: number, col: number, idx: number): boolean {
    console.log(`\n===== row: ${row}, col: ${col} =====`);
    if (idx === word.length) {
      console.log(`🎉 this is dfs(${row}, ${col}, ${idx}), FINISHED ALREADY, &#39;${word}&#39; HAS BEEN FOUND`);
      return true;
    }
    if (outOfBounds(row, col)) {
      console.log(`\n======= OUT OF BOUNDS =======\n`);
      return false;
    }
    if (word[idx] !== board[row][col]) {
      console.log(`looking for &#39;${word[idx]}&#39;, this is ${board[row][col]}`);
      return false;
    }

    // Mark the current cell as visited
    let currentCell = board[row][col];
    console.log(`found ${currentCell}, currentCell is ${currentCell}, idx is ${idx}`);
    board[row][col] = &#39;*&#39;; 

    // Pass idx + 1 because we&#39;re looking for 
    // the next character in the word now
    console.log(`this is dfs(${row}, ${col}, ${idx}), going down, searching for &#39;${word[idx + 1]}&#39;`); 
    let downResult = dfs(row + 1, col, idx + 1); 
    console.log(`🟣 dfs(${row + 1}, ${col}, ${idx + 1}) returned, row is ${row}, col is ${col}\n`);

    console.log(`this is dfs(${row}, ${col}, ${idx}), going up, searching for &#39;${word[idx + 1]}&#39;`);
    let upResult = dfs(row - 1, col, idx + 1);
    console.log(`🟣 dfs(${row - 1}, ${col}, ${idx + 1}) returned, row is ${row}, col is ${col}\n`);

    console.log(`this is dfs(${row}, ${col}, ${idx}), going right, searching for &#39;${word[idx + 1]}&#39;`);
    let rightResult = dfs(row, col + 1, idx + 1);
    console.log(`🟣 dfs(${row}, ${col + 1}, ${idx + 1}) returned, row is ${row}, col is ${col}\n`);

    console.log(`this is dfs(${row}, ${col}, ${idx}), going left, searching for &#39;${word[idx + 1]}&#39;`);
    let leftResult = dfs(row, col - 1, idx + 1);
    console.log(`🟣 dfs(${row}, ${col - 1}, ${idx + 1}) returned, row is ${row}, col is ${col}\n`);

    // Reset the current cell to its original value 
    // because we&#39;re done visiting it
    board[row][col] = currentCell;

    return downResult || upResult || rightResult || leftResult;
  }

  // For each cell, do a depth-first search
  for (let i = 0; i &lt; rowsLength; i++) {
    for (let j = 0; j &lt; colsLength; j++) {
      if (dfs(i, j, 0)) {
        return true;
      }
    }
  }

  return false;
}

console.log(exist([[&#39;A&#39;, &#39;P&#39;],[&#39;E&#39;, &#39;I&#39;]], &#39;PIE&#39;));
</code></pre>
<p>It looks overwhelming and cluttered, but looking at the output, it almost reads like a story:</p>
<pre><code>
===== row: 0, col: 0 =====
looking for &#39;P&#39;, this is A

===== row: 0, col: 1 =====
found P, currentCell is P, idx is 0
this is dfs(0, 1, 0), going down, searching for &#39;I&#39;

===== row: 1, col: 1 =====
found I, currentCell is I, idx is 1
this is dfs(1, 1, 1), going down, searching for &#39;E&#39;

===== row: 2, col: 1 =====

======= OUT OF BOUNDS =======

🟣 dfs(2, 1, 2) returned, row is 1, col is 1

this is dfs(1, 1, 1), going up, searching for &#39;E&#39;

===== row: 0, col: 1 =====
looking for &#39;E&#39;, this is *
🟣 dfs(0, 1, 2) returned, row is 1, col is 1

this is dfs(1, 1, 1), going right, searching for &#39;E&#39;

===== row: 1, col: 2 =====

======= OUT OF BOUNDS =======

🟣 dfs(1, 2, 2) returned, row is 1, col is 1

this is dfs(1, 1, 1), going left, searching for &#39;E&#39;

===== row: 1, col: 0 =====
found E, currentCell is E, idx is 2
this is dfs(1, 0, 2), going down, searching for &#39;undefined&#39;

===== row: 2, col: 0 =====
🎉 this is dfs(2, 0, 3), FINISHED ALREADY, &#39;PIE&#39; HAS BEEN FOUND
🟣 dfs(2, 0, 3) returned, row is 1, col is 0

this is dfs(1, 0, 2), going up, searching for &#39;undefined&#39;

===== row: 0, col: 0 =====
🎉 this is dfs(0, 0, 3), FINISHED ALREADY, &#39;PIE&#39; HAS BEEN FOUND
🟣 dfs(0, 0, 3) returned, row is 1, col is 0

this is dfs(1, 0, 2), going right, searching for &#39;undefined&#39;

===== row: 1, col: 1 =====
🎉 this is dfs(1, 1, 3), FINISHED ALREADY, &#39;PIE&#39; HAS BEEN FOUND
🟣 dfs(1, 1, 3) returned, row is 1, col is 0

this is dfs(1, 0, 2), going left, searching for &#39;undefined&#39;

===== row: 1, col: -1 =====
🎉 this is dfs(1, -1, 3), FINISHED ALREADY, &#39;PIE&#39; HAS BEEN FOUND
🟣 dfs(1, -1, 3) returned, row is 1, col is 0

🟣 dfs(1, 0, 2) returned, row is 1, col is 1

🟣 dfs(1, 1, 1) returned, row is 0, col is 1

this is dfs(0, 1, 0), going up, searching for &#39;I&#39;

===== row: -1, col: 1 =====

======= OUT OF BOUNDS =======

🟣 dfs(-1, 1, 1) returned, row is 0, col is 1

this is dfs(0, 1, 0), going right, searching for &#39;I&#39;

===== row: 0, col: 2 =====

======= OUT OF BOUNDS =======

🟣 dfs(0, 2, 1) returned, row is 0, col is 1

this is dfs(0, 1, 0), going left, searching for &#39;I&#39;

===== row: 0, col: 0 =====
looking for &#39;I&#39;, this is A
🟣 dfs(0, 0, 1) returned, row is 0, col is 1

true
</code></pre>
<p>There are several insights here — for example, note that this line:</p>
<pre><code>this is dfs(1, 0, 2), going down, searching for &#39;undefined&#39;
</code></pre>
<p>indicates that we still go looking for <code>word[idx + 1]</code> even though the current index is the index of the last character in <code>word</code>.</p>
<p>It, of course, continues exploring every direction left from there on:</p>
<pre><code>this is dfs(1, 0, 2), going up, searching for &#39;undefined&#39;
</code></pre>
<pre><code>this is dfs(1, 0, 2), going right, searching for &#39;undefined&#39;
</code></pre>
<pre><code>this is dfs(1, 0, 2), going left, searching for &#39;undefined&#39;
</code></pre>
<p>Again, also these lines:</p>
<pre><code>this is dfs(0, 1, 0), going up, searching for &#39;I&#39;
</code></pre>
<pre><code>this is dfs(0, 1, 0), going right, searching for &#39;I&#39;
</code></pre>
<pre><code>this is dfs(0, 1, 0), going left, searching for &#39;I&#39;
</code></pre>
<p>indicate that once the control returns to the function that has found <code>&#39;P&#39;</code>, it&#39;ll still continue exploring all the directions left from there. We&#39;ve already found <code>&#39;PIE&#39;</code> by going down, but the other directions are still being explored.</p>
<h4>Time and space complexity</h4>
<p>The time complexity will be</p>
<p>$$O(\text{ length of rows } * \text{ length of columns } * 4^{\text{ length of the word }})$$</p>
<p>We can denote it succinctly as $O(n * m * 4^l)$ where $n$ is the length of rows, $m$ is the length of columns, and $l$ is the length of the word. The reason is that we call <code>dfs</code> for each cell on the board ($n * m$), and there can be $4^l$ recursive calls to <code>dfs</code>.</p>
<p>The space complexity is going to be $O(l)$ where $l$ is the length of the word, as the stack depth can reach $l$ in the worst case.</p>
<hr>
<p>Backtracking might not be very efficient or elegant, and it&#39;s definitely a brute force solution for a given problem. Now that we&#39;re done with this chapter, we can take a deep breath.</p>
<p>Next up, we&#39;ll take a look at the <a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener noreferrer">trie data structure</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-word-search</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-word-search</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 20 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Combination Sum]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-19/46-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/combination-sum" target="_blank" rel="noopener noreferrer">Combination Sum</a>:</p>
<blockquote>
<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>
<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>
</blockquote>
<p>For example:</p>
<pre><code>Input: candidates = [2, 3, 6, 7], target = 7

Output: [[2, 2, 3], [7]]

Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
</code></pre>
<p>Or:</p>
<pre><code>Input: candidates = [2, 3, 5], target = 8

Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]
</code></pre>
<hr>
<p>One thing to notice here is that we can have duplicate values — for instance, in the second example, <code>[2, 2, 2, 2]</code> is a possible option for a given target of <code>8</code>.</p>
<p><mark>We can try adding the same item to the <em>current total</em>, until it&#39;s equal to the target or is more than the target.</mark> If the current total ends up being equal to the target, we&#39;ll add the numbers we&#39;ve gathered so far to our result. Otherwise, we&#39;ll backtrack, and try the next item in <code>candidates</code>.</p>
<p>We&#39;ll have two important variables to help us here: <code>currentNums</code> which has the current numbers we&#39;re looking at, and <code>currentTotal</code> which is the sum of <code>currentNums</code>.</p>
<p>For the first base case where we can add the <code>currentNums</code> to the result, we&#39;ll check if the <code>currentTotal</code> equals <code>target</code>:</p>
<pre><code class="language-ts">if (currentTotal === target) {
  result.push([...currentNums]);
  return;
}
</code></pre>
<p>Another case where we need to return is when we&#39;ve looked at all the items in <code>candidates</code> or when <code>currentTotal</code> has surpassed <code>target</code>:</p>
<pre><code class="language-ts">if (idx &gt;= candidates.length || currentTotal &gt; target) {
  return;
}
</code></pre>
<Note>
`idx` will be the index of the item in `candidates` that we're adding to `currentNums`.
</Note>

<p>The process mentioned above goes like this:</p>
<pre><code class="language-ts">currentNums.push(candidates[idx]);
backtrack(idx, currentNums, currentTotal + candidates[idx]);
currentNums.pop();
backtrack(idx + 1, currentNums, currentTotal);
</code></pre>
<p>And, that&#39;s all there is to the <code>backtrack</code> function:</p>
<pre><code class="language-ts">function backtrack(idx: number, currentNums: number[], currentTotal: number) {
  if (currentTotal === target) {
    result.push([...currentNums]);
    return;
  }

  if (idx &gt;= candidates.length || currentTotal &gt; target) {
    return;
  }

  currentNums.push(candidates[idx]);
  backtrack(idx, currentNums, currentTotal + candidates[idx]);
  currentNums.pop();
  backtrack(idx + 1, currentNums, currentTotal);
}
</code></pre>
<p>For example, let&#39;s say that the <code>candidates</code> array is <code>[2, 3, 5]</code> and the target is <code>5</code>. </p>
<p>The first item is <code>2</code>, so we&#39;ll add it to itself until it reaches <code>6</code> (<code>2 + 2 + 2</code>), the point where the current total is more than the target. </p>
<Note>
Remember that we're keeping track of the numbers we gather, at this point the `currentNums` are `[2, 2, 2]`.
</Note>

<p>Now that we&#39;re over the target, we&#39;ll pop the last <code>2</code> from <code>currentNums</code>, and add the next item in <code>candidates</code>, which is <code>3</code>. Now, our current total is <code>2 + 2 + 3</code>, which is again more than the target, so we&#39;ll pop <code>3</code>. We&#39;ll go on to <code>5</code>, and our current total will be <code>2 + 2 + 5</code>, which is of course more than the target, so we&#39;ll pop <code>5</code> as well.</p>
<p>At this point, we&#39;re left with <code>2 + 2</code>, but we tried all the items in <code>candidates</code>, so we&#39;ll pop the last <code>2</code> from <code>currentNums</code> again. </p>
<p>Now, our current total is just <code>2</code>. So, we go on, and add the next item in <code>candidates</code>, and now, our current total is <code>2 + 3</code> which equals our target. We&#39;ll add it to our result and return. </p>
<p>We&#39;ll try the next item, our current total is now <code>2 + 5</code>. It is more than the target, so we&#39;ll pop the last item, and once again we&#39;re only left with <code>2</code> as our current total. But, we tried all the items again, so we&#39;ll pop this <code>2</code> as well.</p>
<p>We tried every possible combination for <code>2</code>, so now it&#39;s time to look at <code>3</code>.</p>
<p>We&#39;ll add <code>3</code> to itself until it&#39;s more than or equal to the target. Our current total will reach <code>3 + 3</code>, which is more than the target, so we&#39;ll pop the last <code>3</code> from <code>currentNums</code>. Now, we&#39;ll go on to the next item, our current total will be <code>3 + 5</code>, which exceeds the target again, so we&#39;ll pop <code>5</code>.<br>At this point we&#39;ve tried all the items for <code>3</code>, so it&#39;s now time to pop <code>3</code> as well.</p>
<p>We go on to <code>5</code>, and as our current total is just <code>5</code> which is equal to the target, we&#39;ll add it to our result. There is no next item we can try with <code>5</code>, so we&#39;ll pop it off. </p>
<p>We don&#39;t have any items left to look at, so we&#39;re done.<br>Our result is <code>[[2, 3], [5]]</code>.</p>
<p>The final solution in TypeScript looks like this:</p>
<pre><code class="language-ts">function combinationSum(candidates: number[], target: number): number[][] {
  let result: number[][] = [];
  let nums = [];

  function backtrack(idx: number, currentNums: number[], currentTotal: number) {
    if (currentTotal === target) {
      result.push([...currentNums]);
      return;
    }

    if (idx &gt;= candidates.length || currentTotal &gt; target) {
      return;
    }

    currentNums.push(candidates[idx]);
    backtrack(idx, currentNums, currentTotal + candidates[idx]);
    currentNums.pop();
    backtrack(idx + 1, currentNums, currentTotal);
  }

  backtrack(0, nums, 0);

  return result;
}
</code></pre>
<p><em>For a more detailed explanation of this solution, see <a href="https://www.youtube.com/watch?v=GBKI9VSKdGg" target="_blank" rel="noopener noreferrer">NeetCode&#39;s video</a> on this problem.</em></p>
<h4>Time and space complexity</h4>
<p>There are different opinions on the time complexity of this solution. The most likely one is—I think—$2^t$ where $t$ is the target number. The reason is related to the height of the <em>decision tree</em>. For example, if the first item in <code>candidates</code> is <code>1</code>, the number of calls to <code>backtrack</code> will be, in the worst case, equal to the target.<br>The space complexity can be $O(t)$ where $t$ is the target, because the recursive call stack can reach a depth of $t$ in the worst case.</p>
<hr>
<p>This is, in my opinion, a very challenging problem, so it&#39;s now time to take a breath. Next, we&#39;ll look at <a href="https://leetcode.com/problems/word-search" target="_blank" rel="noopener noreferrer">Word Search</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-combination-sum</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-combination-sum</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 19 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 9: Backtracking]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-17/45-lm-ch9.png" alt="Cover image"></p>
<p>Let&#39;s start with admitting this one fact: backtracking is hard. Or rather, <em>understanding it the first time</em> is hard.<br>Or, it&#39;s one of those concepts that you think you grasped it, only to realize later that you actually didn&#39;t.</p>
<p>We&#39;ll focus on one problem of finding the subsets of an array, but before that, let&#39;s imagine that we&#39;re walking along a path. </p>
<p>Then, we reach a fork. We pick one of the paths, and walk. </p>
<p>Then, we reach another fork in the path. We pick one of the paths again, and go on walking, <mark>then we reach a dead end. So, we <em>backtrack</em></mark> to the last point we had a fork, then go through the other path that we didn&#39;t choose the first time.</p>
<p>Then we reach another dead end. So, we <em>backtrack</em> once more and realize that there are no other paths we can go from there. So we <em>backtrack</em> again, and explore the other path we didn&#39;t choose the first time we came to this point. </p>
<p>We reach yet another dead end, so we <em>backtrack</em>. We see that there are no more paths to explore, so we <em>backtrack</em> once more. </p>
<p>Now, we&#39;re at our starting point. There are no more paths left to explore, so we can stop walking.</p>
<p>It was a nice but tiring walk, and it went like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-17/backtracking.gif" alt="Backtracking"></p>
<p>Now, let&#39;s take a look at an actual LeetCode problem.</p>
<h4>Subsets</h4>
<p>The description for <a href="https://leetcode.com/problems/subsets" target="_blank" rel="noopener noreferrer">Subsets</a> says:</p>
<blockquote>
<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
</blockquote>
<p>For example:</p>
<pre><code>Input: nums = [1, 2, 3]
Output: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
</code></pre>
<p>Or:</p>
<pre><code>Input: nums = [0]
Output: [[], [0]]
</code></pre>
<p>Before diving into the solution code, let&#39;s take a look at how backtracking will work in this case. Let&#39;s call the <code>nums</code> array <code>items</code> instead:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-17/backtracking-subsets-nums.gif" alt="Backtracking decision tree 1"></p>
<p>For each item in <code>items</code>, we have initially two choices: to include the item, or not to include it.</p>
<p>For each level $n$ in this <em>decision tree</em>, we have the option to include the next item in <code>items</code>. We have $2^n$ possible subsets in total.</p>
<p>Let&#39;s simplify the example a bit, and say that <code>items</code> is now <code>[&#39;a&#39;, &#39;b&#39;]</code> (<strong>We&#39;ll ignore the problem specifics for now</strong>).</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-17/backtracking-subsets-2.gif" alt="Backtracking decision tree 2"></p>
<p>In this case, we can use backtracking like this:</p>
<pre><code class="language-ts">function subsets(items: string[]) {
  let result: string[][] = [];
  let currentSubset: string[] = [];

  function backtrack(idx: number) {
    if (idx &gt;= items.length) {
      result.push([...currentSubset]);
      return;
    }

    currentSubset.push(items[idx]);
    backtrack(idx + 1);

    currentSubset.pop();
    backtrack(idx + 1);
  }

  backtrack(0);

  return result;
}

console.log(subsets([&#39;a&#39;, &#39;b&#39;]));
// -&gt; [[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;], [&#39;b&#39;], []]
</code></pre>
<p>Well, it looks simple at first glance, but what&#39;s going on?</p>
<p>One thing to notice is that we <code>pop</code> from the <code>currentSubset</code>, then call <code>backtrack</code>. In our example of walking, that&#39;s the part we go back to our previous point, and continue our walk.</p>
<p>In the first animation, we indicated a dead end with a cross mark, and in this case, a dead end is the <em>base case</em> we reach.</p>
<p>It might still be tough to understand, so let&#39;s add some helpful <code>console.log</code>s, and see the output:</p>
<pre><code class="language-ts">function subsets(items: string[]) {
  let result: string[][] = [];
  let currentSubset: string[] = [];

  function backtrack(idx: number) {
    console.log(`======= this is backtrack(${arguments[0]}) =======`)
    if (idx &gt;= items.length) {
      console.log(`idx is ${idx}, currentSubset is [${currentSubset}], adding it to result...`);
      result.push([...currentSubset]);
      console.log(`backtrack(${arguments[0]}) is returning...\n`)
      return;
    }

    currentSubset.push(items[idx]);
    console.log(`added ${items[idx]} to currentSubset, inside backtrack(${arguments[0]})`);
    console.log(`calling backtrack(${idx + 1})...`)
    backtrack(idx + 1);

    let item = currentSubset.pop();
    console.log(`popped ${item} from currentSubset, inside backtrack(${arguments[0]})`);
    console.log(`calling backtrack(${idx + 1})...`)
    backtrack(idx + 1);

    console.log(`******* done with backtrack(${arguments[0]}) *******\n`);
  }

  backtrack(0);

  return result;
}

console.log(subsets([&#39;a&#39;, &#39;b&#39;]));
</code></pre>
<p>The output looks like this:</p>
<pre><code>======= this is backtrack(0) =======
added a to currentSubset, inside backtrack(0)
calling backtrack(1)...
======= this is backtrack(1) =======
added b to currentSubset, inside backtrack(1)
calling backtrack(2)...
======= this is backtrack(2) =======
idx is 2, currentSubset is [a,b], adding it to result...
backtrack(2) is returning...

popped b from currentSubset, inside backtrack(1)
calling backtrack(2)...
======= this is backtrack(2) =======
idx is 2, currentSubset is [a], adding it to result...
backtrack(2) is returning...

******* done with backtrack(1) *******

popped a from currentSubset, inside backtrack(0)
calling backtrack(1)...
======= this is backtrack(1) =======
added b to currentSubset, inside backtrack(1)
calling backtrack(2)...
======= this is backtrack(2) =======
idx is 2, currentSubset is [b], adding it to result...
backtrack(2) is returning...

popped b from currentSubset, inside backtrack(1)
calling backtrack(2)...
======= this is backtrack(2) =======
idx is 2, currentSubset is [], adding it to result...
backtrack(2) is returning...

******* done with backtrack(1) *******

******* done with backtrack(0) *******

[ [ &#39;a&#39;, &#39;b&#39; ], [ &#39;a&#39; ], [ &#39;b&#39; ], [] ]
</code></pre>
<p>If you noticed, <em>Add <code>&#39;a&#39;</code>?</em> and <em>Go ahead?</em> arrows on the first level are calls to <code>backtrack(0)</code>. </p>
<p><em>Add <code>&#39;b&#39;</code>?</em> and <em>Go ahead?</em> arrows on the second level are calls to <code>backtrack(1)</code>.</p>
<p><code>backtrack(2)</code> calls are when we reach the &quot;dead ends,&quot; in those cases, we add <code>currentSubset</code> to the <code>result</code>.<br>We always reach the base case in a <code>backtrack(2)</code> call, obviously because it&#39;s only when the <code>idx</code> equals <code>items.length</code>.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-17/backtracking-subsets-func.gif" alt="Backtracking function"></p>
<Note>
We modified the function in the above examples to work with strings, but in the actual solution we'll only deal with numbers, so in TypeScript, `result` and `currentSubset` will look like this:

<pre><code class="language-ts">let result: number[][] = [];
let currentSubset: number[] = [];
</code></pre>
<p>Also, the function parameter and return types are different:</p>
<pre><code class="language-ts">function subsets(nums: number[]): number[][] { ... }
</code></pre>
<p>Otherwise, everything stays the same.<br></Note></p>
<h4>Time and space complexity</h4>
<p>A subset is, in the worst case, length $n$ which is the length of our input. We&#39;ll have $2^n$ subsets and since we also use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener noreferrer">spread operator</a> to copy <code>currentSubset</code>, the time complexity will be $O(n \cdot 2^n)$. The space complexity is—<em>I think</em>— $O(n \cdot 2^n)$ as well because of the recursive call stack (which is of depth <code>n</code>), and the space needed for <code>result</code> (which is in the worst case $2^n$).</p>
<hr>
<p>Now it&#39;s time to take a deep breath, and maybe go on an actual walk. This has been a challenging concept to grasp, and perhaps the only thing that can make it click is a real walk in nature, with some backtracking along the way.</p>
<p>The first problem in this chapter is <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener noreferrer">Combination Sum</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-9-backtracking</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-9-backtracking</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 17 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Find Median from Data Stream]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-14/44-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener noreferrer">this one</a>:</p>
<blockquote>
<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>
<ul>
<li>For example, for <code>arr = [2, 3, 4]</code>, the median is <code>3</code>.</li>
<li>For example, for <code>arr = [2, 3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>
</ul>
<p>Implement the MedianFinder class:</p>
<ul>
<li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li>
<li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li>
<li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10^-5</code> of the actual answer will be accepted.</li>
</ul>
</blockquote>
<p>For example:</p>
<pre><code>Input:
[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]
[[], [1], [2], [], [3], []]

Output:
[null, null, null, 1.5, null, 2.0]

Explanation:
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
</code></pre>
<hr>
<p>This question is labeled as a hard one; however, <em>finding the median</em> itself is not hard. </p>
<p>The first idea that comes to mind is that we can continually add the numbers to an array, keep sorting it each time we do so, and return the median accordingly.</p>
<p>In fact, let&#39;s try it in TypeScript:</p>
<pre><code class="language-ts">class MedianFinder {
  public nums: number[];

  constructor() {
    this.nums = [];
  }

  addNum(num: number): void {
    this.nums.push(num);
    this.nums.sort((a, b) =&gt; a - b);
  }

  findMedian(): number {
    let mid = Math.floor(this.nums.length / 2);

    if (this.nums.length % 2 === 0) {
      let mid1 = Math.floor(this.nums.length / 2) - 1;
      return (this.nums[mid] + this.nums[mid1]) / 2;
    } 

    return this.nums[mid];
  }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
</code></pre>
<Note>
If the length of `nums` is even, we're returning the average of two middle values.
</Note>

<p>Even though it passes <em>some</em> of the tests, it will end up with a <strong>Time Limit Exceeded</strong> error at one point, so we have to do better.</p>
<p>Indeed, let&#39;s take a deep breath, because we&#39;ll make use of <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-8-heap-and-priority-queue" target="_blank" rel="noopener noreferrer">heaps</a> for an elegant solution.</p>
<hr>
<p>When we think about it, <mark>if we have an even number of sorted numbers, the median will be the average of <strong>the maximum of the smaller half</strong> and <strong>the minimum of the larger half</strong></mark>.</p>
<p>For example, if our numbers are these:</p>
<pre><code class="language-ts">[3, 4, 7, 9]
</code></pre>
<p>the median is the average of <code>4</code> and <code>7</code> (which is <code>5.5</code>). </p>
<p><em>The smaller half</em> is <code>[3, 4]</code>, while the larger half is <code>[7, 9]</code>. Indeed, <code>4</code> is the maximum in the smaller half and <code>7</code> is the minimum in the larger half.</p>
<p>However, <mark>if we have an odd length of numbers, we can just get either the maximum value from the smaller half, or the minimum value from the larger half</mark>.</p>
<p>Say, our numbers are these:</p>
<pre><code class="language-ts">[3, 4, 7]
</code></pre>
<p>In this case, the smaller half can be <code>[3, 4]</code>, and the larger half can be <code>[7]</code>, so we can get the maximum value from the smaller half, which is <code>4</code>, and be done with it.</p>
<p>Or, if the smaller half is just <code>[3]</code>, and the larger half is <code>[4, 7]</code>, we&#39;ll get the minimum value from the larger half, which is still <code>4</code>.</p>
<Note>
We refer to these parts as _halves_, but they don't have to be exactly the same size. However, <mark>the sizes can only differ by at most 1 because they still have to be _roughly_ the same size, halving the numbers.</mark>
</Note>

<p>You might already have an inkling that what we&#39;re talking about as <em>the smaller half</em> is a perfect candidate for a <strong>max heap</strong> because we&#39;re only concerned with the maximum value. Similarly, <em>the larger half</em> begs to be implemented as a <strong>min heap</strong> as we only deal with the minimum value in it. Of course, the elegance lies in the fact that we can get these values in constant time.</p>
<p>We are going to use TypeScript for the solution, and LeetCode&#39;s TypeScript environment (well, in fact, JavaScript environment) <a href="https://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages" target="_blank" rel="noopener noreferrer">includes</a> a handy package for using heaps (or, priority queues): Enter <a href="https://www.npmjs.com/package/@datastructures-js/priority-queue" target="_blank" rel="noopener noreferrer">@datastructures-js/priority-queue</a>!</p>
<p>We can use this package to create our max and min heaps, and make use of the functionality it gives such as enqueueing/dequeueing data. </p>
<p>So, inside the constructor of our <code>MedianFinder</code> class, we can initialize our min and max heaps:</p>
<pre><code class="language-ts">class MedianFinder {
  public minHeap;
  public maxHeap;
  
  constructor() {
    this.minHeap = new MinPriorityQueue();
    this.maxHeap = new MaxPriorityQueue();
  }

  ...
}
</code></pre>
<p>Now, when it comes to adding a number, we need to choose a heap to add it into. We can choose either of them when we&#39;re starting off with empty heaps; however, let&#39;s use the max heap for adding a number first. That means, when we&#39;re going to add a number, we&#39;ll first try to put it in the max heap. But, we can only do it when the number we&#39;re going to add is less than the maximum value in the heap, or when the heap is empty. Otherwise, we can add it to the min heap.</p>
<p>So, we can have a handy <code>getHeap</code> function inside our class for choosing the heap to add the number into:</p>
<pre><code class="language-ts">getHeap(n: number) {
  if (this.maxHeap.isEmpty() || n &lt;= this.maxHeap.front().element) {
    return this.maxHeap;
  }

  return this.minHeap;
}
</code></pre>
<Note>
We can have duplicates in a heap, so we're checking if the number is less than or _equal to_ `maxHeap.front().element` instead of only using the "less than" operator.
</Note>

<p>However, once we add the number, we need to make sure that the sizes of the heaps don&#39;t differ by more than 1. In that case, we&#39;ll dequeue the maximum value from the max heap, and enqueue it to the min heap:</p>
<pre><code class="language-ts">if ((this.maxHeap.size() - this.minHeap.size()) &gt; 1) {
  let num = this.maxHeap.dequeue().element;
  this.minHeap.enqueue(num);
}
</code></pre>
<p>If, however, the size of the min heap becomes larger than the size of the max heap, we need to rearrange things, and this time <em>dequeue</em> from the min heap to <em>enqueue</em> the value to the max heap:</p>
<pre><code class="language-ts">if (this.maxHeap.size() &lt; this.minHeap.size()) {
  let num = this.minHeap.dequeue().element;
  this.maxHeap.enqueue(num);
}
</code></pre>
<p>We can add these conditions to a separate <code>rebalanceHeaps</code> function for modularity&#39;s sake:</p>
<pre><code class="language-ts">rebalanceHeaps(): void {
  if ((this.maxHeap.size() - this.minHeap.size()) &gt; 1) {
    let num = this.maxHeap.dequeue().element;
    this.minHeap.enqueue(num);
  }

  if (this.maxHeap.size() &lt; this.minHeap.size()) {
    let num = this.minHeap.dequeue().element;
    this.maxHeap.enqueue(num);
  }
}
</code></pre>
<p>And now, we&#39;re done with <code>addNum</code> itself. We only <em>enqueued</em> the new number to the proper heap, and rebalanced the heaps:</p>
<pre><code class="language-ts">addNum(num: number): void {
  this.getHeap(num).enqueue(num);
  this.rebalanceHeaps();
}
</code></pre>
<p>Now, finding the median is a piece of cake. And, it&#39;s delicious because we&#39;ll get it in constant time:</p>
<pre><code class="language-ts">findMedian(): number {
  let maxOfSmallerHalf = this.maxHeap.front().element;

  if (this.maxHeap.size() === this.minHeap.size()) {
    let minOfLargerHalf = this.minHeap.front().element;

    return (maxOfSmallerHalf + minOfLargerHalf) / 2;
  }

  return maxOfSmallerHalf;
}
</code></pre>
<Note>
If the sizes of the heaps are equal (`this.maxHeap.size() === this.minHeap.size()`), we have an even length of numbers.
</Note>

<p>And finally, here is the whole solution:</p>
<pre><code class="language-ts">class MedianFinder {
  public minHeap;
  public maxHeap;

  constructor() {
    this.minHeap = new MinPriorityQueue();
    this.maxHeap = new MaxPriorityQueue();
  }

  addNum(num: number): void {
    this.getHeap(num).enqueue(num);
    this.rebalanceHeaps();
  }

  findMedian(): number {
    let maxOfSmallerHalf = this.maxHeap.front().element;

    if (this.maxHeap.size() === this.minHeap.size()) {
      let minOfLargerHalf = this.minHeap.front().element;

      return (maxOfSmallerHalf + minOfLargerHalf) / 2;
    }

    return maxOfSmallerHalf;
  }

  getHeap(n: number) {
    if (this.maxHeap.isEmpty() || n &lt;= this.maxHeap.front().element) {
      return this.maxHeap;
    }

    return this.minHeap;
  }

  rebalanceHeaps(): void {
    if ((this.maxHeap.size() - this.minHeap.size()) &gt; 1) {
      let num = this.maxHeap.dequeue().element;
      this.minHeap.enqueue(num);
    }

    if (this.maxHeap.size() &lt; this.minHeap.size()) {
      let num = this.minHeap.dequeue().element;
      this.maxHeap.enqueue(num);
    }
  }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
</code></pre>
<p><em>This version is adapted from <a href="https://github.com/neetcode-gh/leetcode/blob/main/typescript/0295-find-median-from-data-stream.ts" target="_blank" rel="noopener noreferrer">@kx0101&#39;s solution</a></em>.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is going to be $O(log \ n)$ because of the <code>enqueue</code> and <code>dequeue</code> operations on the heaps. However, getting the max value (or, the min value) is always $O(1)$.</p>
<p>The space complexity is $O(n)$ as we need to create heaps to hold the numbers we have, and their sizes will grow as the length of the numbers increases.</p>
<hr>
<p>And, this is the end of the chapter on heaps! Next up, we&#39;ll take a look at the technique of backtracking.<br>Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-find-median-from-data-stream</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-find-median-from-data-stream</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 14 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 8: Heap/Priority Queue]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-12/43-lm-ch8.png" alt="Cover image"></p>
<h2>Table of contents</h2>
<ul>
<li><a href="#intro" target="_blank" rel="noopener noreferrer">Introduction</a></li>
<li><a href="#heap-properties" target="_blank" rel="noopener noreferrer">Heap properties</a></li>
<li><a href="#heaps-with-arrays" target="_blank" rel="noopener noreferrer">Heaps with arrays</a></li>
<li><a href="#insert-remove" target="_blank" rel="noopener noreferrer">Inserting/removing elements</a></li>
<li><a href="#heapsort" target="_blank" rel="noopener noreferrer">Heap sort</a><ul>
<li><a href="#heapsort-complexity" target="_blank" rel="noopener noreferrer">Time and space complexity</a></li>
</ul>
</li>
<li><a href="#resources" target="_blank" rel="noopener noreferrer">Resources</a></li>
</ul>
<p><a name="intro"></a></p>
<p>In this new chapter, we&#39;re going to take a look at a <a href="https://en.wikipedia.org/wiki/Data_structure" target="_blank" rel="noopener noreferrer"><em>data structure</em></a> called a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank" rel="noopener noreferrer">heap</a>, which is a great way to implement an <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank" rel="noopener noreferrer"><em>abstract data type</em></a> called a <a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="noopener noreferrer">priority queue</a>. They&#39;re so interrelated that priority queues are sometimes referred to as heaps — because heaps are a very efficient way to create a priority queue. But, let&#39;s not get ahead of ourselves, and take a deep breath first before we start.</p>
<hr>
<p><a name="heap-properties"></a></p>
<h3>Heap properties</h3>
<p>The kind of heap we&#39;re interested in is also called a <em>binary heap</em> because it&#39;s just a binary tree that has specific properties. </p>
<p>One of them is that it must be a <em><strong>complete binary tree</strong></em>, meaning that all the levels must be filled, and <mark><em>all nodes in the last level should be as far left as possible</em></mark>.</p>
<p>For example, when it comes to shape, this is a <strong>complete</strong> binary tree:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-12/complete-binary-tree.gif" alt="The shape of a complete binary tree"></p>
<p>However, <mark>heaps must also be either a <strong>max heap</strong> or a <strong>min heap</strong></mark> — all the parent nodes must be either greater than or equal to the values of their children (if it&#39;s a max heap); or less than or equal to the values of their children (if it&#39;s a min heap).</p>
<p>A max heap might look like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-12/max-heap.gif" alt="An example of a max heap"></p>
<Note>
A left child doesn't have to be less than the right child at all, as in a binary search tree. Also, we can always have duplicate values in a heap.
</Note>

<p>A min heap, on the other hand, has the values of parent nodes less than those of their children:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-12/min-heap.gif" alt="An example of a min heap"></p>
<Note>
When we have a max heap, the root node will have the maximum value. And, if we have a min heap instead, the root node will have the minimum value.
</Note>

<hr>
<p><a name="heaps-with-arrays"></a></p>
<h3>Heaps with arrays</h3>
<p>We can create a heap using an array. Since the root node is the most interesting element with either a maximum or minimum value, it&#39;ll be the first element in our array, residing at the 0th index.</p>
<p>What&#39;s nice about using an array is that, given a parent node&#39;s index $i$, its left child will be at the index $2i + 1$, and its right child will be at the index $2i + 2$.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-12/heap-array.gif" alt="Heap as an array"></p>
<p>Given that, any child node&#39;s parent will be at the index $\lfloor{\frac{(n - 1)}{2}}\rfloor$. </p>
<Note>
$\lfloor$ and $\rfloor$ indicate the [floor function](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions).
</Note>

<p>One question we might ask at this moment is that why should we use an array at all? </p>
<p>The answer lies in the word <em>queue</em> of a <strong>priority queue</strong>. Since a queue is mainly concerned with the first element (following the <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener noreferrer">FIFO principle</a>), an array can be an ideal choice.<br>In a priority queue, each element has a priority, and the value with the highest priority is dequeued first. </p>
<hr>
<p><a name="insert-remove"></a></p>
<h3>Inserting/removing elements</h3>
<p>Let&#39;s take a look at how we can add an element to a heap.</p>
<p>We know that we have to add the new element to the bottom leftmost place, but once we do that, it might violate the max heap or the min heap property.</p>
<p>And how can we avoid violating the <em>heap-order property</em>? </p>
<p>We&#39;ll <em><strong>heapify</strong></em>, of course!</p>
<p>Let&#39;s say that we want to add a node with the value <code>20</code>:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-12/heapify-for-insert.gif" alt="Heapifying for insertion"></p>
<p>So, the <mark><em>heapify</em> is the swapping of nodes until we know that the heap-order property is maintained</mark>.</p>
<p>A similar thing happens when we need to remove an element. But since we&#39;re mainly concerned with the maximum or the minimum element, we just need to remove the root node. So, how are we going to do that?</p>
<p>We start off by swapping the last element (the bottom leftmost one) with the root. Now we can easily remove the &quot;root,&quot; which resides as a leaf node. However, we still need to maintain the heap-order property, so we need to <em><strong>heapify</strong></em> again.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-12/heapify-for-remove.gif" alt="Heapifying for removing"></p>
<hr>
<p><a name="heapsort"></a></p>
<h3>Heapsort</h3>
<p>Even better thing is that if we have a heap, and continually heapify it, we can sort an array!</p>
<p>Let&#39;s build a max heap first:</p>
<pre><code class="language-ts">function buildMaxHeap(arr: number[]) {
  /*
  Index of the last internal node 
  (i.e., the parent of the last leaf node, 
   or, the last non-leaf node).
  The last leaf node will reside at index arr.length - 1,
  so, we&#39;re getting its parent using the formula mentioned above.
  */
  let i = Math.floor((arr.length - 1) / 2);
    
  while (i &gt;= 0) {
    heapify(arr, i, arr.length);
    i--;
  }
    
  return arr;
}
</code></pre>
<p>Then, the <code>heapify</code> function:</p>
<pre><code class="language-ts">function heapify(arr: number[], i: number, maxLength: number) {
  while (i &lt; maxLength) {
    let index = i;
    let leftChildIdx = 2 * i + 1;
    let rightChildIdx = leftChildIdx + 1;

    if (leftChildIdx &lt; maxLength &amp;&amp; arr[leftChildIdx] &gt; arr[index]) {
      index = leftChildIdx;
    }

    if (rightChildIdx &lt; maxLength &amp;&amp; arr[rightChildIdx] &gt; arr[index]) {
      index = rightChildIdx;
    }
        
    if (index === i) { return; }
        
    // Swap
    [arr[i], arr[index]] = [arr[index], arr[i]];

    i = index;
  }
}
</code></pre>
<p>With a given index <code>i</code>, we get its left and right children indexes, and if the indexes are within bounds, we check if they are out of order. In that case, we make the <code>index</code> the index of the child, and swap the two nodes. Then, we continue with that new index, assigning it to <code>i</code>.</p>
<p>Now, <code>heapify</code> is nice and all, but how can we actually use it for sorting?</p>
<pre><code class="language-ts">function heapSort(arr: number[]) {
  buildMaxHeap(arr);

  let lastElementIdx = arr.length - 1;

  while (lastElementIdx &gt; 0) {
    [arr[0], arr[lastElementIdx]] = [arr[lastElementIdx], arr[0]];

    heapify(arr, 0, lastElementIdx);
    lastElementIdx--;
  }

  return arr;
}
</code></pre>
<Note>
Our max heap:

<pre><code class="language-js">[42, 19, 36, 17, 3, 25, 1, 2]
</code></pre>
<p>won&#39;t change when used in the <code>buildMaxHeap</code> function, as it&#39;s already a max heap!</p>
<p>However, if it were to have <code>17</code> as the right child of <code>42</code>, then <code>17</code> would have <code>25</code> as a child, which breaks the heap-order property. So, using <code>buildMaxHeap</code> with this broken version will correctly swap the <code>17</code> and <code>25</code>, making it a max heap:</p>
<pre><code class="language-ts">buildMaxHeap([42, 36, 17, 19, 3, 25, 1, 2]);

// -&gt; [42, 36, 25, 19, 3, 17, 1, 2]
</code></pre>
</Note>

<p>In <code>heapSort</code>, with our newly built max heap, we&#39;ll start with swapping the first and last nodes. Then, we&#39;ll keep heapifying until we get all the elements in their place.<br>If we use it with our very own max heap, we can see that it returns the sorted array:</p>
<pre><code class="language-ts">heapSort([42, 19, 36, 17, 3, 25, 1, 2]);
// -&gt; [1, 2, 3, 17, 19, 25, 36, 42]
</code></pre>
<p><em>The examples are adapted from <a href="https://medium.com/basecs/heapify-all-the-things-with-heap-sort-55ee1c93af82" target="_blank" rel="noopener noreferrer">Vaidehi Joshi&#39;s article</a>.</em></p>
<p><a name="heapsort-complexity"></a></p>
<h4>Time and space complexity</h4>
<p>Heap sort, as a nice sorting algorithm it is, runs in $O(n \ log \ n)$ time.</p>
<Note>
In this example, building the max heap starts from the last non-leaf node and goes up to the root node, each time calling `heapify`. The `heapify` function has a time complexity of $O(log \ n)$ as we're working with a binary tree, and in the worst case, we get to do it for all the levels. Since we do it $n / 2$ times, overall, `buildMaxHeap` has $O(n \ log \ n)$ time complexity.

<p>We&#39;re swapping the first and last elements, and heapifying as we go through each element, so this is also overall an $O(n \ log \ n)$ operation — which makes the time complexity of <code>heapSort</code> $O(n \ log \ n)$.<br></Note></p>
<br />

<Note>
Building the max heap [can be improved to have $O(n)$ runtime](https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity).
</Note>

<p>Since there is no use of auxiliary space, the space complexity is constant, $O(1)$.</p>
<hr>
<p>Now, we can take a deep breath. The one and only problem that we&#39;re going to look at in this chapter is called <a href="https://leetcode.com/problems/find-median-from-data-stream" target="_blank" rel="noopener noreferrer">Find Median from Data Stream</a>. Until then, happy coding.</p>
<p><a name="resources"></a></p>
<h5>Resources</h5>
<ul>
<li><a href="https://medium.com/basecs/learning-to-love-heaps-cef2b273a238" target="_blank" rel="noopener noreferrer">&quot;Learning to Love Heaps&quot; - Vaidehi Joshi</a></li>
<li><a href="https://medium.com/basecs/heapify-all-the-things-with-heap-sort-55ee1c93af82" target="_blank" rel="noopener noreferrer">&quot;Heapify All The Things With Heap Sort&quot; - Vaidehi Joshi</a></li>
<li><a href="https://brilliant.org/wiki/binary-heap/" target="_blank" rel="noopener noreferrer">Binary Heap - brilliant.org</a></li>
<li><a href="https://condor.depaul.edu/ntomuro/courses/402/notes/heap.html" target="_blank" rel="noopener noreferrer">Heap &amp; HeapSort - Noriko Tomuro</a></li>
<li><a href="https://faculty.cs.niu.edu/~freedman/340/340notes/340heap.htm" target="_blank" rel="noopener noreferrer">Heaps - Professor Reva Freedman</a></li>
</ul>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-8-heap-and-priority-queue</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-8-heap-and-priority-queue</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 12 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Serialize and Deserialize Binary Tree]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-04/42-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree" target="_blank" rel="noopener noreferrer">Serialize and Deserialize Binary Tree</a>:</p>
<blockquote>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p><strong>Clarification:</strong> The input/output format is the same as <a href="https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-" target="_blank" rel="noopener noreferrer">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
</blockquote>
<p>For example:</p>
<img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="Example image" />

<pre><code>Input: root = [1, 2, 3, null, null, 4, 5]
Output: [1, 2, 3, null, null, 4, 5]
</code></pre>
<hr>
<p>This one sounds easy, at least for the <code>serialize</code> function. We can just get the nodes one by one, and put them into a string. What could go wrong?</p>
<p>We can indeed get the nodes one by one, and put them into a string for <code>serialize</code>, but we need a proper method so that when it comes time to <code>deserialize</code>, we can reconstruct our binary tree.</p>
<p>One way to do it is using <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#bfs" target="_blank" rel="noopener noreferrer">breadth-first search</a>, in other words, a <em>level-order traversal</em>.  </p>
<p>We&#39;ll keep a result array which we&#39;ll transform into a string by joining the elements with the comma character (<code>,</code>). </p>
<p>We have seen how to do a level-order traversal before, but now when we see a <code>null</code> node, we don&#39;t ignore it, and instead add the string <code>&#39;null&#39;</code> to our <code>result</code>. Otherwise, we&#39;ll add the stringified version of the node&#39;s value using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener noreferrer">template literal</a>:</p>
<pre><code class="language-ts">function serialize(root: TreeNode | null): string {
  if (root === null) {
    return &#39;&#39;;
  }
  let queue = [root];
  let result = [];
  while (queue.length &gt; 0) {
    let node = queue[0];
    if (node === null) {
      result.push(&#39;null&#39;);
    } else {
      queue.push(node.left);
      queue.push(node.right);
      result.push(`${node.val}`);
    }
    queue.shift();
  }

  return result.join(&#39;,&#39;);
}
</code></pre>
<p><code>result</code> will include all the nodes level by level. For example, if our tree is the one in the example image above, then the <code>serialize</code> function will return this:</p>
<pre><code class="language-ts">&#39;1,2,3,null,null,4,5,null,null,null,null&#39;
</code></pre>
<p>So, <code>&#39;1&#39;</code> is the root node, and the next level is <code>&#39;2,3&#39;</code>. </p>
<p>The next level after that is <code>&#39;null,null,4,5&#39;</code>. The last four <code>&#39;null&#39;</code>s are for the children of <code>&#39;4&#39;</code> and <code>&#39;5&#39;</code>.</p>
<p>That&#39;s fine, but how can we use this string to construct a binary tree in <code>deserialize</code>?</p>
<p>The first thing we can do is check the edge case when the input <code>data</code> is an empty string. In that case, we can return <code>null</code>:</p>
<pre><code class="language-ts">if (data === &#39;&#39;) {
  return null;
}
</code></pre>
<p>Otherwise, since the <code>data</code> is a string that&#39;s constructed with commas, we can split it to get the values in an array.</p>
<pre><code class="language-ts">let vals = data.split(&#39;,&#39;);
</code></pre>
<p>We have to start with the root node somehow, and we know that the very first element in <code>vals</code> has the value for the root node. So we can construct it like this:</p>
<pre><code class="language-ts">let root = new TreeNode(+vals[0]);
</code></pre>
<Note>
We use the [unary plus (`+`) operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus) to easily convert the string into a number.
</Note>

<p>Now, we have to walk the tree, and make the tree.<br>Since we used a level-order traversal in <code>serialize</code>, we can use a queue again, initializing it with the <code>root</code>:</p>
<pre><code class="language-ts">let queue = [root];
</code></pre>
<p>Now, we can start iterating from the second element of the <code>vals</code> array since we already have the root, and add the nodes to our <code>queue</code>. And, to get the correct right and left children, we can simply use a flag value:</p>
<pre><code class="language-ts">let isRightChild = false;

for (let i = 1; i &lt; vals.length; i++) {
  let nodeVal = vals[i];
  let node = null;
  if (n !== &#39;null&#39;) {
    node = new TreeNode(+nodeVal);
    queue.push(node);
  }
  if (isRightChild) {
    queue[0].right = node;
    queue.shift();
    isRightChild = false;
  } else {
    queue[0].left = node;
    isRightChild = true;
  }
}
</code></pre>
<p><em>Since we already initialize <code>node</code> as <code>null</code>, all the <code>null</code> nodes will be &quot;inserted&quot; correctly.</em></p>
<p>With our <code>data</code> string looking like this:</p>
<pre><code class="language-ts">&#39;1,2,3,null,null,4,5,null,null,null,null&#39;
</code></pre>
<p>In the <code>for</code> loop, we&#39;ll start with <code>&#39;2&#39;</code>, and push it into our <code>queue</code>. Our <code>isRightChild</code> flag is initially <code>false</code>, so we&#39;ll add <code>2</code> as the left child of the first element in the <code>queue</code>, which is the root node. (<em>Remember that we initialized our <code>queue</code> with <code>root</code>.</em>)</p>
<p>Then, we&#39;ll go to <code>&#39;3&#39;</code>, push it into our <code>queue</code>, and since <code>isRightChild</code> is now <code>true</code>, we&#39;ll add it as the right child of <code>root</code>. </p>
<p>Now that we&#39;re finished with the <code>root</code>&#39;s children, we can remove it using <code>queue.shift()</code>, and go on to the next value.</p>
<p>The next value is <code>&#39;null&#39;</code>. In this case, we don&#39;t construct a <code>TreeNode</code>, but just point the left child of the first element in our <code>queue</code> (which is the node with the value <code>2</code>) to it.</p>
<p>We go on until there aren&#39;t any elements left in <code>vals</code>.</p>
<Note>
We're removing an element from the queue (using `queue.shift()`) only after we add its right child. Since this is a binary tree, and we're going level by level, we won't have another child to add for a node after we add its right child.
</Note>


<p>Finally, <code>deserialize</code> looks like this:</p>
<pre><code class="language-ts">function deserialize(data: string): TreeNode | null {
  if (data === &#39;&#39;) {
    return null;
  }

  let vals = data.split(&#39;,&#39;);
  let root = new TreeNode(+vals[0]);
    
  let queue = [root];
  let isRightChild = false;
    
  for (let i = 1; i &lt; vals.length; i++) {
    let nodeVal = vals[i];
    let node = null;
    if (n !== &#39;null&#39;) {
      node = new TreeNode(+nodeVal);
      queue.push(node);
    }
    if (isRightChild) {
      queue[0].right = node;
      queue.shift();
      isRightChild = false;
    } else {
      queue[0].left = node;
      isRightChild = true;
    }
  }
    
  return root;
}
</code></pre>
<p>And, this is the final solution in TypeScript:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

/*
 * Encodes a tree to a single string.
 */
function serialize(root: TreeNode | null): string {
  if (root === null) {
    return &#39;&#39;;
  }
  let queue = [root];
  let result = [];
  while (queue.length &gt; 0) {
    let node = queue[0];
    if (node === null) {
      result.push(&#39;null&#39;);
    } else {
      queue.push(node.left);
      queue.push(node.right);
      result.push(`${node.val}`);
    }
    queue.shift();
  }

  return result.join(&#39;,&#39;);
}

/*
 * Decodes your encoded data to tree.
 */
function deserialize(data: string): TreeNode | null {
  if (data === &#39;&#39;) {
    return null;
  }

  let vals = data.split(&#39;,&#39;);
  let root = new TreeNode(+vals[0]);
    
  let queue = [root];
  let isRightChild = false;
    
  for (let i = 1; i &lt; vals.length; i++) {
    let n = vals[i];
    let node = null;
    if (n !== &#39;null&#39;) {
      node = new TreeNode(+n);
      queue.push(node);
    }
    if (isRightChild) {
      queue[0].right = node;
      queue.shift();
      isRightChild = false;
    } else {
      queue[0].left = node;
      isRightChild = true;
    }
  }
    
  return root;
}


/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
</code></pre>
<h4>Time and space complexity</h4>
<p>The time and space complexity will both be $O(n)$ for both <code>serialize</code> and <code>deserialize</code>: In both functions, we process each node, and use a queue to hold all the nodes.</p>
<hr>
<p>We can take a deep breath now, because we have just finished the chapter on <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees" target="_blank" rel="noopener noreferrer">trees</a>! It&#39;s time to take a short hike and appreciate the <em>real</em> trees around us (and maybe plant one or two!).</p>
<p>Next up, we&#39;ll take a look at <a href="https://leetcodethehardway.com/tutorials/basic-topics/heap" target="_blank" rel="noopener noreferrer">heaps</a> — until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-serialize-and-deserialize-binary-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-serialize-and-deserialize-binary-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 04 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Binary Tree Maximum Path Sum]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-05-03/41-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener noreferrer">Binary Tree Maximum Path Sum</a>:</p>
<blockquote>
<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>
<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>
<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>
</blockquote>
<p>For example:</p>
<img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="Example image 1" />

<pre><code>Input: root = [1, 2, 3]
Output: 6
Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.
</code></pre>
<p>Or:</p>
<img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="Example image 2" />

<pre><code>Input: root = [-10, 9, 20, null, null, 15, 7]
Output: 42
Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.
</code></pre>
<hr>
<p>Although some people have found it <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/comments/1712502" target="_blank" rel="noopener noreferrer">quite simple</a>, this is a challenging problem. So, we&#39;ll take a deep breath, and take a look at a recursive <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#dfs" target="_blank" rel="noopener noreferrer">depth-first search</a> approach as shown by <a href="https://www.youtube.com/watch?v=Hr5cWUld4vU" target="_blank" rel="noopener noreferrer">NeetCode</a>.</p>
<p>When all we have is a root node and its children, the maximum value we can have is the total values of all three of them. Of course, however, if there is a negative value that&#39;s going to lower the maximum value we can get, we shouldn&#39;t include it.</p>
<p>From any root node&#39;s perspective, what we should do is get the total maximum value from the left subtree and the total maximum value from the right subtree. However, if we do the same thing for a node in one of the subtrees, we&#39;ll break our path. </p>
<p>That is, <mark>if we are going to add the values of both of the children of a node, then we can&#39;t do that again for another node, because it will break the path</mark>. Once we have chosen both the left and right children of a node, we cannot have both children of another node again, we can only choose one of them. In other words, <em>we can only split once</em>.</p>
<p>Let&#39;s imagine that we are the root node. We&#39;ll get the values of both our left and right children. We&#39;ll get the maximum value we can get from our left subtree, but each node in the left subtree can choose only one of their children. The same is true for the right subtree as well:</p>
<pre><code class="language-ts">/*
  maxLeft: the maximum value gained from the left subtree 
  where each node chose only one of their children

  maxRight: the maximum value gained from the right subtree 
  where each node chose only one of their children
*/
let currentMax = root.val + maxLeft + maxRight;
</code></pre>
<p>Once again, the reason that the nodes in the subtrees have to choose only one of their children is that the root node have already chosen both of its children. Otherwise, our path will break.</p>
<p>But, how can we get <code>maxLeft</code> and <code>maxRight</code>?<br>That&#39;s where the <em>depth-first</em> of depth-first search comes in:</p>
<pre><code class="language-ts">let maxLeft = dfs(root.left);
let maxRight = dfs(root.right);
</code></pre>
<p>We&#39;ll initialize our result value as the minimum possible value of <code>-Infinity</code> (because we want to get the possible maximum):</p>
<pre><code class="language-ts">let result = -Infinity;
</code></pre>
<p>Inside <code>dfs</code>, we need to update this value each time we calculate <code>currentMax</code>:</p>
<pre><code class="language-ts">result = Math.max(result, currentMax);
</code></pre>
<p>Remember that the nodes in the subtrees have to choose only one of their children? That&#39;s what our <code>dfs</code> function will return:</p>
<pre><code class="language-ts">return Math.max(root.val + maxLeft, root.val + maxRight, 0);
</code></pre>
<Note>
We include `0` as one of the possible maximum values as well, because a potential negative value can lower the maximum value we can have. `0` is better than a negative.
</Note>

<p>That&#39;s all there is to it. The final solution in TypeScript looks like this:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function maxPathSum(root: TreeNode | null): number {
  let result = -Infinity;

  function dfs(root: TreeNode | null) {
    if (root === null) {
      return 0;
    }

    let maxLeft = dfs(root.left);
    let maxRight = dfs(root.right);

    let currentMax = root.val + maxLeft + maxRight;
    result = Math.max(result, currentMax);

    return Math.max(root.val + maxLeft, root.val + maxRight, 0);    
  }

  dfs(root);
    
  return result;
}
</code></pre>
<Note>
`dfs` updates `result` as it runs, so in the outer function (`maxPathSum`), all we have to do is return it.
</Note>

<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ as we look at each node in the tree once. The space complexity is $O(h)$—where $h$ is the height of the tree—because of the stack frames created each time with the recursive calls.</p>
<hr>
<p>It&#39;s time to take another deep breath, because next up is yet another problem that&#39;s labeled as hard — <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree" target="_blank" rel="noopener noreferrer">Serialize and Deserialize Binary Tree</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-binary-tree-maximum-path-sum</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-binary-tree-maximum-path-sum</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 03 May 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Construct Binary Tree from Preorder and Inorder Traversal]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-30/40-lm.png" alt="Cover image"></p>
<p>Let&#39;s look at the description for <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener noreferrer">this problem</a>:</p>
<blockquote>
<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
</blockquote>
<p>For example:</p>
<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="Example image 1" />

<pre><code>Input: preorder = [3, 9, 20, 15, 7], inorder = [9, 3, 15, 20, 7]
Output: [3, 9, 20, null, null, 15, 7]
</code></pre>
<hr>
<p>Even though it has a medium difficulty label, I think this one can be quite challenging.</p>
<p>So, let&#39;s start with what we know.</p>
<p>We know that a <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#preorder" target="_blank" rel="noopener noreferrer">preorder traversal</a> first looks at the root node, then goes to the left subtree, then the right subtree.</p>
<p>To construct any tree, first of all, we need to start with the root. Here, we can do it easily like this:</p>
<pre><code class="language-ts">let root = new TreeNode(preorder[0]);
</code></pre>
<p>And, now?</p>
<p>We need to add the left and right children of the root somehow.<br>One idea is that we can get them recursively by partitioning the arrays. Let&#39;s look at this binary tree (which is also a <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#bst" target="_blank" rel="noopener noreferrer">binary search tree</a>):</p>
<img src="https://rivea0.github.io/blog/post-images/2024-04-15/bst-example1.png" width="50%"/>

<p>The <code>preorder</code> array in this case would be this:</p>
<pre><code class="language-ts">[8, 3, 1, 6, 4, 7, 10, 14, 13]
</code></pre>
<p>And, <code>inorder</code> would look like this:</p>
<pre><code class="language-ts">[1, 3, 4, 6, 7, 8, 10, 13, 14]
</code></pre>
<p>What we know about the <code>inorder</code> array is that <em><strong>all the values to the left of the root are in the left subtree</strong></em>. And, <em><strong>all the values to the right of the root are in the right subtree</strong></em>.<br>Remember that inorder traversal gets all the nodes in the left subtree first, then the root. Preorder traversal, however, gets the root first, then all the nodes in the left subtree.</p>
<p>Therefore, <em>the nodes in the left subtree + the root node</em> will be the in the same portion in both of the arrays:</p>
<p><code>preorder</code>: [<mark>8, 3, 1, 6, 4, 7</mark>, 10, 14, 13]</p>
<p><code>inorder</code>: [<mark>1, 3, 4, 6, 7, 8</mark>, 10, 13, 14]</p>
<p>If we get the root node&#39;s index in the <code>inorder</code> array, we can easily get the left subtree in the <code>preorder</code> array as well. The rest will be the right subtree:</p>
<table>
<thead>
<tr>
<th></th>
<th>left subtree</th>
<th>right subtree</th>
</tr>
</thead>
<tbody><tr>
<td><strong>preorder</strong></td>
<td>[8, <mark>3, 1, 6, 4, 7</mark>, 10, 14, 13]</td>
<td>[8, 3, 1, 6, 4, 7, <mark>10, 14, 13</mark>]</td>
</tr>
<tr>
<td><strong>inorder</strong></td>
<td>[<mark>1, 3, 4, 6, 7</mark>, 8, 10, 13, 14]</td>
<td>[1, 3, 4, 6, 7, 8, <mark>10, 13, 14</mark>]</td>
</tr>
</tbody></table>
<p>We can then slice the arrays to get the subtrees:</p>
<pre><code class="language-ts">let rootIdx = inorder.findIndex(i =&gt; i === root.val);

let preorderLeft = preorder.slice(1, rootIdx + 1);
let inorderLeft = inorder.slice(0, rootIdx);
let preorderRight = preorder.slice(rootIdx + 1, preorder.length);
let inorderRight = inorder.slice(rootIdx + 1, inorder.length);
</code></pre>
<Note>
One of the constraints in the problem says:

<blockquote>
<p><code>preorder</code> and <code>inorder</code> consist of unique values. </p>
</blockquote>
<p>So we&#39;ll always get the correct index.<br></Note></p>
<p>Now that we know where the subtrees reside, we can build our tree recursively.</p>
<p>Our base case is when one of the arrays is empty:</p>
<pre><code class="language-ts">if (preorder.length === 0 || inorder.length === 0) {
  return null;
}
</code></pre>
<p>And, here&#39;s the final solution in TypeScript:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function buildTree(preorder: number[], inorder: number[]): TreeNode | null {
  if (preorder.length === 0 || inorder.length === 0) {
    return null;
  }

  let root = new TreeNode(preorder[0]);
  let rootIdx = inorder.findIndex(i =&gt; i === root.val);

  // Get the left and right subtrees in preorder and inorder arrays
  let preorderLeft = preorder.slice(1, rootIdx + 1);
  let inorderLeft = inorder.slice(0, rootIdx);
  let preorderRight = preorder.slice(rootIdx + 1, preorder.length);
  let inorderRight = inorder.slice(rootIdx + 1, inorder.length);

  root.left = buildTree(preorderLeft, inorderLeft);
  root.right = buildTree(preorderRight, inorderRight);

  return root;
}
</code></pre>
<h4>Time and space complexity</h4>
<p>For each node that we calculate the index of, we also slice the arrays. <a href="https://stackoverflow.com/a/72545403" target="_blank" rel="noopener noreferrer">Slicing itself is an O(n) operation</a>, as well as finding the index. So, the overall time complexity is $O(n^2)$. The space complexity is in the worst case—<em>I think</em>—$O(n^2)$ as well because we create the slices in each recursive call which in the worst case can have $O(n)$ depth.</p>
<hr>
<p>The explanation of this approach can also be found in <a href="https://www.youtube.com/watch?v=ihj4IQGZ2zc" target="_blank" rel="noopener noreferrer">NeetCode&#39;s video</a>. </p>
<p>Next up, we&#39;ll look at the problem called <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener noreferrer">Binary Tree Maximum Path Sum</a>. Until then, happy coding. </p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-construct-binary-tree-from-preorder-and-inorder-traversal</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-construct-binary-tree-from-preorder-and-inorder-traversal</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 30 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Kth Smallest Element in a BST]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-28/39-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener noreferrer">Kth Smallest Element in a BST</a>:</p>
<blockquote>
<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>
</blockquote>
<p>For example:</p>
<img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="Example image 1" />

<pre><code>Input: root = [3, 1, 4, null, 2], k = 1
Output: 1
</code></pre>
<p>Or:</p>
<img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="Example image 2" />

<pre><code>Input: root = [5, 3, 6, 2, 4, null, null, 1], k = 3
Output: 3
</code></pre>
<hr>
<p>This problem naturally lends itself to a neat recursive solution using a neat traversal algorithm. </p>
<p>Remember <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#inorder" target="_blank" rel="noopener noreferrer">inorder traversal</a> that gives us the values in a binary search tree <em>in order</em>? Exactly.</p>
<p>Here, we can use it to build a stack called <code>values</code>, and get the <code>k</code>th item (1-indexed of course, as the problem description states):</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function kthSmallest(root: TreeNode | null, k: number): number {
  let values = [];
  function inorderWalk(node: TreeNode | null) {
    if (node === null || values.length === k) {
      return;
    }

    inorderWalk(node.left);
    values.push(node.val);
    inorderWalk(node.right);
  }

  inorderWalk(root);

  return values[k - 1];
}
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity is going to be $O(n)$ because we traverse the whole tree and visit each node once. The space complexity is also $O(n)$ as we keep a stack that holds all the nodes.</p>
<hr>
<p>That was a simple and elegant solution, but let&#39;s now take a breath and look at another solution that uses an <em><strong>iterative</strong></em> version of the inorder traversal:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function kthSmallest(root: TreeNode | null, k: number): number {
  let stack = [];
  let currentNode = root;

  while (k &gt; 0) {
    while (currentNode !== null) {
      stack.push(currentNode);
      currentNode = currentNode.left;
    }

    currentNode = stack.pop();
    k--;

    if (k === 0) {
      return currentNode.val;
    }

    currentNode = currentNode.right;
  }
}
</code></pre>
<p>Here, we go as deep as we can in the left subtree, adding the nodes to our <code>stack</code> as we go. Once we reach a node that doesn&#39;t have a left child, we pop from the stack. Each time we do so, we&#39;ll be getting the values in sorted order.<br>Once we pop the <code>k</code>th time, we&#39;ll return the value of the current node and be done with it. Otherwise, we&#39;ll go to the right subtree.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ because in the worst case where <code>k</code> is $n$, we&#39;ll end up visiting each node. The space complexity will be $O(h)$—where $h$ is the height of the tree—because in the worst case, we&#39;ll store all the nodes from the root to the deepest leaf node.</p>
<hr>
<p>The next problem is called <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener noreferrer">Construct Binary Tree from Preorder and Inorder Traversal</a>. Yet another mouthful title, but we&#39;ll survive. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-kth-smallest-element-in-a-bst</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-kth-smallest-element-in-a-bst</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 28 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Validate Binary Search Tree]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-26/38-lm.png" alt="Cover image"></p>
<p>The description for Validate Binary Search Tree is:</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
</blockquote>
<p>For example: </p>
<img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="Example image 1" />

<pre><code>Input: root = [2, 1, 3]
Output: true
</code></pre>
<p>Or:</p>
<img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="Example image 1" />

<pre><code>Input: root = [5, 1, 4, null, null, 3, 6]
Output: false
Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.
</code></pre>
<hr>
<p>Even though this one looks easy to solve recursively, there is a catch. </p>
<p>Let&#39;s say we naively wrote something like this:</p>
<pre><code class="language-ts">function isValidBST(root: TreeNode | null): boolean {
  if (root === null) {
    return true;
  }
    
  if (
    (root.left !== null &amp;&amp; root.left.val &gt;= root.val) ||
    (root.right !== null &amp;&amp; root.right.val &lt;= root.val)
  ) {
    return false;
  }
    
  return isValidBST(root.left) &amp;&amp; isValidBST(root.right);
}
</code></pre>
<p>This would return <code>true</code> for the second example above, which is <strong>wrong</strong>. In that example, although the right subtree is valid in its own right, the whole tree itself is not a valid binary search tree because 3 should be in the left subtree of the root.</p>
<p>So, let&#39;s look at a proper solution in TypeScript, adapted from <a href="https://www.youtube.com/watch?v=s6ATEkipzow" target="_blank" rel="noopener noreferrer">NeetCode&#39;s explanation</a>:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function isValidBST(root: TreeNode | null): boolean {
  function valid(node: TreeNode | null, left: number, right: number) {
    if (node === null) {
      return true;
    }

    if (node.val &gt;= right || node.val &lt;= left) {
      return false;
    }

    return valid(node.left, left, node.val) &amp;&amp; valid(node.right, node.val, right);
  }

  return valid(root, -Infinity, Infinity);
}
</code></pre>
<p>Here, we give boundaries for the left and right values that we&#39;re going to check a node&#39;s value against. Here, the value should be greater than <code>left</code>, and less than <code>right</code>. We start with negative and positive infinity because the root can be any value. </p>
<p>Inside <code>valid</code>, we only update the right boundary for the left child, and we only update the left boundary for the right child. </p>
<Note>
Remember that a left child can be as small as it wants to be, as long as it's smaller than the root, so only the right boundary should be updated for it:

<pre><code class="language-ts">valid(node.left, left, node.val)
</code></pre>
<p>Likewise, a right child can be as large as it can be, as long as it&#39;s larger than the root. Therefore, we only update the left boundary for it:</p>
<pre><code class="language-ts">valid(node.right, node.val, right)
</code></pre>
</Note>

<p>Of course, we return <code>false</code> when BST rules are broken: if the given node&#39;s value is greater than or equal to the right boundary, or less than or equal to the left boundary.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is going to be $O(n)$ as we do the comparisons for each node in the tree once. The space complexity will be $O(h)$ where $h$ is the height of the tree because of the recursive function we use, as it&#39;ll create a new stack frame with each call.</p>
<hr>
<p>The next problem is called <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener noreferrer">Kth Smallest Element in a BST</a>, which sounds exciting enough. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-validate-binary-search-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-validate-binary-search-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 26 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Binary Tree Level Order Traversal]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-24/37-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener noreferrer">Binary Tree Level Order Traversal</a>:</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>
</blockquote>
<p>For example:</p>
<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="Example image" />

<pre><code>Input: root = [3, 9, 20, null, null, 15, 7]
Output: [[3], [9, 20], [15, 7]]
</code></pre>
<hr>
<p>Level-order traversal is another name for <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#bfs" target="_blank" rel="noopener noreferrer">breadth-first search</a>. In this problem, we only need to get the values of the nodes in each level.</p>
<p>My initial solution in TypeScript looked like this:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function levelOrder(root: TreeNode | null): number[][] {
  if (root === null) {
    return [];
  }

  let result = [];
  let currentLevel = [root];

  while (currentLevel.length &gt; 0) {
    let nextLevel = [];
    for (let node of currentLevel) {
      if (node !== null &amp;&amp; node.left !== null) {
        nextLevel.push(node.left);
      }
      if (node !== null &amp;&amp; node.right !== null) {
        nextLevel.push(node.right);
      }
    }

    result.push(currentLevel.map(node =&gt; node.val));
    currentLevel = nextLevel;
  }

  return result;
}
</code></pre>
<p>What we do is, first, check if <code>root</code> is null — in that case, we immediately return an empty array.</p>
<p>Then, we initialize a <code>result</code> array and another array to hold the nodes in the current level (which initially only has <code>root</code>).</p>
<p>As we traverse the tree, we add the nodes in the next level — that is, the left and right children of the nodes in the current level we&#39;re looking at. Once we&#39;re done with the current level, we add the values in it to <code>result</code>, and go to the next level in the tree, doing the same thing until there are no nodes left to look at.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ as we visit each node once in the tree. Since <a href="https://en.wikipedia.org/wiki/Binary_tree#Properties_of_binary_trees" target="_blank" rel="noopener noreferrer">the largest level in a binary tree can be of length $\frac{n + 1}{2}$</a> where $n$ is the total number of nodes in the tree, the space complexity also ends up being $O(n)$ as we store each level.</p>
<hr>
<p>Similar to the version above, another solution might look like this (as in <a href="https://www.youtube.com/watch?v=6ZnyEApgFYg" target="_blank" rel="noopener noreferrer">this example by NeetCode</a>) — let&#39;s see it in Python this time:</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:
    result = []
    queue = collections.deque()
    queue.append(root)

    while queue:
        current_level = []
        current_queue_length = len(queue)
        for i in range(current_queue_length):
            node = queue.popleft()
            if node:
                current_level.append(node.val)
                queue.append(node.left)
                queue.append(node.right)
        if current_level:
            result.append(current_level)
    
    return result
</code></pre>
<p>In this version, we use a <a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank" rel="noopener noreferrer"><code>deque</code></a> for our queue. We initially append <code>root</code> to it, and as we traverse the tree, we append the values to <code>current_level</code>. Once we&#39;re done with a level, we append the values to <code>result</code>.</p>
<p>We can try a similar logic in TypeScript as well:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function levelOrder(root: TreeNode | null): number[][] {
  let result = [];
  let queue = [root];

  while (queue.length &gt; 0) {
    let currentLevel = [];
    let currentQueueLength = queue.length;
    for (let i = 0; i &lt; currentQueueLength; i++) {
      let node = queue.shift();
      if (node !== null) {
        currentLevel.push(node.val);
        queue.push(node.left);
        queue.push(node.right);
      }
    }
    if (currentLevel.length &gt; 0) {
      result.push(currentLevel);
    }
  }
   
  return result;
}
</code></pre>
<Note>
We're keeping the length of `queue` in a separate variable called `currentQueueLength` — it's essentially needed to keep the levels separate. 

<p>(Note that we&#39;re mutating <code>queue</code>&#39;s length inside the <code>for</code> loop with <code>queue.push</code> when we add the left and right children.)<br></Note></p>
<p>The time and space complexity are the same for this solution as well, that is, both are $O(n)$.</p>
<hr>
<p>Next up, we&#39;ll validate a binary search tree in the problem with the appropriate title, <a href="https://leetcode.com/problems/validate-binary-search-tree" target="_blank" rel="noopener noreferrer">Validate Binary Search Tree</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-binary-tree-level-order-traversal</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-binary-tree-level-order-traversal</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 24 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Lowest Common Ancestor of a Binary Search Tree]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-23/36-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener noreferrer">this one</a> states:</p>
<blockquote>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener noreferrer">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
</blockquote>
<p>For example:</p>
<img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Example 1 image" />

<pre><code>Input: root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
</code></pre>
<p>Or:</p>
<img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Example 2 image" />

<pre><code>Input: root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</code></pre>
<hr>
<p>If this is the first time you&#39;re hearing the term <em>lowest common ancestor</em> in the context of trees, it might sound a bit intimidating. But, it&#39;s indeed easy to see how it works.</p>
<p>Like many other problems, the solution awaits that we find which cases to look out for. </p>
<p>One of those cases is when <code>p</code> and <code>q</code> are in the different subtrees: that is, either <code>p</code> is greater than <code>root</code> and <code>q</code> is less than <code>root</code>, or <code>p</code> is less than <code>root</code> and <code>q</code> is greater than <code>root</code>. In that case, we know that the <code>root</code> will be their lowest common ancestor. </p>
<p>Since a node can be a descendant of itself, we can also return it when it&#39;s the lowest common ancestor to both nodes, as in the second example above.</p>
<p>My initial solution in TypeScript was this:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
  if (
    root.val === p.val ||
    root.val === q.val ||
    (p.val &lt; root.val &amp;&amp; q.val &gt; root.val) ||
    (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)
  ) {
    return root;
  }

  if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) {
    return lowestCommonAncestor(root.right, p, q);
  }
    
  if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) {
    return lowestCommonAncestor(root.left, p, q);
  }
}
</code></pre>
<p>We&#39;re using (yet again) recursion. If the values of <code>p</code> and <code>q</code> are greater than <code>root</code>, we pass <code>root.right</code> as <code>root</code> to our function, otherwise, we pass <code>root.left</code>.</p>
<p>The base cases are the ones mentioned above. It looks a bit confusing, so let&#39;s look at it closely.</p>
<p>This one:</p>
<pre><code class="language-ts">(p.val &lt; root.val &amp;&amp; q.val &gt; root.val)
</code></pre>
<p>And this one:</p>
<pre><code class="language-ts">(p.val &gt; root.val &amp;&amp; q.val &lt; root.val)
</code></pre>
<p>check whether <code>p</code> and <code>q</code> are in different subtrees — that is, when a split happens. In that case, <code>root</code> is their lowest common ancestor. If one of them is true, we need to return <code>root</code>.</p>
<p>Other conditions are when <code>root.val === p.val</code> or <code>root.val === q.val</code>. In these cases, either <code>p</code> or <code>q</code> is the same as the <code>root</code>, which means that it is the lowest common ancestor, so we can return <code>root</code> as well.</p>
<h4>Time and space complexity</h4>
<p>Both the time and space complexity will be $O(h)$—where $h$ is the height of the tree. We touch one node at each level as we go (hence the time complexity). And, because of the recursion, we create a new stack frame for each function call, so the additional space is proportionate to the height of the tree.</p>
<Note>
Since this is a [BST](https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#bst), and we're halving the search space as we go, the time complexity can also be said to be $O(log \ n)$. 
</Note>

<hr>
<h3>Non-recursive approach</h3>
<p>We can do better for the space complexity, and not use recursion at all — like this:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {
  let currentNode = root;

  while (currentNode !== null) {
    if (p.val &gt; currentNode.val &amp;&amp; q.val &gt; currentNode.val) {
      currentNode = currentNode.right;
    } else if (p.val &lt; currentNode.val &amp;&amp; q.val &lt; currentNode.val) {
      currentNode = currentNode.left;
    // One of them is larger and one of them is smaller than 
    // the currentNode (i.e., a split happened)
    } else { 
      return currentNode;
    }
  }
}
</code></pre>
<p>This version is perhaps more readable and cleaner than the first one. When both <code>p</code> and <code>q</code> have greater values than <code>currentNode</code> (which is initially <code>root</code>), we go to the right subtree, otherwise if their values are less, we go to the left subtree. In all the other cases (the ones we&#39;ve looked at in the recursive version), we just return <code>currentNode</code>.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is again $O(h)$ where $h$ is the height, for the same reason that we touch each node at every level. However, the space complexity is $O(1)$ as we don&#39;t need additional space.</p>
<hr>
<p>The next problem is a fun and essential one, <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">Binary Tree Level Order Traversal</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-lowest-common-ancestor-of-a-binary-search-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-lowest-common-ancestor-of-a-binary-search-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 23 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Subtree of Another Tree]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-22/35-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/subtree-of-another-tree" target="_blank" rel="noopener noreferrer">this one</a>:</p>
<blockquote>
<p>Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of <code>subRoot</code> and <code>false</code> otherwise.</p>
<p>A subtree of a binary tree <code>tree</code> is a tree that consists of a node in <code>tree</code> and all of this node&#39;s descendants. The tree <code>tree</code> could also be considered as a subtree of itself.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" alt="Example image 1"></p>
<pre><code>Input: root = [3, 4, 5, 1, 2], subRoot = [4, 1, 2]
Output: true
</code></pre>
<p>Or:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg" alt="Example image 2"></p>
<pre><code>Input: root = [3, 4, 5, 1, 2, null, null, null, null, 0], subRoot = [4, 1, 2]
Output: false
</code></pre>
<hr>
<p>When it comes to tree problems (at least the ones we&#39;ve looked at so far), recursion seems to be a natural choice, as <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees" target="_blank" rel="noopener noreferrer">trees themselves are recursive structures</a>. And this problem is no different.</p>
<p>What we need to do is check whether a subtree of the first tree we&#39;re given <em>is the same as</em> another tree.<br>In the previous problem, we did just that: we&#39;ve checked <a href="https://rivea0.github.io/blog/leetcode-meditations-same-tree" target="_blank" rel="noopener noreferrer">if two trees are the same</a>.</p>
<p>So, we can use the same function here as well. Here&#39;s a concise <code>isSameTree</code> function:</p>
<pre><code class="language-ts">function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {
  if (p === null &amp;&amp; q === null) {
    return true;
  } 

  if (p !== null &amp;&amp; q !== null &amp;&amp; p.val === q.val) {
    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
  } else {
    return false;
  }
}
</code></pre>
<p>Now for this problem, we need to check if, with the given <code>root</code> and <code>subRoot</code>, the trees are the same. If not, we need to recursively search left and right subtrees for <em>sameness</em>.</p>
<p>However, coming up with edge cases was harder than I thought. For one thing, we <strong>don&#39;t want to</strong> check the case when both <code>root</code> and <code>subRoot</code> are <code>null</code> — they need to be handled separately. <a href="https://www.youtube.com/watch?v=E36O5SWp-LE" target="_blank" rel="noopener noreferrer">NeetCode&#39;s explanation</a> was very helpful to sort this out in my mind.</p>
<p>So, we can check the case when the <code>subRoot</code> is <code>null</code>, in that case we can return <code>true</code> because <mark><em>an empty tree is a subtree of every tree</em></mark>.<br>However, when the <code>root</code> is <code>null</code> and the <code>subRoot</code> is not <code>null</code>, we need to return <code>false</code>, because that means the given subtree is not in the tree. </p>
<p>When the current <code>root</code> and <code>subRoot</code> are holding the same tree, we can return <code>true</code>, but in other cases, we recursively search the left and right subtrees until they result in the same tree or the root ends up being <code>null</code>: </p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function isSubtree(root: TreeNode | null, subRoot: TreeNode | null): boolean {
  // The order of these two base cases is important!
  if (subRoot === null) {
    return true;
  }

  if (root === null) { // (root === null &amp;&amp; subRoot !== null)
    return false;
  }
    
  if (isSameTree(root, subRoot)) {
    return true;
  } else {
    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
  }
}
</code></pre>
<Note>
The order of the first two base cases is important. The second one where we check if `root` is `null` implicitly **assumes that `subRoot` is not `null`** as we have checked that condition in the first `if` statement.
</Note>

<h4>Time and space complexity</h4>
<p>For each node in the first tree, we use the <code>isSameTree</code> function to check if the tree is the same as the given subtree. Therefore the time complexity is in the worst case $O(n^2)$.<br>Because of the recursive calls, the space complexity is—<em>I think</em>—in the worst case $O(n)$.</p>
<hr>
<p>Next up is <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener noreferrer">Lowest Common Ancestor of a Binary Search Tree</a>. That&#39;s a mouthful, but we&#39;ll manage.<br>Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-subtree-of-another-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-subtree-of-another-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 22 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Same Tree]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-20/34-lm.png" alt="Cover image"></p>
<p>Let&#39;s see the description for <a href="https://leetcode.com/problems/same-tree" target="_blank" rel="noopener noreferrer">this problem</a>:</p>
<blockquote>
<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="Example 1"></p>
<pre><code>Input: p = [1, 2, 3], q = [1, 2, 3]
Output: true
</code></pre>
<p>Or:</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="Example 2"></p>
<pre><code>Input: p = [1, 2], q = [1, null, 2]
Output: false
</code></pre>
<hr>
<p>This problem lends itself easily to recursion. After all, two trees are the same if their subtrees are the same.</p>
<p>My initial solution in TypeScript looked like this:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {
  if (p !== null &amp;&amp; q !== null &amp;&amp; p.val !== q.val) {
    return false;
  } 

  if (p === null) {
    return q === null;
  }

  if (q === null) {
    return p === null;
  }

  return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
}
</code></pre>
<p>First, we check if both nodes are not <code>null</code> and their values are not the same; in that case, we can return <code>false</code>.<br>Then, if one of them is <code>null</code>, we can return if the other one is <code>null</code> as well — if it is, the return value will be <code>true</code>, otherwise <code>false</code>. Of course, we apply <code>isSameTree</code> to the left and right children of the node recursively.</p>
<h4>Time and space complexity</h4>
<p>The time complexity will be proportionate to the total number of nodes in both trees, that is, $O(n)$ where $n$ is the total number of nodes. Because of the recursive calls, the space complexity, in the worst case—<em>I think</em>—can be said to be $O(n)$ where $n$ is the overall total number of nodes.</p>
<hr>
<p>Note that we can also write another concise (and <em>better</em>?) solution like this:</p>
<pre><code class="language-ts">function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {
  if (p === null &amp;&amp; q === null) {
    return true;
  } 

  if (p !== null &amp;&amp; q !== null &amp;&amp; p.val === q.val) {
    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
  } else {
    return false;
  }
}
</code></pre>
<p>Since the only way both trees are the same is either when they both are empty or all their nodes are the same. We first check whether both nodes are <code>null</code>, if so, we return <code>true</code>. We continue checking the left and right subtrees recursively only if both nodes are not <code>null</code> and their values are the same. In other cases, the trees can&#39;t be the same, so we return <code>false</code>.</p>
<hr>
<p>The next problem is called <a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener noreferrer">Subtree of Another Tree</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-same-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-same-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 20 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Maximum Depth of Binary Tree]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-18/33-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener noreferrer">Maximum Depth of Binary Tree</a> says that:</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>
<p>A binary tree&#39;s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="Example image"></p>
<pre><code>Input: root = [3, 9, 20, null, null, 15, 7]
Output: 3
</code></pre>
<hr>
<p>The word <em>depth</em> in the title (kind of) hints at a <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#dfs" target="_blank" rel="noopener noreferrer">depth-first search</a> approach. One way to do it is with recursion:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function maxDepth(root: TreeNode | null): number {
  if (root === null) {
    return 0;
  }

  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
</code></pre>
<p>It looks elegant and simple: what we&#39;re doing is calculating the depth of left and right subtrees from the root node&#39;s perspective, and returning the larger one of them plus 1 (for the root node).</p>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ as we visit each node in the tree. The space complexity can be said to be $O(h)$ where $h$ is the height of the tree (because each recursive call creates a new stack frame). However, in the case of an unbalanced tree, it is going to be $O(n)$.</p>
<hr>
<p>Depth-first search doesn&#39;t always have to be recursive, so let&#39;s look at an iterative version, as shown by <a href="https://youtu.be/hTM3phVI6YQ?si=_Mzn37CRjHFzpO4G&t=643" target="_blank" rel="noopener noreferrer">NeetCode</a> (but let&#39;s write it in TypeScript):</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function maxDepth(root: TreeNode | null): number {
  // Keep the current node and current depth in stack
  let stack: [TreeNode | null, number][] = [[root, 1]];
  let result = 0;

  while (stack.length &gt; 0) {
    let [currentNode, depth] = stack.pop();
    if (currentNode !== null) {
      result = Math.max(result, depth);
      stack.push([currentNode.left, depth + 1]);
      stack.push([currentNode.right, depth + 1]);
    }
  }

  return result;
}
</code></pre>
<p>Here, we use a <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-4-stack" target="_blank" rel="noopener noreferrer">stack</a> where we keep the current node and current depth — starting with the root node, and depth of 1.<br>We pop the last item and continue pushing its left and right children, also incrementing <code>depth</code> as we do so. <code>result</code> is keeping track of the maximum depth, so at the end when our stack is empty, we just return it. </p>
<h4>Time and space complexity</h4>
<p>The time and space complexity are both $O(n)$ — we go through each node; and keep a stack whose size will grow as the number of nodes in the tree grows.</p>
<hr>
<p>The next problem is what seems to be an easy one, called <a href="https://leetcode.com/problems/same-tree" target="_blank" rel="noopener noreferrer">Same Tree</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-maximum-depth-of-binary-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-maximum-depth-of-binary-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 18 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Invert Binary Tree]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-16/32-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/invert-binary-tree" target="_blank" rel="noopener noreferrer">Invert Binary Tree</a>:</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="Example image"></p>
<hr>
<p>Although this one has a very simple recursive solution, let&#39;s see one approach that I come up with initially:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function invertTree(root: TreeNode | null): TreeNode | null {
  let queue = [];
  queue.push(root);

  while (queue.length &gt; 0) {
    let currentNode = queue[0];
    if (currentNode !== null) {
      queue.push(currentNode.left);
      queue.push(currentNode.right);
      [currentNode.left, currentNode.right] = [currentNode.right, currentNode.left];
    }

    queue.shift();
  }

  return root;
}
</code></pre>
<p>This version uses <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees#bfs" target="_blank" rel="noopener noreferrer">level-order traversal</a>; we store the children of each node in a queue as we go through each level in the tree, and swap the node&#39;s left and right children.</p>
<h4>Time and space complexity</h4>
<p>Since we visit each node once, the time complexity is $O(n)$.<br>The space complexity will be proportionate to the size of the queue we keep, which holds a whole level at a time, which amounts to $O(n)$ overall.</p>
<hr>
<p>Now, let&#39;s look at the recursive solution, which is much simpler:</p>
<pre><code class="language-ts">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */

function invertTree(root: TreeNode | null): TreeNode | null {
  if (root === null) {
    return null;
  }

  [root.left, root.right] = [root.right, root.left];

  invertTree(root.left);
  invertTree(root.right);

  return root;
}
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ as we visit each node to swap its left and right children. The space complexity is also $O(h)$—where $h$ is the height of the tree—because of the recursive calls to the function on each level.</p>
<hr>
<p>Next up is <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">Maximum Depth of Binary Tree</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-invert-binary-tree</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-invert-binary-tree</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 16 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 7: Trees]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-15/31-lm-ch7.png" alt="Cover image"></p>
<h2>Table of contents</h2>
<ul>
<li><a href="#intro" target="_blank" rel="noopener noreferrer">Introduction</a></li>
<li><a href="#bst" target="_blank" rel="noopener noreferrer">Binary trees, binary search trees (BSTs)</a><ul>
<li><a href="#bst-insert" target="_blank" rel="noopener noreferrer">Inserting into a binary search tree</a><ul>
<li><a href="#bst-insert-recursive" target="_blank" rel="noopener noreferrer">Recursive solution</a><ul>
<li><a href="#bst-insert-recursive-complexity" target="_blank" rel="noopener noreferrer">Time and space complexity</a></li>
</ul>
</li>
<li><a href="#bst-insert-iterative" target="_blank" rel="noopener noreferrer">Iterative solution</a><ul>
<li><a href="#bst-insert-iterative-complexity" target="_blank" rel="noopener noreferrer">Time and space complexity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#bst-delete" target="_blank" rel="noopener noreferrer">Deleting from a binary search tree</a><ul>
<li><a href="#bst-delete-complexity" target="_blank" rel="noopener noreferrer">Time and space complexity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#traversals" target="_blank" rel="noopener noreferrer">Traversals</a><ul>
<li><a href="#dfs" target="_blank" rel="noopener noreferrer">Depth-First Search (DFS)</a><ul>
<li><a href="#preorder" target="_blank" rel="noopener noreferrer">Preorder traversal</a></li>
<li><a href="#inorder" target="_blank" rel="noopener noreferrer">Inorder traversal</a></li>
<li><a href="#postorder" target="_blank" rel="noopener noreferrer">Postorder traversal</a></li>
</ul>
</li>
<li><a href="#bfs" target="_blank" rel="noopener noreferrer">Breadth-First Search (BFS)</a></li>
</ul>
</li>
<li><a href="#resources" target="_blank" rel="noopener noreferrer">Resources</a></li>
</ul>
<hr>
<p><a name="intro"></a><br>In this new chapter of the series, we&#39;ll take a look at a <strong>non-linear</strong> data structure that is pretty familiar to many developers: trees.</p>
<p>Whether familiarity breeds contempt or not is arguable, so let&#39;s start with the simplest component of a tree: a node.</p>
<p>Trees (like <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-6-linked-lists" target="_blank" rel="noopener noreferrer">linked lists</a>) are made up of nodes. The simplest version of a tree is just the <strong>root node</strong> which doesn&#39;t have any edges (links) pointing to it; that is, it has no <strong>parent nodes</strong>. It is the starting point, in a way.</p>
<p>A tree can only have one root node, and when you think about it, <em>if there are $n$ nodes in a tree, that means there are $n - 1$ edges (links)</em> because there is no edge (link) pointing to the root node.</p>
<hr>
<br />

<p>If you&#39;ve looked at a tree long enough, you might&#39;ve had a moment of epiphany—a tree has smaller trees within itself. A branch may as well be a trunk, having other branches for the little tree it constitutes. </p>
<p>The tree data structure is like this, it is <strong>recursive</strong>: <em>a child node can be the root of a subtree</em>.</p>
<hr>
<p>Two terms that are important when it comes to a tree node are <em>depth</em> and <em>height</em>.</p>
<p>The <strong>depth</strong> of a node is how far away it is from the root node (how many edges (links) does it take to travel from the root node to it), and the <strong>height</strong> of a node is how far away it is from its furthest <strong>leaf node</strong> (which is the node that has no children).</p>
<Note>
The height of the root node is the same as the height of the whole tree.
</Note>

<p>A <strong>balanced tree</strong> is one where <em>the heights of the left and right subtrees of every node differ by at most 1</em>.</p>
<hr>
<p><a name="bst"></a></p>
<h3>Binary trees, binary search trees (BSTs)</h3>
<p>A <strong>binary tree</strong> is a tree where each node has at most two children. That is, a node can have a left child node and a right child node, and no more.</p>
<p>The maximum number of nodes in a binary tree is $2^h - 1$ where $h$ is the height of the tree.<br>This is where the <em>binary</em> of the binary tree makes sense: on each level, the number of nodes grows proportionately to the exponents of $2$. For example, the number of nodes on the first level (the 0th level) is $2^0 = 1$, which is just the root node. The second level has at most 2 nodes: $2^1 = 2$ (remember that we&#39;re counting from $0$, so the second level is $1$).</p>
<p>A <strong>binary search tree</strong> is a binary tree where the values smaller than the node go to its left and those greater than it go to its right:</p>
<p>$\text{left children } \lt \text{ node } \lt \text{ right children}$</p>
<p>Here is an example:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-15/bst.gif" alt="Binary search tree example"></p>
<p><a name="bst-insert"></a></p>
<h4>Inserting into a binary search tree</h4>
<p>If we want to insert a new node into a binary search tree, we need to insert it into its proper place to keep the properties of a BST intact.</p>
<p>Let&#39;s see it in JavaScript.</p>
<p><a name="bst-insert-recursive"></a></p>
<h5>Recursive solution</h5>
<pre><code class="language-js">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
function insertIntoBST(root, val) {
  if (root === null) {
    return new TreeNode(val);
  }

  if (val &lt; root.val) {
    root.left = insertIntoBST(root.left, val);
  } else {
    root.right = insertIntoBST(root.right, val);
  }

  return root;
}
</code></pre>
<p>Here, we traverse the tree until we find a space (a <code>null</code> position) for our value that is waiting to be a <code>TreeNode</code>. We start with the root node; if the value of the node-to-be-inserted is less than the value of the root node, we go left (passing <code>root.left</code> as the <code>root</code> argument to the function). Otherwise, we go right (passing <code>root.right</code> as the <code>root</code> argument).</p>
<p><a name="bst-insert-recursive-complexity"></a></p>
<h6>Time and space complexity</h6>
<p>The time complexity is $O(h)$ where $h$ is the height of the tree. On each level in the tree, we either go left or right, so we don&#39;t necessarily visit every single node. The space complexity is also $O(h)$ because we use recursion, creating a new stack frame for each function call.</p>
<p><em>Note that if the tree is unbalanced, the time and space complexity can be said to be $O(n)$.</em></p>
<p><a name="bst-insert-iterative"></a></p>
<h5>Iterative solution</h5>
<p>We can also do it iteratively, using pointers only:</p>
<pre><code class="language-js">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
function insertIntoBST(root, val) {
  if (root === null) {
    return new TreeNode(val);
  }

  let prevNode = null;
  let currentNode = root;

  while (currentNode !== null) {
    prevNode = currentNode;
    if (val &lt; currentNode.val) {
      currentNode = currentNode.left;
    } else {
      currentNode = currentNode.right;
    }
  }

  if (val &lt; prevNode.val) {
    prevNode.left = new TreeNode(val);
  } else {
    prevNode.right = new TreeNode(val);
  }

  return root;
}
</code></pre>
<p>Here, we do the same thing — iterating until we find the correct place, but also keeping track of the parent node. Then, we insert the node as either the left or the right child of the parent, depending on its value.</p>
<p><a name="bst-insert-iterative-complexity"></a></p>
<h6>Time and space complexity</h6>
<p>The time complexity is again $O(h)$ (<em>or if the tree is unbalanced, $O(n)$</em>) for the same reason as in the recursive solution. However, the space complexity is constant — $O(1)$ as we only use pointers.</p>
<p><a name="bst-delete"></a></p>
<h4>Deleting from a binary search tree</h4>
<p>The challenging thing when deleting a node from a BST is keeping the BST as a BST. All smaller values should still go to the root node&#39;s left subtree, and all those that are larger should go to the root node&#39;s right subtree.</p>
<p>Let&#39;s take a look at how we might do it in JavaScript:</p>
<pre><code class="language-js">/**
 * Definition for a binary tree node.
 * class TreeNode {
 *   val: number
 *   left: TreeNode | null
 *   right: TreeNode | null
 *   constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.left = (left === undefined ? null : left)
 *     this.right = (right === undefined ? null : right)
 *   }
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
function deleteNode(root, key) {
  if (root === null) {
    return root;
  }

  if (key &lt; root.val) {
    root.left = deleteNode(root.left, key);
  } else if (key &gt; root.val) {
    root.right = deleteNode(root.right, key);
  } else {
    // Node-to-be-deleted has no children
    if (root.left === null &amp;&amp; root.right === null) {
      return null;
    } 

    // If either the left or the right child exists,
    // return the one that exists as the new child 
    // of the parent node (of the node-to-be-deleted)
    if (root.left === null || root.right === null) {
      return root.left ? root.left : root.right;
    }

    // If both children exist, traverse the left subtree, get its maximum value...
    let currentNode = root.left;

    while (currentNode.right !== null) {
      currentNode = currentNode.right;
    }

    // ...replace it with the node-to-be-deleted
    root.val = currentNode.val;
    // ...then apply the recursion to the left subtree to get rid of the duplicate value
    root.left = deleteNode(root.left, root.val);
  }

  return root;
}
</code></pre>
<p>We traverse the tree until we find the node to be deleted. Once we find it, there are several things to do.</p>
<p>In the case where it doesn&#39;t have any child nodes, we can return <code>null</code> and be done with it.</p>
<p>If it has one child node, we can return the one that exists using the ternary operation (<code>return root.left ? root.left : root.right</code>). </p>
<Note>
In this case, we're essentially making the root of the subtree the child of the parent node.

<p>For example, in the image, if the node-to-be-deleted is 10 (it has only right child node with the value 14), we make 14 the right child of 8. It doesn&#39;t break our BST, because those that are larger than 8 continue to be in the right subtree of 8.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-15/bst-example1.png" alt="Example BST"><br></Note></p>
<p>Otherwise, if both the left and right children of the node-to-be-deleted exist, we need to do something different. </p>
<p>In this case, we&#39;ll replace the node-to-be-deleted with the largest value in the left subtree. </p>
<p>However, after replacing, we&#39;ll have two nodes of the same value in both places, so we need to apply <code>deleteNode</code> itself to the subtree that we&#39;ve taken our replacement node from. </p>
<p>This is all done to keep the BST as BST. It might be a bit difficult to wrap one&#39;s head around at first, but <a href="https://www.youtube.com/watch?v=LFzAoJJt92M" target="_blank" rel="noopener noreferrer">NeetCode has a detailed explanation of this problem</a>.</p>
<Note>
Note that we can also use the smallest value in the right subtree as well. In that case, our code would look like this:

<pre><code class="language-js">let currentNode = root.right;

while (currentNode.left !== null) {
  currentNode = currentNode.left;
}

root.val = currentNode.val;
root.right = deleteNode(root.right, root.val);
</code></pre>
</Note>

<p><a name="bst-delete-complexity"></a></p>
<h6>Time and space complexity</h6>
<p>Similar to inserting into a BST, both the time and space complexity of deleting from a BST will be $O(h)$ where $h$ is the height of the tree.</p>
<hr>
<p><a name="traversals"></a></p>
<h4>Traversals</h4>
<p>We&#39;ll take a brief look at two of the most famous ways to traverse a tree where the order in which we visit the nodes matters: depth-first search and breadth-first search.</p>
<p><a name="dfs"></a></p>
<h5>Depth-First Search (DFS)</h5>
<p>In a depth-first search, we traverse through a branch until we get to a leaf node. Then, we backtrack and do the same thing with another branch.</p>
<p>There are three common ways to do a depth-first search:</p>
<ul>
<li>preorder traversal</li>
<li>inorder traversal</li>
<li>postorder traversal</li>
</ul>
<p><a name="preorder"></a></p>
<h6>Preorder traversal</h6>
<p>It goes like this: We first visit the node, then go on to its left subtree, then the right subtree.</p>
<p>$$\text{node \ -&gt; \ left subtree \ -&gt; \ right subtree}$$</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-15/preorder.gif" alt="Preorder walk example"></p>
<p>We can do a preorder walk recursively:</p>
<pre><code class="language-js">function preorderWalk(node) {
  if (node === null) {
    return;
  }

  console.log(node.val);
  preorderWalk(node.left);
  preorderWalk(node.right);
}
</code></pre>
<p><a name="inorder"></a></p>
<h6>Inorder traversal</h6>
<p>It goes like this: we first visit the left subtree, then the node, then the right subtree.</p>
<p>$$\text{left subtree \ -&gt; \ node \ -&gt; \ right subtree}$$</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-15/inorder.gif" alt="Inorder walk example"></p>
<Note>
The inorder traversal gives us the sorted values.
</Note>

<p>We can do an inorder walk recursively as well:</p>
<pre><code class="language-js">function inorderWalk(node) {
  if (node === null) {
    return;
  }

  inorderWalk(node.left);
  console.log(node.val);
  inorderWalk(node.right);
}
</code></pre>
<p><a name="postorder"></a></p>
<h6>Postorder traversal</h6>
<p>It goes like this: we first visit the left subtree, then the right subtree, and finally the node.</p>
<p>$$\text{left subtree \ -&gt; \ right subtree \ -&gt; \ node}$$</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-15/postorder.gif" alt="Postorder walk example"></p>
<p>We can do a postorder walk recursively:</p>
<pre><code class="language-js">function postorderWalk(node) {
  if (node === null) {
    return;
  }

  postorderWalk(node.left);
  postorderWalk(node.right);
  console.log(node.val);
}
</code></pre>
<p><a name="bfs"></a></p>
<h5>Breadth-First Search (BFS)</h5>
<p>In breadth-first search, we visit the nodes level by level, that is, visiting every child of a node first before moving on.</p>
<p>A queue is used when implementing a BFS. Since we don&#39;t have edges connecting all the children on one level together, it makes sense to keep them in a queue and visit each one when their time comes.<br>When a node is added to the queue and not have been visited yet, it&#39;s called a <strong>discovered node</strong>.</p>
<p>A simple BFS operation looks like this (which is repeated until the queue is empty):</p>
<ul>
<li>visit node</li>
<li>enqueue left child</li>
<li>enqueue right child</li>
</ul>
<p>Note that the breadth-first search is also known as <em>level-order traversal</em>.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-15/bfs-walk.gif" alt="Level order walk example"></p>
<p>Let&#39;s see a simple example of a level-order traversal in JavaScript:</p>
<pre><code class="language-js">function levelOrderWalk(root) {
  if (root === null) {
    return;
  }

  let queue = [];
  queue.push(root);

  while (queue.length &gt; 0) {
    let currentNode = queue[0];

    console.log(currentNode.val);

    if (currentNode.left !== null) {
      queue.push(currentNode.left);
    }

    if (currentNode.right !== null) {
      queue.push(currentNode.right);
    }

    // Remove the current node
    queue.shift();
  }
}
</code></pre>
<p><em>This example is based on Vaidehi Joshi&#39;s <a href="https://gist.github.com/vaidehijoshi/27f9fa6b6b68f70360019805b5ca3692#file-level_order_search-js" target="_blank" rel="noopener noreferrer">GitHub Gist</a>.</em></p>
<hr>
<p>This was a fresh (and long) chapter, and the first problem will be the famous (or infamous) <a href="https://leetcode.com/problems/invert-binary-tree" target="_blank" rel="noopener noreferrer">Invert Binary Tree</a>. Until then, happy coding.</p>
<p><a name="resources"></a></p>
<h3>Resources</h3>
<ul>
<li><a href="https://medium.com/basecs/leaf-it-up-to-binary-trees-11001aaf746d" target="_blank" rel="noopener noreferrer">&quot;Leaf It Up To Binary Trees&quot; - Vaidehi Joshi</a></li>
<li><a href="https://medium.com/basecs/demystifying-depth-first-search-a7c14cccf056" target="_blank" rel="noopener noreferrer">&quot;Demystifying Depth-First Search&quot; - Vaidehi Joshi</a></li>
<li><a href="https://medium.com/basecs/breaking-down-breadth-first-search-cebe696709d9" target="_blank" rel="noopener noreferrer">&quot;Breaking Down Breadth-First Search&quot; - Vaidehi Joshi</a></li>
<li><a href="https://inst.eecs.berkeley.edu/~cs61b/fa21/materials/demos/tree-traversal-demo.html" target="_blank" rel="noopener noreferrer">Tree Traversals - Professor Paul N. Hilfinger</a></li>
<li><a href="https://brilliant.org/wiki/traversals" target="_blank" rel="noopener noreferrer">Tree Traversals - brilliant.org</a></li>
<li><a href="https://leetcodethehardway.com/tutorials/graph-theory/binary-search-tree" target="_blank" rel="noopener noreferrer">Binary Search Tree - LeetCode the Hard Way</a></li>
<li><a href="https://leetcodethehardway.com/tutorials/graph-theory/depth-first-search" target="_blank" rel="noopener noreferrer">Depth-First Search - LeetCode the Hard Way</a></li>
<li><a href="https://leetcodethehardway.com/tutorials/graph-theory/breadth-first-search" target="_blank" rel="noopener noreferrer">Breadth-First Search - LeetCode the Hard Way</a></li>
</ul>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-7-trees</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 15 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Merge K Sorted Lists]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-09/30-lm.png" alt="Cover image"></p>
<p>The description of <a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener noreferrer">Merge K Sorted Lists</a> states:</p>
<blockquote>
<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>
<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>
</blockquote>
<p>For example:</p>
<pre><code>Input: lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
Output: [1, 1, 2, 3, 4, 4, 5, 6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre>
<hr>
<p>This problem was a bit confusing to me at first, but the explanation by <a href="https://www.youtube.com/watch?v=q5a5OiGbT6Q" target="_blank" rel="noopener noreferrer">NeetCode</a> made a lot of sense. </p>
<p>The way to go for a solution is the <a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener noreferrer">Merge Sort algorithm</a>, which is one of the most familiar algorithms you might remember from any introductory computer science course.</p>
<p>Now, in a usual Merge Sort when we&#39;re given an array as the input, we recursively split the array into left and right halves, and keep merging them until the whole array is sorted. Here&#39;s how our familiar friend might look like in JavaScript:</p>
<pre><code class="language-ts">function mergeSort(arr) {
  if (arr.length &lt;= 1) {
    return arr;
  }

  let left = arr.slice(0, Math.floor(arr.length / 2));
  let right = arr.slice(Math.floor(arr.length / 2), arr.length);

  mergeSort(left);
  mergeSort(right);

  merge(left, right, arr);

  return arr;
}


function merge(left, right, arr) {
  let index = 0;

  while (left.length &amp;&amp; right.length) {
    if (left[0] &lt; right[0]) {
      arr[index++] = left.shift();
    } else {
      arr[index++] = right.shift();
    }
  }

  while (left.length) {
    arr[index++] = left.shift();
  }

  while (right.length) {
    arr[index++] = right.shift();
  }
}
</code></pre>
<p>However, what we&#39;re going to make use of is the <em>idea</em> of the <code>merge</code> function. </p>
<p>Since we&#39;re also using linked lists, it will look a bit different. Using TypeScript, it will look like this:</p>
<pre><code class="language-ts">function merge(list1: ListNode | null, list2: ListNode | null) {
  let result = new ListNode(0);
  let currentNode = result;
    
  while (list1 !== null &amp;&amp; list2 !== null) {
    if (list1.val &lt; list2.val) {
      currentNode.next = list1;
      list1 = list1.next;
    } else {
      currentNode.next = list2;
      list2 = list2.next;
    }

    currentNode = currentNode.next;
  }

  if (list1 !== null) {
    currentNode.next = list1;
  }

  if (list2 !== null) {
    currentNode.next = list2;
  }

  return result.next;
}
</code></pre>
<p>Since we&#39;re given <code>k</code> sorted lists, we&#39;ll merge pairs of lists, and keep merging while the length of <code>lists</code> is greater than 1:</p>
<pre><code class="language-ts">function mergeKLists(lists: Array&lt;ListNode | null&gt;): ListNode | null {
  if (lists === null || lists.length === 0) {
    return null;
  }

  while (lists.length &gt; 1) {
    let mergedLists = [];
    for (let i = 0; i &lt; lists.length; i += 2) {
      let list1 = lists[i];
      let list2 = i + 1 &lt; lists.length ? lists[i + 1] : null;
      mergedLists.push(merge(list1, list2));
    }

    lists = mergedLists;
  } 

  return lists[0];
};
</code></pre>
<Note>
If `list2` is `null` (in the case where the length of `lists` is not even), the merging of `list1` and `list2` will be just `list1`.
</Note>

<p>Overall, the solution looks like this:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function mergeKLists(lists: Array&lt;ListNode | null&gt;): ListNode | null {
  if (lists === null || lists.length === 0) {
    return null;
  }

  while (lists.length &gt; 1) {
    let mergedLists = [];
    for (let i = 0; i &lt; lists.length; i += 2) {
      let list1 = lists[i];
      let list2 = i + 1 &lt; lists.length ? lists[i + 1] : null;
      mergedLists.push(merge(list1, list2));
    }

    lists = mergedLists;
  } 

  return lists[0];
};

function merge(list1: ListNode | null, list2: ListNode | null) {
  let result = new ListNode(0);
  let currentNode = result;
    
  while (list1 !== null &amp;&amp; list2 !== null) {
    if (list1.val &lt; list2.val) {
      currentNode.next = list1;
      list1 = list1.next;
    } else {
      currentNode.next = list2;
      list2 = list2.next;
    }

    currentNode = currentNode.next;
  }

  if (list1 !== null) {
    currentNode.next = list1;
  }

  if (list2 !== null) {
    currentNode.next = list2;
  }

  return result.next;
}
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n \ log \ k)$ — also see <a href="https://youtu.be/q5a5OiGbT6Q?si=NlxKdlyZ5P2bsQUX&t=195" target="_blank" rel="noopener noreferrer">NeetCode&#39;s explanation</a> —, if you remember that the time complexity of the Merge Sort function is $O(n \ log \ n)$: We go through each item in the merging operation, but since the input is halved each time, we do it $log \ n$ times. It is similar here, where $n$ refers to the number of nodes, and $k$ is the number of lists.<br>The space complexity is $O(k)$ where $k$ is the number of lists as we keep a temporary <code>mergedLists</code> variable.</p>
<hr>
<p>And, this is the last problem of the Linked Lists chapter. Next up, we&#39;ll begin looking at some <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)" target="_blank" rel="noopener noreferrer">trees</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-merge-k-sorted-lists</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-merge-k-sorted-lists</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 09 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Linked List Cycle]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-08/29-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/linked-list-cycle" target="_blank" rel="noopener noreferrer">Linked List Cycle</a>:</p>
<blockquote>
<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example image"></p>
<pre><code>Input: head = [3, 2, 0, -4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
</code></pre>
<hr>
<p>One easy way to do it is using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener noreferrer">set</a>. As we traverse the list, we can look up each node in the set, and if it&#39;s there, we know that there has to be a cycle so we can just return <code>true</code>.</p>
<p>Here is how it looks like in TypeScript:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function hasCycle(head: ListNode | null): boolean {
  let nodes = new Set();
  let currentNode = head;

  while (currentNode !== null) {
    if (nodes.has(currentNode)) {
      return true;
    }
    nodes.add(currentNode);
    currentNode = currentNode.next;
  }

  return false;
};
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity of this solution is $O(n)$ as we go through every node in the list once. The space complexity is also $O(n)$ because we&#39;ll store each node in <code>nodes</code>, and its size will grow with the size of the linked list.</p>
<hr>
<p>There is another way to solve this problem that is more memory efficient using <a href="https://rivea0.github.io/blog/leetcode-meditations-interlude-fast-and-slow-pointers" target="_blank" rel="noopener noreferrer">fast and slow pointers</a>, where we don&#39;t need to store an additional data structure at all:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function hasCycle(head: ListNode | null): boolean {
  let slow = head;
  let fast = head;

  while (fast !== null &amp;&amp; fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) {
      return true;
    }
  }   

  return false;
};
</code></pre>
<p>We initialize both pointers at the head, and while <code>fast</code> (or its <code>next</code> pointer) is not <code>null</code>, we&#39;ll update them. Of course, while <code>slow</code> is moving one step at a time, <code>fast</code> is increasing by two steps. And, we return <code>true</code> if they both point to the same node, at which point we know there has to be a cycle. Otherwise, if <code>fast</code> ever points to <code>null</code>, we know that there is no cycle, so we can return <code>false</code>.</p>
<p>This technique of detecting a cycle is also called <a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare" target="_blank" rel="noopener noreferrer">Floyd&#39;s tortoise and hare algorithm</a>.</p>
<p>The important thing is that when <code>slow</code> and <code>fast</code> catch up, they are going to be pointing to the same node.<br>The reason that this works is that while <code>slow</code> increases the distance between it and <code>fast</code> by 1, <code>fast</code> decreases that distance by 2 — eventually making the overall distance between them 0.</p>
<p>It makes more sense with an example such as the one given in <a href="https://youtu.be/gBTe7lFR3vc?si=GfjvRmI9rEfYMDSe&t=339" target="_blank" rel="noopener noreferrer">NeetCode&#39;s explanation</a>.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ where $n$ is the length of the cycle (we can imagine a worst case scenario where the last node points to the head). The good thing is that the space complexity is $O(1)$ because we don&#39;t need an additional data structure that will grow with the size of the input.</p>
<hr>
<p>The last problem in this chapter will be <a href="https://leetcode.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener noreferrer">Merge K Sorted Lists</a>. Until then, happy coding. </p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-linked-list-cycle</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-linked-list-cycle</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 08 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Remove Nth Node From the End of List]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-07/28-lm.png" alt="Cover image"></p>
<p>The description for this problem says:</p>
<blockquote>
<p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="Example image"></p>
<pre><code>Input: head = [1, 2, 3, 4, 5], n = 2
Output: [1, 2, 3, 5]
</code></pre>
<hr>
<p>It seems like an easy question at first glance.<br>However, the tricky thing is that the nth node is counted from the back. </p>
<p>Now, if we were to do it normally <strong>from the start of the list</strong>, we could just keep a count, and when the count reached the <code>n</code>th index, we could just unlink that node. Here is a basic example in JavaScript:</p>
<pre><code class="language-js">function removeNode(head, n) {
  if (head === null) {
    return;
  }

  let currentNode = head;

  if (n === 0) {
    head = currentNode.next;
    return;
  }

  let count = 0;
  
  while (currentNode !== null &amp;&amp; count &lt; n - 1) {
    currentNode = currentNode.next;
    count++;
  }

  if (currentNode === null || currentNode.next === null) {
    return;  
  }

  let nextNode = currentNode.next.next;
  currentNode.next = nextNode;

  return head;
}
</code></pre>
<Note>
We're using `n` as a 0-based index in this example. If the index were to start from 1 as the actual problem demands, we'd have to modify our condition like this:

<pre><code class="language-js">if (n === 1) {
  head = currentNode.next;
  return;
}
</code></pre>
<p>and, use <code>count &lt; n - 2</code> instead of <code>count &lt; n - 1</code> in the <code>while</code> loop condition to point <code>currentNode</code> to the previous node.<br></Note></p>
<hr>
<p>However, we need to do it from the back of the list. We could try traversing in reverse, but there is a solution using the <a href="https://rivea0.github.io/blog/leetcode-meditations-interlude-fast-and-slow-pointers" target="_blank" rel="noopener noreferrer">fast and slow pointers technique</a> as shown by <a href="https://www.youtube.com/watch?v=XVuQxVej6y8" target="_blank" rel="noopener noreferrer">NeetCode</a>.</p>
<p>First, we&#39;ll create a dummy node with value <code>0</code>, that I&#39;m going to call <code>result</code>:</p>
<pre><code class="language-ts">let result = new ListNode(0);
</code></pre>
<p>Then, we&#39;ll point its <code>next</code> pointer to <code>head</code> to link the original list:</p>
<pre><code class="language-ts">result.next = head;
</code></pre>
<p>Then, we&#39;ll initialize our <code>fast</code> and <code>slow</code> pointers:</p>
<pre><code class="language-ts">let slow = result;
let fast = head;
</code></pre>
<Note>
While `fast` is pointing to the (actual) `head`, `slow` points to the dummy node `result`, appropriately as it needs to be behind `fast`. But, the reason is that it will be at the previous node of the node that we're going to remove.
</Note>

<p>Then, we&#39;ll bring our <code>fast</code> pointer to the <code>n</code>th node so that the number of nodes between it and the <code>slow</code> pointer is initially <code>n</code>:</p>
<pre><code class="language-ts">while (n &gt; 0 &amp;&amp; fast !== null) {
  fast = fast.next;
  n--;
}
</code></pre>
<p><em>For example, in the image given at the beginning, if <code>n</code> is <code>1</code>, <code>fast</code> will be at the node with the value <code>2</code>, while <code>slow</code> points to the dummy node with value <code>0</code>. The gap between them is exactly <code>n</code> — that is, 1.</em></p>
<p>After that, we&#39;ll make the <code>slow</code> pointer catch up slowly. We&#39;ll also update <code>fast</code>, but the gap between them will stay as <code>n</code>:</p>
<pre><code class="language-ts">while (fast !== null) {
  slow = slow.next;
  fast = fast.next;
}
</code></pre>
<p>At this point when <code>fast</code> points to <code>null</code>, <code>slow</code> will be at the previous node of the node we need to remove.<br>So, the only thing to do is to point its <code>next</code> pointer to the next of the node-to-be-removed, essentially unlinking it:</p>
<pre><code class="language-ts">slow.next = slow.next.next;
</code></pre>
<p>Eventually we can return the <code>head</code> which is pointed to by our dummy node&#39;s <code>next</code> pointer:</p>
<pre><code class="language-ts">return result.next;
</code></pre>
<p>All in all, this is our solution in TypeScript:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
  let result = new ListNode(0);
  result.next = head;
  let slow = result;
  let fast = head;

  while (n &gt; 0 &amp;&amp; fast !== null) {
    fast = fast.next;
    n--;
  }

  while (fast !== null) {
    slow = slow.next;
    fast = fast.next;
  }

  slow.next = slow.next.next;

  return result.next;
};
</code></pre>
<h4>Time and space complexity</h4>
<p>We need to &quot;touch&quot; each node, so the time complexity will be linear — $O(n)$.<br>The space complexity is $O(1)$ as we don&#39;t need extra space that grows with the input size. Note that <code>result</code> doesn&#39;t scale with the size of the input, it&#39;s just one node that has its <code>next</code> pointing to the head of the original list.</p>
<hr>
<p>The next problem is <a href="https://leetcode.com/problems/linked-list-cycle" target="_blank" rel="noopener noreferrer">Linked List Cycle</a> where the fast and slow pointers technique will be useful again. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-remove-nth-node-from-end-of-list</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-remove-nth-node-from-end-of-list</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 07 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Reorder List]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-07/27-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/reorder-list" target="_blank" rel="noopener noreferrer">Reorder List</a>:</p>
<blockquote>
<p>You are given the head of a singly linked-list. The list can be represented as:</p>
<p><code>L0 → L1 → … → Ln - 1 → Ln</code></p>
<p><em>Reorder the list to be on the following form:</em></p>
<p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p>
<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg" alt="Example image"></p>
<hr>
<p>My initial solution was to get every node inside an array first, then link each value to the linked list in an alternating order.</p>
<p>Adding the values to an array is easy:</p>
<pre><code class="language-ts">let nums = [];
let current = head;

while (current !== null) {
  nums.push(current.val);
  current = current.next;
}
</code></pre>
<Note>
Since we shouldn't modify the `head` pointer in this case, we keep a `current` pointer pointing to `head`, and update its value in each iteration.
</Note>

<p>Then, we can point our <code>current</code> pointer back to the <code>head</code> node, and slice <code>nums</code> to start from the second element (since <code>current</code> is already pointing to the first element). That&#39;s also easy:</p>
<pre><code class="language-ts">current = head;
nums = nums.slice(1);
</code></pre>
<p>Then, we can use the <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers" target="_blank" rel="noopener noreferrer">Two Pointers technique</a> to link the elements in an alternating fashion. We can also keep a <a href="https://en.wikipedia.org/wiki/Sentinel_value" target="_blank" rel="noopener noreferrer">flag variable</a> to know which direction (left or right) to go next.</p>
<p>Since we&#39;re already pointing to the first element, we need to add the next item from the reversed portion (going left), so we can initialize this variable as <code>false</code>:</p>
<pre><code class="language-ts">let goRight = false;
</code></pre>
<p>Then, as we update our <code>left</code> and <code>right</code> pointers, we can link our newly created <code>ListNode</code>, and flip the <code>goRight</code> flag accordingly.</p>
<p>Overall, it looks like this:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

/**
 Do not return anything, modify head in-place instead.
 */
function reorderList(head: ListNode | null): void {
  let nums = [];
  let current = head;

  while (current !== null) {
    nums.push(current.val);
    current = current.next;
  }

  current = head;
  nums = nums.slice(1);
  let left = 0;
  let right = nums.length - 1;
  let goRight = false;

  while (left &lt;= right) {
    if (goRight) {
      current.next = new ListNode(nums[left++]);
      goRight = false;
    } else {
      current.next = new ListNode(nums[right--]);
      goRight = true;
    }
    current = current.next;
  }
};
</code></pre>
<h4>Time and space complexity</h4>
<p>Adding each value to an array is an $O(n)$ operation since we visit every node in the linked list. Then, we&#39;ll traverse this array again to convert it back to a linked list — another $O(n)$ operation. Therefore, the time complexity of the overall function ends up being $O(n)$.<br>The space complexity is also $O(n)$ because of the array we create to store the values.</p>
<hr>
<p>There is another way to solve this problem, as shown by <a href="https://youtu.be/S5bfdUTrKLM?si=S4SP6uJwQ-wYU8qP" target="_blank" rel="noopener noreferrer">NeetCode</a>.</p>
<p>In this version, we&#39;ll make use of the <a href="https://rivea0.github.io/blog/leetcode-meditations-interlude-fast-and-slow-pointers" target="_blank" rel="noopener noreferrer">Fast and Slow Pointers</a> technique, where we initialize two pointers: <code>fast</code> and <code>slow</code>. <code>slow</code> will initially point to the <code>head</code>, while <code>fast</code> will point to <code>head.next</code>, and we&#39;ll update them until <code>fast</code> (or its <code>next</code> pointer) reaches the end, at which point <code>slow</code> stays at the middle node.</p>
<pre><code class="language-ts">let slow = head;
let fast = head.next;
while (fast !== null &amp;&amp; fast.next !== null) {
  slow = slow.next;
  fast = fast.next.next;
}
</code></pre>
<p>Now that <code>slow</code> is at the middle node, we can partition the list into two.<br>However, we need to go through the second half in reverse order. So, we can get the head of this second half (which is <code>slow.next</code>), and point its <code>next</code> pointer to <code>null</code>. </p>
<pre><code class="language-ts">let second = slow.next;
slow.next = null;
</code></pre>
<p>Then, we&#39;ll just iterate in reverse order. If you remember from <a href="https://rivea0.github.io/blog/leetcode-meditations-reverse-linked-list" target="_blank" rel="noopener noreferrer">Reverse Linked List</a>, this is how we&#39;re going to do it:</p>
<pre><code class="language-ts">let prevNode = null;

while (second !== null) {
  let nextNode = second.next;
  second.next = prevNode;
  prevNode = second;
  second = nextNode;
}
</code></pre>
<p>Now that the second portion is reversed, we can go ahead and do the main job of merging all the nodes.</p>
<p>After this reversing operation, the <code>prevNode</code> is now at the last node of the list (because <code>second</code> points to <code>null</code>). Now, we&#39;ll alternate pointers: pointing <code>left</code>&#39;s <code>next</code> to the right, and <code>right</code>&#39;s <code>next</code> to the left one.</p>
<pre><code class="language-ts">let left = head;
let right = prevNode;

while (right !== null) {
  let nextLeft = left.next;
  let nextRight = right.next;
  // Rearrange pointers alternatively
  left.next = right;
  right.next = nextLeft;
  // Update pointers
  left = nextLeft;
  right = nextRight;
}
</code></pre>
<Note>
Since the right pointer might reach `null` first (as the second half is likely to be shorter), we'll iterate until `right` is not `null`.
</Note>


<p>All in all, the function will look like this:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

/**
 Do not return anything, modify head in-place instead.
 */
function reorderList(head: ListNode | null): void {
  // Get to the middle node
  let slow = head;
  let fast = head.next;
  while (fast !== null &amp;&amp; fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }

  // Get the head of the second half of the list
  let second = slow.next;
  slow.next = null;
    
  // Reverse the second half of the list
  let prevNode = null;
  while (second !== null) {
    let nextNode = second.next;
    second.next = prevNode;
    prevNode = second;
    second = nextNode;
  }

  let left = head;
  let right = prevNode;

  while (right !== null) {
    let nextLeft = left.next;
    let nextRight = right.next;
    // Rearrange pointers alternatively
    left.next = right;
    right.next = nextLeft;
    // Update pointers
    left = nextLeft;
    right = nextRight;
  }
};
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity is again $O(n)$ in this version, as we need to &quot;touch&quot; each node. However, space complexity is constant, that is, $O(1)$ as we don&#39;t need extra amount of space that will grow with the input size, which is better.</p>
<hr>
<p>If you feel a bit dizzy after rearranging all those pointers, now it&#39;s time to take a breath.<br>The next problem will be <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener noreferrer">Remove Nth Node From End of List</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-reorder-list</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-reorder-list</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 07 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Interlude: Fast & Slow Pointers]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-06/26-lm-interlude.png" alt="Cover image"></p>
<p>Before we start the <a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener noreferrer">next problem in the series</a>, let&#39;s take a quick look at a technique that comes in handy when it comes to working with linked lists.</p>
<p>We can keep two pointers while traversing a linked list: fast and slow. While the fast one increases by two steps, the slow pointer will increase by just one step. </p>
<h4>Finding the middle node of a linked list</h4>
<p>When the fast pointer reaches the end of the list, the slow pointer will be at the &quot;middle&quot; node.</p>
<p>Let&#39;s see it conceptually:</p>
<pre><code class="language-js">let slow = head;
let fast = head;

while (fast !== null &amp;&amp; fast.next !== null) {
  slow = slow.next;
  fast = fast.next.next;
}
</code></pre>
<p>We can think of a list like <code>[1, 2, 3, 4, 5]</code> (where each value is a node in the linked list).</p>
<p>Both <code>fast</code> and <code>slow</code> start pointing to the head, that is, <code>1</code>.</p>
<p>Then, we update the slow pointer one step, which will be <code>2</code>. And, <code>fast</code> will be at <code>3</code>.</p>
<p>When we update <code>slow</code> again, it will be at <code>3</code>.<br>When the fast pointer increases, it will be two steps ahead, and its <code>next</code> pointer will point to the <code>null</code> value, at which point our loop will stop iterating. </p>
<p><code>slow</code> will end up pointing to the node with the value <code>3</code>, which is the middle node.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-06/fast-and-slow.gif" alt="An example of fast and slow pointers"></p>
<p>With an even number of nodes, there are two candidates for the middle node. For example, with a list like <code>[1, 2, 3, 4]</code>, our current implementation will find the middle as <code>3</code>.</p>
<hr>
<p>This technique is also useful to detect cycles in a linked list, but we&#39;ll see that in an upcoming problem.<br>For now, knowing that it exists is sufficient and makes our day better. Happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-interlude-fast-and-slow-pointers</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-interlude-fast-and-slow-pointers</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 06 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Merge Two Sorted Lists]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-05/25-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener noreferrer">Merge Two Sorted Lists</a> says:</p>
<blockquote>
<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>
<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return <em>the head of the merged linked list</em>.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="Example for merging two sorted lists"></p>
<pre><code class="language-ts">mergeTwoLists([1, 2, 4], [1, 3, 4]);
// -&gt; [1, 1, 2, 3, 4, 4]


mergeTwoLists([], []);
// -&gt; []


mergeTwoLists([], [0]);
// -&gt; [0]
</code></pre>
<hr>
<p>First, let&#39;s think about how we would do it with a simple array. We would have two pointers: one for the first array, and the other for the second.<br>As we iterate through them both simultaneously, we&#39;d get the smaller value in our result array. At the end of the iteration, if there are some more elements left in one of the arrays (in case of different lengths), we&#39;d simply add them all as well.</p>
<p>Let&#39;s write a pseudocode of how we would go about doing it:</p>
<pre><code>i = 0
j = 0
result = []

while i &lt; arr1.length and j &lt; arr2.length:
    if arr1[i] &lt; arr2[j]:
        add arr1[i] to result
        i = i + 1
    else:
        add arr2[j] to result
        j = j + 1

while i &lt; arr1.length:
    add arr1[i] to result
    i = i + 1

while j &lt; arr2.length:
    add arr2[j] to result
    j = j + 1
</code></pre>
<p>The solution for this problem looks very similar, only difference is that we&#39;ll do it with a linked list. Let&#39;s look at it in TypeScript:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function mergeTwoLists(
  list1: ListNode | null,
  list2: ListNode | null
): ListNode | null {
  // Start with an initial node with value 0
  let result = new ListNode(0);
  let currentNode = result;

  while (list1 !== null &amp;&amp; list2 !== null) {
    if (list1.val &lt; list2.val) {
      currentNode.next = list1;
      list1 = list1.next;
    } else {
      currentNode.next = list2;
      list2 = list2.next;
    }

    currentNode = currentNode.next;
  }

  if (list1 !== null) {
    currentNode.next = list1;
  }

  if (list2 !== null) {
    currentNode.next = list2;
  }

  // Go past the first dummy value of 0
  return result.next;
}
</code></pre>
<p>We initialize <code>result</code> with a node that holds the value of <code>0</code>. We&#39;ll also keep a pointer to <code>currentNode</code> that initially points to the head of <code>result</code>.<br>As we traverse the lists, we&#39;ll <em>link</em> the smaller value first by pointing <code>currentNode</code>&#39;s <code>next</code> pointer to that value.</p>
<p>If, at the end, we haven&#39;t finished looking at all the nodes in one of the lists (in case of different lengths), we&#39;ll simply link the rest of it.</p>
<p>To return, we need to go past the first initial dummy node with the value <code>0</code>, so we&#39;ll return <code>result.next</code> which starts with the actual value that we added from one of the lists. And, we&#39;re done.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(m + n)$ —where $m$ is the length of the first list, and $n$ is the length of the second list— because we need to &quot;touch&quot; each node in each list once. </p>
<p>The space complexity is $O(n)$ because of the <code>result</code> list we hold: its size will grow with the input size.</p>
<hr>
<p>Next up is a slightly more challenging problem called <a href="https://leetcode.com/problems/reorder-list" target="_blank" rel="noopener noreferrer">Reorder List</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-merge-two-sorted-lists</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-merge-two-sorted-lists</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 05 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Reverse Linked List]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-04-02/24-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/reverse-linked-list" target="_blank" rel="noopener noreferrer">Reverse Linked List</a> states:</p>
<blockquote>
<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="Reversing linked list example image"></p>
<hr>
<p>From a single node&#39;s perspective, what we need to do is to update the next pointer to point to the previous node. But, before that, we need to hold on to the original next node, otherwise we&#39;ll unlink it, and lose all the data.</p>
<p>So, as we traverse the linked list, we need to keep a pointer to the next node, and update the next pointer to point to the previous node:</p>
<pre><code class="language-ts">let nextNode = currentNode.next;
currentNode.next = prevNode;
</code></pre>
<p>Then, we&#39;ll go to the next node in the list. It will look like this:</p>
<pre><code class="language-ts">prevNode = currentNode;
currentNode = nextNode;
</code></pre>
<p>All in all, the whole function is just about it:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function reverseList(head: ListNode | null): ListNode | null {
  let prevNode: ListNode | null = null;
  let currentNode: ListNode | null = head;

  while (currentNode) {
    let nextNode = currentNode.next;
    currentNode.next = prevNode;
    prevNode = currentNode;
    currentNode = nextNode;
  }

  return prevNode;
};
</code></pre>
<hr>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ because we traverse the whole list. Even though arranging pointers is an $O(1)$ operation, since we do it for each node, the overall time complexity is $O(n)$.</p>
<p>The space complexity is $O(1)$ because we don&#39;t have any additional space requirements that will grow with the input size.</p>
<hr>
<h5>Recursive solution(s)</h5>
<p>We can also solve this problem recursively; however, while the time complexity stays the same, the space complexity will be worse: $O(n)$.<br>This is usually the case with recursive solutions, even though we gain on elegance, there is a space tradeoff.</p>
<p>This one looks very similar to the iterative solution. We&#39;ll keep pointers to the current and previous nodes. Our base case is when the current node is null, in that case we&#39;ll return the previous node. Otherwise, we&#39;ll just update the current node&#39;s next pointer to point to the previous node.</p>
<p>It will look like this:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function reverseList(head: ListNode | null): ListNode | null {
  function reverse(currentNode: ListNode | null, prevNode: ListNode | null) {
    if (currentNode === null) {
      return prevNode;
    } else {
      let nextNode = currentNode.next;
      currentNode.next = prevNode;

      return reverse(nextNode, currentNode);
    }
  }

  return reverse(head, null);
};
</code></pre>
<hr>
<p>There is also another recursive solution where we don&#39;t keep a pointer to the previous node, as in <a href="https://youtu.be/G0_I-ZF0S38?si=ab7zCuMXFTNXUAV_&t=289" target="_blank" rel="noopener noreferrer">this example from NeetCode</a>.</p>
<p>This one was a bit tough for me to understand initially.<br>But, it&#39;s again important to think about solving the subproblem.<br>Our base case is when the <code>head</code> is <code>null</code>: we&#39;ll just return <code>null</code>.</p>
<p>Now, it&#39;s time to take a deep breath, and think about the subproblem.</p>
<p>From one node&#39;s perspective, what does <em>reversing</em> look like?</p>
<p>So, if we&#39;re just one node (<code>head</code>), and there is a next node after us (<code>head.next</code>), we need to point the next pointer of that next node to us:</p>
<pre><code class="language-ts">head.next.next = head;
</code></pre>
<p>But <strong>before that</strong>, that next node should have been reversed already:</p>
<pre><code class="language-ts">reverseList(head.next);
</code></pre>
<p>That&#39;s fine so far. However, we need our base case to work, so we have to set <em>our</em> next pointer to <code>null</code>:</p>
<pre><code class="language-ts">head.next = null;
</code></pre>
<p>Remember that we &quot;reversed&quot; the next node, with <code>reverseList(head.next)</code>? Now it&#39;s supposed to be the new head, so we&#39;ll return it.</p>
<p>Solving the subproblem solves the whole problem in this sense, so the function will look like this:</p>
<pre><code class="language-ts">/**
 * Definition for singly-linked list.
 * class ListNode {
 *   val: number
 *   next: ListNode | null
 *   constructor(val?: number, next?: ListNode | null) {
 *     this.val = (val === undefined ? 0 : val)
 *     this.next = (next === undefined ? null : next)
 *   }
 * }
 */

function reverseList(head: ListNode | null): ListNode | null {
  if (head === null) {
    return null;
  }

  let currentNode: ListNode | null = head;

  if (head.next) {
    currentNode = reverseList(head.next);
    head.next.next = head;
  }

  head.next = null;

  return currentNode;
};
</code></pre>
<p>It&#39;s a bit challenging to grasp initially, but it makes sense when you work through it; well, that&#39;s recursion.</p>
<hr>
<p>This was a great opener for the Linked Lists chapter. Next up is <a href="https://leetcode.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener noreferrer">Merge Two Sorted Lists</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-reverse-linked-list</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-reverse-linked-list</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 02 Apr 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 6: Linked Lists]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-31/23-lm-ch6.png" alt="Cover image"></p>
<p>A linked list is a linear data structure that you&#39;re likely to be familiar with. It is also a dynamic data structure that can grow and shrink dynamically, so unlike arrays, there&#39;s no need to allocate memory beforehand.</p>
<p>An important part of a linked list is the <em>head pointer</em> that points to the beginning of the list. There may or may not be a <em>tail pointer</em> that also points to the end of the list. </p>
<p>The core ingredient of a linked list is a simple node, which consists of two parts: data and the next pointer.<br>So, it is an important idea to remember: <em>a node only knows about its data and its neighbor.</em></p>
<p>The very last node in the linked list points to <code>null</code> to indicate it&#39;s the end of the list.</p>
<p>However, there are different types of linked lists that differ from each other slightly, so let&#39;s briefly take a look at them.</p>
<hr>
<h4>Singly linked lists</h4>
<p>The core idea with singly linked lists is that each node, along with the data it has, have a pointer that points <em>only</em> to the next node:</p>
<pre><code class="language-js">class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
</code></pre>
<p>And here is an example where we have three nodes, holding the values <code>1</code>, <code>2</code>, and <code>3</code> consecutively:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-31/singly-ll.gif" alt="Singly linked list example"></p>
<p>Here is a simple implementation of a singly linked list in JavaScript:</p>
<pre><code class="language-js">class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  // Add value to the end of the list
  append(value) {
    let node = new Node(value);
    // If the list is empty
    if (this.head === null) {
      this.head = node;
      this.tail = this.head;
    } else {
      this.tail.next = node;
      this.tail = node;
    }
    
    this.length++;
    return this;
  }

  // Add value to the beginning of the list
  prepend(value) {
    let node = new Node(value);
    // If the list is empty
    if (this.head === null) {
      this.head = node;
      this.tail = this.head;
    } else {
      node.next = this.head;
      this.head = node;
    }
    
    this.length++;
    return this;
  }

  remove(value) {
    // If the list is empty, return null
    if (this.head === null) { 
      return null; 
    }

    // If it is the first element
    if (this.head.data === value) {
      this.head = this.head.next;
      this.length--;
      // If it is the only element 
      // (we don&#39;t have anything after removing it)
      if (this.head === null) {
        this.tail = null;
      } 
      return;
    }

    let currentNode = this.head;
    
    while (currentNode.next) {
      if (currentNode.next.data === value) {
        currentNode.next = currentNode.next.next;
        // If it is the last element, update tail
        if (currentNode.next === null) {
          this.tail = currentNode;
        } 
        this.length--;
        return;
      }
      currentNode = currentNode.next;
    }
  }

  search(value) {
    let currentNode = this.head;

    while (currentNode) {
      if (currentNode.data === value) {
        return currentNode;
      }
      currentNode = currentNode.next;
    }

    // If the value does not exist, return null
    return null;
  }

  printList() {
    let values = [];
    let currentNode = this.head;
    while (currentNode) {
      values.push(currentNode.data);
      currentNode = currentNode.next;
    }
    
    console.log(values);
  }
}
</code></pre>
<Note>
We'll keep a tail pointer in all these examples for convenience. It [doesn't hurt](https://softwareengineering.stackexchange.com/a/301863) to have a tail pointer.
</Note>

<hr>
<h4>Doubly linked lists</h4>
<p>Doubly linked lists differ from the &quot;singly&quot; ones in that each node also have another pointer that points to the previous element.</p>
<p>So, this time, a single node will look different:</p>
<pre><code class="language-js">class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.previous = null;
  }
}
</code></pre>
<p>Here is the same example as above, but as a doubly linked list:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-31/doubly-ll.gif" alt="Doubly linked list example"></p>
<p>A simple implementation might look like this:</p>
<pre><code class="language-js">class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  // Add value to the end of the list
  append(value) {
    let node = new Node(value);
    // If the list is empty
    if (this.head === null) {
      this.head = node;
      this.tail = this.head;
    } else {
      node.previous = this.tail;
      this.tail.next = node;
      this.tail = node;
    }
    
    this.length++;
    return this;
  }

  // Add value to the beginning of the list
  prepend(value) {
    let node = new Node(value);
    // If the list is empty
    if (this.head === null) {
      this.head = node;
      this.tail = this.head;
    } else {
      this.head.previous = node;
      node.next = this.head;
      this.head = node;
    }
    
    this.length++;
    return this;
  }

  remove(value) {
    // If the list is empty, return null
    if (this.head === null) { 
      return null;
    }

    let currentNode = this.head;

    // If it is the first element
    if (currentNode.data === value) {
      this.head = currentNode.next;
      // If the removed element is not the only one,
      // make the previous pointer of the new head null
      if (this.head) {
        this.head.previous = null;
      // If the removed element was the only element,
      // point the tail to null as well
      } else {
        this.tail = null;
      }
      this.length--;
      return;
    }

    while (currentNode) {
      if (currentNode.data === value) {
        if (currentNode.previous) {
          currentNode.previous.next = currentNode.next;
        }
        if (currentNode.next) {
          currentNode.next.previous = currentNode.previous;
        // If it&#39;s the last element in the list, update tail
        // to point to the previous node
        } else {
          this.tail = currentNode.previous;
        }
        
        this.length--;
        return;
      }
    
      currentNode = currentNode.next;
    }
  }

  search(value) {
    let currentNode = this.head;
    while (currentNode) {
      if (currentNode.data === value) {
        return currentNode;
      }
      currentNode = currentNode.next;
    }

    // If the value does not exist, return null
    return null;
  }

  printList() {
    let values = [];
    let currentNode = this.head;
    
    while (currentNode) {
      values.push(currentNode.data);
      currentNode = currentNode.next;
    }
    
    console.log(values);
  }
}
</code></pre>
<hr>
<h4>Circular linked lists</h4>
<p>With circular linked lists, we have the last node also pointing to the first element, creating circularity.</p>
<p>We&#39;ll only look at the singly circular linked list for simplicity&#39;s sake, so our node will look the same as in the first example:</p>
<pre><code class="language-js">class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
</code></pre>
<p>The same example, in a circular linked list fashion:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-31/circular-ll.gif" alt="Circular linked list example"></p>
<p>Here is a simple implementation:</p>
<pre><code class="language-js">class CircularLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
  }

  // Add value to the &quot;end&quot; of the list
  append(value) {
    let node = new Node(value);
    // If the list is empty
    if (this.head === null) {
      this.head = node;
      this.tail = node;
      // As the only node in the list, it should point to itself
      node.next = node;
    } else {
      // As the &quot;last&quot; node, it should point to the head (this.tail.next)
      node.next = this.tail.next;
      this.tail.next = node;
      this.tail = node;
    }
  }

  // Add value to the beginning of the list
  prepend(value) {
    let node = new Node(value);
    node.next = this.head;
    // Update last node&#39;s next pointer to point to the new node
    this.tail.next = node;
    this.head = node;
  }  

  remove(value) {
    // If the list is empty, return null
    if (this.head === null) { 
      return null; 
    }

    // If it is the first element
    if (this.head.data === value) {
      // If it&#39;s the only element
      if (this.head.next === this.head) {
        this.head = null;
        this.tail = null;
        return;
      }
      this.head = this.head.next;
      this.tail.next = this.head;
      this.length--;
      return;
    }

    let currentNode = this.head;
    let prevNode = null;

    // Iterate until you find the value or
    // you don&#39;t find it after traversing the whole list
    while (currentNode.data !== value || prevNode === null) {
      if (currentNode.next === this.head) { 
        break; 
      }
      prevNode = currentNode;
      currentNode = currentNode.next;
    }

    if (currentNode.data === value) {
      // If there is a previous node before the element to be removed,
      // update the previous node&#39;s next pointer to point to
      // the one after the element to be removed
      // (unlink it)
      if (prevNode) {
        prevNode.next = currentNode.next;
        // If the element to be removed is the last one,
        // update tail to be the previous node
        if (this.tail === currentNode) {
          this.tail = prevNode;
        }
      // If the element to be removed is the first one in the list
      } else {
        // If it&#39;s the only one in the list
        if (this.head.next === this.head) {
          this.head = null;
          this.tail = null;
        } else {
          this.head = this.head.next;
          this.tail.next = this.head;
        }
      }
    }
  }

  printList() {
    let nodes = [];
    let currentNode = this.head;
    if (this.head === null) { 
      console.log(nodes); 
      return;
    }

    // Traverse the list once to add the values, 
    // don&#39;t go in circles
    do {
      nodes.push(currentNode.data);
      currentNode = currentNode.next;
    } while (currentNode !== this.head);

    console.log(nodes);
  }
}
</code></pre>
<h5>Time and space complexity</h5>
<p>With linked lists, the time complexity for accessing an element is in the worst case $O(n)$.<br><em>Prepending</em> and <em>appending</em> an element depends on whether we have a tail pointer; if we have it, then, both operations are $O(1)$ as we only need to arrange pointers.<br>However, if we don&#39;t have a tail pointer, <em>appending</em> an element requires traversing the whole list, so it is an $O(n)$ operation.<br>Removing an element is similar, in the worst case, it is $O(n)$.</p>
<p>The space complexity is linear—$O(n)$—, the amount of data to store grows linearly with the number of nodes in the list.</p>
<hr>
<p>The first problem in this chapter is <a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener noreferrer">Reverse Linked List</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-6-linked-lists</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-6-linked-lists</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 31 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Search in Rotated Sorted Array]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-29/22-lm.png" alt="Cover image"></p>
<p>The description for this problem states:</p>
<blockquote>
<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>
<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>
<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">search([4, 5, 6, 7, 0, 1, 2], 0);
// -&gt; 4


search([4, 5, 6, 7, 0, 1, 2], 3);
// -&gt; -1


search([1], 0);
// -&gt; -1
</code></pre>
<hr>
<p>This one is really a hard problem where we have to think of all the cases that can possibly occur.<br>We&#39;ll use binary search, and similar to the <a href="https://rivea0.github.io/blog/leetcode-meditations-find-minimum-in-rotated-sorted-array" target="_blank" rel="noopener noreferrer">previous problem</a>, we&#39;ll consider two sorted portions in the array: left and right. Also, as with binary search, we&#39;ll have two pointers <code>low</code> and <code>high</code> pointing to the <code>0</code>th and the last index respectively.<br>With normal binary search, we search the right portion only when the middle element is less than the target; and search the left portion when the middle element is more than the target. But here, things are different.</p>
<p>If we&#39;re in a sorted portion, we&#39;ll search the right if:</p>
<ul>
<li>the target is greater than the middle element</li>
</ul>
<p>or </p>
<ul>
<li>the target is less than the value that <code>low</code> points to.</li>
</ul>
<p>Otherwise, we&#39;ll go left.</p>
<p>Else if we&#39;re not in a sorted portion, we&#39;ll search the left if:</p>
<ul>
<li>the target is less than the middle element</li>
</ul>
<p>or </p>
<ul>
<li>the target is greater than the value that <code>high</code> points to.</li>
</ul>
<p>Otherwise, we&#39;ll go right.</p>
<Note>
**Searching the right** refers to updating `low` to be `mid + 1`, and **searching the left** refers to updating `high` to be `mid - 1`.
</Note>

<p>Here is a solution in TypeScript:</p>
<pre><code class="language-ts">function search(nums: number[], target: number): number {
  let low = 0;
  let high = nums.length - 1;

  while (high &gt;= low) {
    let mid = Math.floor((high + low) / 2);

    if (nums[mid] === target) {
      return mid;
    }

    if (nums[low] &lt;= nums[mid]) {
      if (target &gt; nums[mid] || target &lt; nums[low]) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    } else {
      if (target &lt; nums[mid] || target &gt; nums[high]) {
        high = mid - 1;
      } else {
        low = mid + 1;
      }
    }
  }

  return -1;
};
</code></pre>
<p>It might look confusing and hard to wrap your mind around at first, because it is. I find this problem to be one of the most challenging ones in this series so far. It means that it&#39;s now time to take a deep breath.</p>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(log \ n)$ as we use binary search, halving the search space with each iteration. The space complexity is $O(1)$ because we don&#39;t make use of any extra space that proportionally grows with the input size.</p>
<hr>
<p>Next up, we&#39;ll start a chapter on Linked Lists. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-search-in-rotated-sorted-array</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-search-in-rotated-sorted-array</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 29 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Find Minimum in Rotated Sorted Array]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-26/21-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array" target="_blank" rel="noopener noreferrer">this problem</a>:</p>
<blockquote>
<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>
<ul>
<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>
<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>
</ul>
<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>
<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>
<p>You must write an algorithm that runs in <code>O(log n) time.</code></p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">findMin([3, 4, 5, 1, 2]);
// -&gt; 1
// The original array was [1, 2, 3, 4, 5] rotated 3 times.


findMin([4, 5, 6, 7, 0, 1, 2]);
// -&gt; 0
// The original array was [0, 1, 2, 4, 5, 6, 7] and it was rotated 4 times.


findMin([11, 13, 15, 17]);
// -&gt; 11
// The original array was [11, 13, 15, 17] and it was rotated 4 times.
</code></pre>
<p>For instance, moving the rightmost element to the left once is one rotation. </p>
<hr>
<p>It is easy to find a linear solution using linear search, like this:</p>
<pre><code class="language-ts">function findMin(nums: number[]): number {
  let min = Infinity;

  for (let n of nums) {
    min = Math.min(min, n);
  }

  return min;
};
</code></pre>
<p>Or, given that the numbers are sorted, we can find the first element where the number on the left side is larger:</p>
<pre><code class="language-ts">function findMin(nums: number[]): number {
  for (let i = 0; i &lt; nums.length; i++) {
    if (i - 1 &gt;= 0 &amp;&amp; nums[i - 1] &gt; nums[i]) {
      return nums[i];
    }
  }

  // Not rotated or rotated (nums.length * n) times.
  // So the minimum element is the first one.
  return nums[0];
};
</code></pre>
<p>However, the problem specifically asks for a solution with  logarithmic time complexity.</p>
<p>Let&#39;s take a deep breath, and think about one approach.</p>
<hr>
<p>We can think of the minimum element as the pivot point where the array was rotated. With this pivot, we have two sorted portions of the array: left and right.</p>
<p>Binary search can still be useful here. We&#39;ll initialize <code>low</code> and <code>high</code> pointers to the <code>0</code>th and the last index respectively. We can leverage the fact that the both portions are sorted, so if the value at <code>low</code> is less than the value at <code>high</code>, that means either the array is not rotated at all or the number of times it&#39;s rotated is a multiple of its size. Either way, the array is fully sorted, so we can return the first element and be done with it.</p>
<p>Otherwise, we&#39;ll go on with the usual binary search, where we calculate the midpoint first. Once the midpoint is less than the element to the left of it, that means it is the pivot, so we can just return that midpoint. However, if it&#39;s greater than the value that <code>high</code> points to, it means we need to search the right portion, so we update <code>low</code> to be <code>mid + 1</code>. Otherwise, we need to search the left portion, so we&#39;ll update <code>high</code> to be <code>mid - 1</code>.</p>
<p>Here&#39;s one way to write it in TypeScript:</p>
<pre><code class="language-ts">function findMin(nums: number[]): number {
  let low = 0;
  let high = nums.length - 1;

  // Not rotated or rotated (nums.length * n) times
  if (nums[low] &lt;= nums[high]) {
    return nums[low];
  }

  while (high &gt;= low) {
    let mid = Math.floor((high + low) / 2);

    if (nums[mid] &lt; nums[mid - 1]) {
      return nums[mid];
    }

    if (nums[mid] &gt; nums[high]) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
};
</code></pre>
<hr>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(log \ n)$ as we use binary search. With each iteration, we divide the search space in half, which results in logarithmic time complexity. We don&#39;t use any additional data structures that will grow proportionally with the input size, so the space complexity is $O(1)$.</p>
<hr>
<p>The next problem is <a href="https://leetcode.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener noreferrer">Search in Rotated Sorted Array</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-find-minimum-in-rotated-sorted-array</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-find-minimum-in-rotated-sorted-array</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 5: Binary Search]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-24/20-lm-ch5.png" alt="Cover image"></p>
<p>Binary search is one of the most well-known algorithms. It&#39;s also a <a href="https://brilliant.org/wiki/divide-and-conquer/" target="_blank" rel="noopener noreferrer">divide-and-conquer algorithm</a>, where we break the problem into smaller components.</p>
<p>The crux of binary search is to find a target element in a given sorted array.<br>We have two pointers: <code>high</code> to point to the largest element, and <code>low</code> to point to the smallest element. We first initialize them for the whole array itself, with <code>high</code> being the last index and <code>low</code> being the first index. Then, we calculate the midpoint. If the target is greater than the midpoint, then we adjust our <code>low</code> pointer to point to the <code>mid + 1</code>, otherwise if the target is less than the midpoint, we adjust <code>high</code> to be <code>mid - 1</code>. With each iteration, we eliminate half the array until the midpoint equals target or the <code>low</code> pointer passes <code>high</code>. </p>
<p>If we find the index of the target, we can return it as soon as we find it; otherwise, we can just return <code>-1</code> to indicate that the target doesn&#39;t exist in the array.</p>
<p>For example, if we have a <code>nums</code> array <code>[-1, 0, 3, 5, 9, 12]</code> and our <code>target</code> is <code>9</code>, the operation looks like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-24/binary-search.gif" alt="Binary search example"></p>
<p>We can write it in TypeScript like this: </p>
<pre><code class="language-ts">function search(nums: number[], target: number): number {
  let high = nums.length - 1;
  let low = 0;

  while (high &gt;= low) {
    let mid = Math.floor((high + low) / 2);

    if (target &gt; nums[mid]) {
      low = mid + 1;
    } else if (target &lt; nums[mid]) {
      high = mid - 1;
    } else {
      return mid;
    }
  }

  return -1;
};
</code></pre>
<h5>Time and space complexity</h5>
<p>The time complexity of a binary search algorithm is $O(log \ n)$ in the worst case. (For example, if the target is not in the array, we&#39;ll be halving the array until there is one element left.) The space complexity is $O(1)$ as we don&#39;t need extra space.</p>
<hr>
<p>The first problem in this chapter will be <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array" target="_blank" rel="noopener noreferrer">Find Minimum in Rotated Sorted Array</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-5-binary-search</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-5-binary-search</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 24 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Valid Parentheses]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-19/19-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/valid-parentheses" target="_blank" rel="noopener noreferrer">this problem</a> says:</p>
<blockquote>
<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>
</blockquote>
<p>For example: </p>
<pre><code class="language-ts">isValid(&#39;()&#39;);
// -&gt; true


isValid(&#39;()[]{}&#39;);
// -&gt; true


isValid(&#39;(]&#39;);
// -&gt; false
</code></pre>
<hr>
<p>The first idea that comes to mind is, perhaps, adding each parenthesis in the string to a stack, and once we come to one of the closing parentheses, we can check if the previous parenthesis is its opening pair. If so, we can pop them both off the stack. If we are left with an empty stack at the end, that means all the parentheses match, so we can return <code>true</code>; otherwise, we&#39;ll return <code>false</code>.</p>
<p>For example, if our string is <code>([{}])</code> (which is valid), it will look like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-17/stack.gif" alt="Stack for checking valid parentheses"></p>
<p>My initial solution in TypeScript looked like this:</p>
<pre><code class="language-ts">function isValid(s: string): boolean {
  let stack = [];
  const opening = [&#39;(&#39;, &#39;{&#39;, &#39;[&#39;];
  const closing = [&#39;)&#39;, &#39;}&#39;, &#39;]&#39;];
  for (const c of s) {
    stack.push(c);
    if (closing.includes(c)) {
      let prevItem = stack[stack.length - 2];
      if (opening.includes(prevItem) &amp;&amp; 
          opening.indexOf(prevItem) === closing.indexOf(c)) {
            stack.pop();
            stack.pop();
      }
    }
  }

  if (!stack.length) {
    return true;
  }

  return false;
};
</code></pre>
<p>However, there is a slightly better way, where we can use a hash table for parentheses, mapping the closing ones to their opening pairs. We also don&#39;t have to push every character onto the stack, and can return immediately when the parentheses don&#39;t match:</p>
<pre><code class="language-ts">function isValid(s: string): boolean {
  let stack = [];
  const parentheses = {
    &#39;)&#39;: &#39;(&#39;,
    &#39;]&#39;: &#39;[&#39;,
    &#39;}&#39;: &#39;{&#39;
  }
  for (const c of s) {
    // If it&#39;s a closing parenthesis
    if (c in parentheses) { 
      // If the stack is not empty and the previous item on the stack is its opening pair
      if (stack.length &amp;&amp; stack[stack.length - 1] === parentheses[c]) {
        stack.pop();
      } else {
        return false;
      }
    } else {
      stack.push(c);
    }
  }

  if (!stack.length) {
    return true;
  }

  return false;
};
</code></pre>
<p>Here, as we iterate through the characters of <code>s</code>, if it&#39;s an opening parenthesis, we&#39;ll just push it to our stack. When we come to a closing parenthesis, if our stack is not empty and the last item we added to our stack matches the opening pair of the closing one we&#39;re looking at, we can just pop it off the stack. Otherwise, it&#39;s not a matching pair, so we can return <code>false</code> immediately. </p>
<p>At the end, if our stack is empty, we can return <code>true</code>, otherwise we&#39;ll return <code>false</code>.</p>
<h4>Time and space complexity</h4>
<p>The time complexity for this solution is $O(n)$ because in the worst case where each character in the input string is an opening parenthesis, we&#39;ll loop through the entire string, so the runtime growth is proportionate to its length.<br>The space complexity is $O(n)$ because of our stack, which, in the worst case, will have all the characters in the input string.</p>
<hr>
<p>Next up, we&#39;ll start a new chapter on <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank" rel="noopener noreferrer">Binary Search</a>. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-valid-parentheses</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-valid-parentheses</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 19 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 4: Stack]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-17/18-lm-ch4.png" alt="Cover image"></p>
<p>A stack data type is perhaps one of the most well-known ones. A stack of books might be a good example to visualize, however, insertion and deletion can only happen from the one end. A stack operates through the last-in first-out (LIFO) principle: the last item to go in is the first to go out.</p>
<p>Usually we&#39;ll have methods for <em>pushing</em> an element onto the stack, and <em>popping</em> an element from the stack.</p>
<p>For example, let&#39;s say we&#39;re looking for valid parentheses in a given string (more on <a href="https://leetcode.com/problems/valid-parentheses" target="_blank" rel="noopener noreferrer">that problem</a> in the next post), and the operation we&#39;ll do goes like this:</p>
<p>As we iterate over the characters in the string, we <em>push</em> the character onto the stack. If we pushed a closing parenthesis (one of <code>)</code>, <code>}</code>, or <code>]</code>), then, if the previous pushed element is its opening pair, we&#39;ll <em>pop</em> that pair from the stack.</p>
<p>If, at the end, the stack is empty, the string consists of valid parentheses.</p>
<p>It looks like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-17/stack.gif" alt="Stack for checking valid parentheses"></p>
<hr>
<p>A stack can be implemented as an array or a linked list; but using linked lists is more common because with arrays, we have a potential <em>stack overflow</em> when we predefine a maximum stack size. On the other hand, linked lists are not static when it comes to memory, so they are a good candidate to implement stacks. </p>
<p>Linked lists are also efficient because we are using one end of the stack for insertion and deletion, and doing these are constant time operations. </p>
<hr>
<p>Let&#39;s look at one easy stack implementation in Python.</p>
<p>Now, we can use a <code>list</code>, but <a href="https://docs.python.org/3/faq/design.html#how-are-lists-implemented-in-cpython" target="_blank" rel="noopener noreferrer">a list in Python is implemented as a dynamic array underneath</a>, so at one point, pushing an item can be $O(n)$ operation if the list needs to be copied into another memory location. For that reason, we&#39;ll use a <a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank" rel="noopener noreferrer"><code>deque</code></a>, which is implemented as a doubly-linked list, so that we know push and pop operations will be $O(1)$.</p>
<pre><code class="language-python">from collections import deque

class Stack:
    def __init__(self):
        self._stack = deque()

    def push(self, item):
        self._stack.append(item)

    def pop(self):
        return self._stack.pop()

    def peek(self):
        return self._stack[-1]

    def is_empty(self):
        return not bool(len(self._stack))

    def size(self):
        return len(self._stack)
</code></pre>
<p>In addition to <code>push</code> and <code>pop</code>, we&#39;ll also usually have functions like <code>peek</code> to get the topmost item in the stack, <code>is_empty</code> to check if the stack is empty, and <code>size</code> to get the size of the stack.</p>
<hr>
<p>We can also do it using JavaScript. Now, we can do it using an array, but we want to use a linked list instead. Since we don&#39;t have a robust built-in library like Python this time, we&#39;ll implement a very simple version of it ourselves.<br>Even though we haven&#39;t seen linked lists in this series so far, the basic idea is that we have nodes, each of which having a <code>data</code> value, and a <code>next</code> pointer pointing to the next node.</p>
<p>Let&#39;s create a simple node first:</p>
<pre><code class="language-js">class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
</code></pre>
<p>We can write our stack now:</p>
<pre><code class="language-js">class Stack {
  constructor() {
    this.top = null;
    this.length = 0;
  }

  push(item) {
    const node = new Node(item);
    node.next = this.top;
    this.top = node;
    this.length++;
  }

  pop() {
    if (this.isEmpty()) { return null; }

    const data = this.top.data;
    this.top = this.top.next;
    this.length--;

    return data;
  }

  peek() {
    if (this.isEmpty()) { return null; }

    return this.top.data;
  }

  isEmpty() {
    return this.size() === 0;
  }

  size() {
    return this.length;
  }
}
</code></pre>
<h5>Time and space complexity</h5>
<p>Each method we defined has $O(1)$ time complexity, and it would be the same if we were to use an array as well. However, as mentioned above, arrays have limitations in that having to allocate a predefined stack size can lead to a stack overflow. And if we were to use a dynamic array, the whole array might need to be copied to go into another memory location after a certain size is reached, leading to $O(n)$ time. So, linked lists are ideal to implement a stack data type.</p>
<p>The space complexity is linear —$O(n)$—, the stack will grow linearly with the number of items in it.</p>
<hr>
<p>The first and only problem in this chapter is <a href="https://leetcode.com/problems/valid-parentheses" target="_blank" rel="noopener noreferrer">Valid Parentheses</a>, until then, happy coding.</p>
<h6>References</h6>
<p><a href="https://medium.com/basecs/stacks-and-overflows-dbcf7854dc67" target="_blank" rel="noopener noreferrer">https://medium.com/basecs/stacks-and-overflows-dbcf7854dc67</a></p>
<p><a href="https://brilliant.org/wiki/stacks/" target="_blank" rel="noopener noreferrer">https://brilliant.org/wiki/stacks/</a></p>
<p><a href="https://realpython.com/how-to-implement-python-stack/#using-collectionsdeque-to-create-a-python-stack" target="_blank" rel="noopener noreferrer">https://realpython.com/how-to-implement-python-stack/#using-collectionsdeque-to-create-a-python-stack</a></p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-4-stack</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-4-stack</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 17 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Minimum Window Substring]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-16/17-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/minimum-window-substring" target="_blank" rel="noopener noreferrer">Minimum Window String</a>:</p>
<blockquote>
<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <strong><em>substring</em></strong> <em>of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string</em> <code>&quot;&quot;</code>.</p>
<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">minWindow(&#39;ADOBECODEBANC&#39;, &#39;ABC&#39;);
// -&gt; &#39;BANC&#39;
// The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.


minWindow(&#39;a&#39;, &#39;a&#39;);
// -&gt; &#39;a&#39;
// The entire string s is the minimum window.


minWindow(&#39;a&#39;, &#39;aa&#39;);
// -&gt; &#39;&#39;
// Both &#39;a&#39;s from t must be included in the window.
// Since the largest window of s only has one &#39;a&#39;, return empty string.
</code></pre>
<p>This is the first problem in this series that is labeled as having the difficulty level of hard, and rightly so.</p>
<p>Let&#39;s look at one solution in TypeScript:</p>
<pre><code class="language-ts">function minWindow(s: string, t: string): string {
  if (t === &#39;&#39;) {
    return &#39;&#39;;
  }

  let countT = new Map();
  let window = new Map();

  for (let i = 0; i &lt; t.length; i++) {
    if (countT.has(t[i])) {
      countT.set(t[i], countT.get(t[i]) + 1);
    } else {
      countT.set(t[i], 0);
    }
  }

  let have = 0;
  let need = countT.size;
  let result = &#39;&#39;;
  let resultLength = Infinity;
  let left = 0;
  let right = 0;

  while (right &lt; s.length) {
    let char = s[right];
    if (window.has(char)) {
      window.set(char, window.get(char) + 1);
    } else {
      window.set(char, 0);
    }

    if (countT.has(char) &amp;&amp; window.get(char) === countT.get(char)) {
      have++;
    }

    while (have === need) {
      if ((right - left + 1) &lt; resultLength) {
        result = s.slice(left, right + 1);
        resultLength = right - left + 1;
      }

      window.set(s[left], window.get(s[left]) - 1);

      if (countT.has(s[left]) &amp;&amp; window.get(s[left]) &lt; countT.get(s[left])) {
        have--;
      }

      left++;
    }

    right++;
  }

  if (resultLength !== Infinity) {
    return result;
  } else {
    return &#39;&#39;;
  }
};
</code></pre>
<p>This solution is adapted from <a href="https://www.youtube.com/watch?v=jSto0O4AJbM" target="_blank" rel="noopener noreferrer">NeetCode</a>.</p>
<p>First, we need to handle the case where <code>t</code> is empty; if so, we&#39;ll return an empty string.</p>
<p>We start by initializing two hash maps to hold characters for <code>t</code> and our current window. For example, if <code>t</code> is <code>&#39;ABC&#39;</code>, then <code>countT</code> will be this:</p>
<pre><code class="language-js">Map(3) { &#39;A&#39; =&gt; 0, &#39;B&#39; =&gt; 0, &#39;C&#39; =&gt; 0 }
</code></pre>
<p>We&#39;ll have a variable named <code>have</code> to keep track of how many of the letters in <code>t</code> we have in our current window.<br>We also initialize a <code>need</code> variable with the size of <code>countT</code> to keep track of how many letters we <em>need</em> to <em>have</em>.<br>Then, we&#39;ll have <code>result</code> and <code>resultLength</code> that will be keeping track of the <em>minimum window substring</em> we&#39;ve seen so far.</p>
<Note>
`resultLength` is first initialized to (positive) `Infinity`, which is a good start if we want it to have the minimum value as a result. If we were to go for the maximum value, we could initialize it as `-Infinity`.
</Note>

<p>Then, starting with both <code>left</code> and <code>right</code> pointers pointing to the first index, we&#39;ll add each character to our <code>window</code> hash map. If the number of times the current character occurs in <code>t</code> is the same as the number of times it occurs in our current window, we&#39;ll increment our <code>have</code> variable.</p>
<p>That&#39;s good so far. Now let&#39;s look at this part:</p>
<pre><code class="language-ts">while (have === need) {
  if ((right - left + 1) &lt; resultLength) {
    result = s.slice(left, right + 1);
    resultLength = right - left + 1;
  }

  window.set(s[left], window.get(s[left]) - 1);

  if (countT.has(s[left]) &amp;&amp; window.get(s[left]) &lt; countT.get(s[left])) {
    have--;
  }

  left++;
}
</code></pre>
<p>Once what we <em>have</em> is equal to what we <em>need</em>, we&#39;ll do these things while they are still equal:</p>
<p>We&#39;ll first update our minimum result values (<code>result</code> and <code>resultLength</code>) if the length of our current window is less than their previous values.</p>
<p>Then, we&#39;ll see if we can do better. We&#39;ll first decrement the value of the left character in <code>window</code>. If it reaches below the value in <code>countT</code>, then we decrement our <code>have</code> variable because we lack that character in our current window at this point.<br>Note that, here, we&#39;ll only decrement the <code>have</code> variable when a character occurs <em>less than</em> the number of times it occurs in <code>t</code>. We can have more, we&#39;ll be fine with that. For example, if <code>t</code> is <code>&#39;ABC&#39;</code>, we&#39;ll be fine with having more than one <code>&#39;A&#39;</code>s in our current window.</p>
<p>Then, at this point, we&#39;ll also need to increment our <code>left</code> pointer so that we shrink our <code>window</code> and see if we can do better when it comes to the minimum value.</p>
<p>Once we have what we need, we&#39;ll return our result string, which is <code>s</code> sliced from the <code>left</code> index up to (and including) the <code>right</code> index.</p>
<p>However, if we don&#39;t have a result, we&#39;ll just return an empty string. And, that&#39;s all there is to it.</p>
<h4>Time and space complexity</h4>
<p>The time complexity of this solution is $O(n)$, as we have two main loops, one iterating over the elements of <code>t</code>, the other over the elements of <code>s</code>; each one has $O(n)$ time complexity, making the overall time complexity $O(n)$.<br>The space complexity is $O(1)$, because the hash maps will be the dominant additional space, and they are constant, each having 26 items in total.</p>
<hr>
<p>With the hardest (so far!), and the last problem of <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-3-sliding-window" target="_blank" rel="noopener noreferrer">the Sliding Window chapter</a> behind, we can finally start a new chapter on stacks. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-minimum-window-substring</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-minimum-window-substring</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 16 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Longest Repeating Character Replacement]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-15/16-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/longest-repeating-character-replacement/description/" target="_blank" rel="noopener noreferrer">this problem</a> says:</p>
<blockquote>
<p>You are given a string <code>s</code> and an integer <code>k</code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code>k</code> times.</p>
<p>Return <em>the length of the longest substring containing the same letter you can get after performing the above operations</em>.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">characterReplacement(&#39;ABAB&#39;, 2);
// -&gt; 4
// Explanation: Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.


characterReplacement(&#39;AABABBA&#39;, 1);
// -&gt; 4
// Explanation: Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.
// The substring &quot;BBBB&quot; has the longest repeating letters, which is 4.
// There may exists other ways to achieve this answer too.
</code></pre>
<hr>
<p>This one is, I think, very tough, even though it&#39;s labeled as medium difficulty.</p>
<p>Let&#39;s take a deep breath, and look at one solution:</p>
<pre><code class="language-ts">function characterReplacement(s: string, k: number): number {
  let count = Array.from({ length : 26 }, () =&gt; 0);
  let left = 0;
  let right = 0;
  let maxLength = 0;

  while (right &lt; s.length) {
    count[s[right].charCodeAt(0) - &#39;A&#39;.charCodeAt(0)]++;
    while ((right - left + 1) - Math.max(...count) &gt; k) {
      count[s[left].charCodeAt(0) - &#39;A&#39;.charCodeAt(0)]--;
      left++;
    }

    maxLength = Math.max(right - left + 1, maxLength);
    right++;
  }

  return maxLength;
};
</code></pre>
<Note>
`s[right].charCodeAt(0) - 'A'.charCodeAt(0)` calculates the _index_ of the **uppercase** character in the `count` array.
So, if `s[right]` is `'A'`, `s[right].charCodeAt(0)` is `65`, and the result of the calculation is `0`, making it the first index.
If `s[right]` is `'B'`, its charCode is `66`, subtracting it from the charCode of `'A'` makes it the index `1`, etc.

<p>Also, see the <a href="https://rivea0.github.io/blog/leetcode-meditations-group-anagrams" target="_blank" rel="noopener noreferrer">Group Anagrams problem</a>, which uses a similar technique.<br></Note></p>
<p>What we start with is an array to represent the frequency of characters that occur in the substrings we&#39;ll look at. We initialize <code>count</code> with length <code>26</code> for each letter, each one initially having the value of <code>0</code>.</p>
<p>Then, we&#39;ll use <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-3-sliding-window" target="_blank" rel="noopener noreferrer">the sliding window technique</a> to check for substrings, so we&#39;ll initialize <code>left</code> and <code>right</code> pointers starting from the very first character&#39;s index: <code>0</code>.<br>We&#39;ll also need to keep <code>maxLength</code> to keep track of the substring with the maximum length.</p>
<p>Then, as we look through each substring, we&#39;ll increase the character&#39;s count in the <code>count</code> array. </p>
<p>One important—and, maybe the most confusing—part is here:</p>
<pre><code class="language-ts">while ((right - left + 1) - Math.max(...count) &gt; k) {
  count[s[left].charCodeAt(0) - &#39;A&#39;.charCodeAt(0)]--;
  left++;
}
</code></pre>
<p>Now, <code>right - left + 1</code> is the length of our current window.<br><code>Math.max(...count)</code> will give us the maximum number of times a character occurs within our current window, that is, the number of the <em>longest repeating letters</em>.<br>Subtracting it from the length of our window will give us the number of potential replacements we can make.<br>Remember that we can replace a character at most <code>k</code> times within a window, so, if the number of our potential replacements surpasses <code>k</code>, then we need to <em>slide</em> our window; that is, update the <code>left</code> pointer, also decreasing the value at the <code>left</code>&#39;s index in the <code>count</code> array.</p>
<p>We&#39;ll also keep track of our <code>maxLength</code> as we increase our window&#39;s length, and return it at the end as the result.</p>
<h4>Time and space complexity</h4>
<p>The time complexity for this solution is $O(n)$ as we loop through each character in <code>s</code>. The amount of space we additionally require for the <code>count</code> array is constant, of length 26, so the space complexity will be $O(1)$.</p>
<hr>
<p>This solution is adapted from <a href="https://www.youtube.com/watch?v=gqXU1UyA8pk&t=925s" target="_blank" rel="noopener noreferrer">NeetCode</a>, where he also mentions a slight optimization.</p>
<p>I think this was a challenging problem, so it&#39;s time for another deep breath. Next up is the last problem <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener noreferrer">Minimum Window Substring</a> in the Sliding Window chapter, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-longest-repeating-character-replacement</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-longest-repeating-character-replacement</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 15 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Longest Substring without Repeating Characters]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-11/15-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener noreferrer">this problem</a>:</p>
<blockquote>
<p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <strong>substring</strong> without repeating characters.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">lengthOfLongestSubstring(&#39;abcabcbb&#39;);
// -&gt; 3
// The answer is &quot;abc&quot;, with the length of 3.


lengthOfLongestSubstring(&#39;bbbbb&#39;);
// -&gt; 1
// The answer is &quot;b&quot;, with the length of 1.


lengthOfLongestSubstring(&#39;pwwkew&#39;);
// -&gt; 3
// The answer is &quot;wke&quot;, with the length of 3.
// Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>
<hr>
<p>Since this is a problem that is under the <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-3-sliding-window" target="_blank" rel="noopener noreferrer">Sliding Window</a> topic, my first intuition was to initialize <code>left</code> and <code>right</code> pointers, and keep growing the window until we see a duplicate character. If we see one, we can increase <code>left</code> one step, and let <code>right</code> be where <code>left</code> is. And, we need to clear the set that keeps our unique letters as we&#39;re starting our search for a new substring anew. Otherwise, we&#39;ll just add the letters we see to our set, and keep increasing the right pointer; that is, increasing our window size from the right end. We&#39;ll also update our maximum length:</p>
<pre><code class="language-ts">function lengthOfLongestSubstring(s: string): number {
  let letters = new Set();
  let left = 0;
  let right = 0;
  let maxLength = 0;

  while (right &lt; s.length) {
    if (letters.has(s[right])) {
      left++;
      right = left;
      letters.clear();
    } else {
      letters.add(s[right]);
      right++;
    }

    maxLength = Math.max(maxLength, right - left);
  }

  return maxLength;
};
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity for this solution is $O(n)$ as we iterate through the elements in the string once. The space complexity is also $O(n)$ as <code>letters</code> can contain all the letters in the string in a worst-case scenario where all the letters are unique, making its growth proportional to our input string.</p>
<p>Now, let&#39;s take a deep breath because it turns out, there is a slightly better approach.</p>
<hr>
<pre><code class="language-ts">function lengthOfLongestSubstring(s: string): number {
  let letters = new Set();
  let left = 0;
  let right = 0;
  let maxLength = 0;

  while (right &lt; s.length) {
    while (letters.has(s[right])) {
      letters.delete(s[left]);
      left++;
    } 

    letters.add(s[right]);
    maxLength = Math.max(maxLength, (right - left) + 1);
    right++;
  }

  return maxLength;
};
</code></pre>
<p>This solution is adapted from <a href="https://youtu.be/wiGpQwVHdE0" target="_blank" rel="noopener noreferrer">NeetCode</a>. This time we don&#39;t reset the entire substring when we find a duplicate as we did in the first version, and we remove only the repeating characters from the set instead of completely emptying it.</p>
<h4>Time and space complexity</h4>
<p>The time complexity of this version is $O(n)$ again as we iterate through all the characters. The space complexity is also $O(n)$; however, this version is more efficient than the first one, mainly given the reason that we don&#39;t wipe out the whole set when a duplicate is found.</p>
<hr>
<p>Next up is <a href="https://leetcode.com/problems/longest-repeating-character-replacement" target="_blank" rel="noopener noreferrer">Longest Repeating Character Replacement</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-longest-substring-without-repeating-characters</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-longest-substring-without-repeating-characters</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 11 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Best Time to Buy and Sell Stock]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-10/14-lm.png" alt="Cover image"></p>
<p><em>Make sure to read <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-3-sliding-window" target="_blank" rel="noopener noreferrer">the Sliding Window post</a> first!</em></p>
<hr>
<p>The description for <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener noreferrer">this problem</a> states:</p>
<blockquote>
<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">maxProfit([7, 1, 5, 3, 6, 4]);
// -&gt; 5
// Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
// Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.


maxProfit([7, 6, 4, 3, 1]);
// -&gt; 0
// In this case, no transactions are done and the max profit = 0.
</code></pre>
<hr>
<p>This problem is a perfect example where we can use the sliding window technique. But one important thing to notice is that we need to sell the stock at a <em>future</em> date; that is, <em>the right end of our window should be at least one step ahead of the left end</em>.</p>
<p>We can initialize <code>left</code> and <code>right</code> pointers (<em>remember <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers" target="_blank" rel="noopener noreferrer">the Two Pointers technique</a>?</em>); <code>left</code> at the first index, <code>right</code> at <code>left + 1</code>. If the price on the left is less than the one on the right, that means we can make a profit, so we can get their difference and update the maximum difference that we keep track of. Otherwise, we&#39;ll just update <code>left</code> to be where <code>right</code> is, because <code>right</code> will be the minimum value we have seen so far. Either way, we&#39;ll update the <code>right</code> pointer until it points to the last element.</p>
<p>It looks like this in TypeScript:</p>
<pre><code class="language-ts">function maxProfit(prices: number[]): number {
  let left = 0;
  let right = left + 1;
  let maxDiff = 0;

  while (right &lt; prices.length) {
    if (prices[left] &lt; prices[right]) {
      let diff = prices[right] - prices[left];
      maxDiff = Math.max(maxDiff, diff);
    } else {
      left = right;
    }

    right++;
  }

  return maxDiff;
};
</code></pre>
<p>This is an example of the <strong>dynamically sized sliding window</strong> technique, where we adjust our window size dynamically based on conditions, instead of keeping it fixed to some value. It&#39;s specifically a version of <strong>fast/catch-up</strong> because while the <code>right</code> pointer is always increasing, the <code>left</code> pointer <em>jumps</em> to catch up with the <code>right</code> pointer in the <code>else</code> block.</p>
<h4>Time and space complexity</h4>
<p>The time complexity for this solution is $O(n)$ because we iterate once through the items of the array. And, the space complexity is $O(1)$ as we don&#39;t use any additional space where the size depends on the size of the input array.</p>
<hr>
<p>That&#39;s it for this problem, we can take a deep breath now. Next up is <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener noreferrer">Longest Substring Without Repeating Characters</a> — until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-best-time-to-buy-and-sell-stock</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-best-time-to-buy-and-sell-stock</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 10 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 3: Sliding Window]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-09/13-lm-ch3.png" alt="Cover image"></p>
<p>Now that we&#39;re familiar with the <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers" target="_blank" rel="noopener noreferrer">Two Pointers technique</a>, we can add another one to our toolbox: the Sliding Window.<br>It&#39;s usually used for operations done on the subsets of a given data. It also comes in two flavors: <strong>fixed window size</strong> and <strong>dynamic window size</strong>.</p>
<h4>Fixed window size</h4>
<p>If we have a size constraint in a given problem, say, we need to check a $k$-sized subarray, sliding window is an appropriate technique to use.</p>
<p>For example, getting the maximum subarray (of size $k$) sum of a given array can be done like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-09/sliding-window-fixed.gif" alt="Sliding window fixed"></p>
<p>Note that the window size is $k$, and it doesn&#39;t change throughout the operation, hence, <em>fixed size</em>.</p>
<p>A very cool thing to notice here is that with each <em>slide</em>, what happens to our sum is that we <em>add</em> the right element, and <em>decrease</em> the left element.</p>
<p>Let&#39;s look at an example for getting the maximum sum of subarray with given size <code>k</code>:</p>
<pre><code class="language-typescript">function maxSubarray(numbers: number[], k: number) {
  if (numbers.length &lt; k) {
    return 0;
  }

  let currentSum = 0;

  // Initial sum of the first window 
  for (let i = 0; i &lt; k; i++) {
    currentSum += numbers[i];
  }

  let maxSum = currentSum;

  let left = 0;
  let right = k;

  while (right &lt; numbers.length) {
    currentSum = currentSum - numbers[left++] + numbers[right++];
    maxSum = Math.max(maxSum, currentSum);
  }

  return maxSum;
}
</code></pre>
<Note>
Updating the pointers can be done outside the brackets as well, like this:

<pre><code class="language-ts">while (right &lt; numbers.length) {
  currentSum = currentSum - numbers[left] + numbers[right];
  maxSum = Math.max(maxSum, currentSum);
  left++;
  right++;
}
</code></pre>
<p>Since the <a href="https://www.programiz.com/article/increment-decrement-operator-difference-prefix-postfix" target="_blank" rel="noopener noreferrer">postfix operator</a> returns the value first, they can be used inside the brackets to be slightly more concise.<br></Note></p>
<p>Here, we first get the initial sum of our window using the <code>for</code> loop, and set it as the maximum sum.</p>
<p>Then we initialize two pointers: <code>left</code> that points to the left end of the window, and <code>right</code> that points to the right end of the window. As we loop, we update our <code>currentSum</code>, decreasing the <code>left</code> value, and adding the <code>right</code> value. When our current sum is more than the maximum sum, <code>maxSum</code> variable is updated as well.</p>
<h4>Dynamic window size</h4>
<p>As opposed to the fixed window size version, the size of the window changes dynamically this time.</p>
<p>For example, let&#39;s take a brief look at the problem <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener noreferrer">Best Time to Buy and Sell Stock</a> that we&#39;ll see in detail later on.<br>We need to choose a day to buy a stock, and sell it in the <em>future</em>. The numbers in the array are prices, and we need to buy the stock at as low a price as we can, and sell it as high as we can.</p>
<p>We can initialize <code>left</code> and <code>right</code> pointers again, but this time, we&#39;ll update them depending on a condition. When the left item is less than the one on the right, that means it&#39;s good, we can buy and sell at those prices, so we get their difference and update our <code>maxDiff</code> variable that holds the maximum difference between the two.<br>If, however, the left one is greater than the right one, we update our <code>left</code> pointer to be where the <code>right</code> is at.<br>In both cases, we&#39;ll continue updating <code>right</code> until we reach the end of the array.</p>
<p>With the blue arrow indicating the left pointer, and the red the right one, the process looks like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-09/sliding-window-dynamic.gif" alt="Sliding window dynamic"></p>
<p>The solution looks like this:</p>
<pre><code class="language-ts">function maxProfit(prices: number[]): number {
  let left = 0;
  let right = left + 1;
  let maxDiff = 0;

  while (right &lt; prices.length) {
    if (prices[left] &lt; prices[right]) {
      let diff = prices[right] - prices[left];
      maxDiff = Math.max(maxDiff, diff);
    } else {
      left = right;
    }

    right++;
  }

  return maxDiff;
};
</code></pre>
<Note>
This one is also called **fast/catch-up** version of dynamic sliding window, because the `left` pointer jumps to catch up with the `right` pointer in the `else` block.
</Note>

<h5>Time and space complexity</h5>
<p>Both examples have the same time and space complexity: The time complexity is $O(n)$ because in the worst case we iterate through all the elements in the array. The space complexity is $O(1)$ as we don&#39;t need additional space.</p>
<hr>
<p>Even though it might be slightly disorienting, sliding window technique is not too hard to fall from our grasp, so we can take a deep breath. The first problem of this chapter is <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener noreferrer">Best Time to Buy and Sell Stock</a> that we already mentioned, but we&#39;ll see in detail in the next post. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-3-sliding-window</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-3-sliding-window</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 09 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Container with Most Water]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-05/12-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="noopener noreferrer">this problem</a> states:</p>
<blockquote>
<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>
<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>
<p>Return <em>the maximum amount of water a container can store</em>.</p>
<p><strong>Notice</strong> that you may not slant the container.</p>
</blockquote>
<p>For example:</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="Example 1"></p>
<pre><code class="language-ts">let height = [1, 8, 6, 2, 5, 4, 8, 3, 7];

maxArea(height);
// -&gt; 49
// The above vertical lines are represented by array [1, 8, 6, 2, 5, 4, 8, 3, 7]. In this case, the max area of water (blue section) the container can contain is 49.
</code></pre>
<hr>
<p>What we are looking for is the largest interval where the two heights have the smallest difference.</p>
<p>To put it another way, we want the <em>width</em> and the <em>height</em> to be the largest possible values.</p>
<p>The good thing is that we can do it with the <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers" target="_blank" rel="noopener noreferrer">Two Pointers technique</a>.</p>
<p>We can keep <code>left</code> and <code>right</code> pointers that point to the two ends of the array. As we calculate the current area, we can update the maximum area. And, we need to update our pointers according to which height is less: if the left one is less than the right one, we&#39;ll increment <code>left</code>, otherwise, we&#39;ll continue decrementing <code>right</code>:</p>
<pre><code class="language-ts">function maxArea(height: number[]): number {
  let left = 0;
  let right = height.length - 1;
  let maximumArea = 0;

  while (left &lt; right) {
    let containerWidth = right - left;
    let containerHeight = Math.min(height[right], height[left]);
    let currentArea = containerWidth * containerHeight;

    if (currentArea &gt; maximumArea) {
      maximumArea = currentArea;
    }

    height[left] &lt; height[right] ? left++ : right--;
  }

  return maximumArea;
}
</code></pre>
<Note>
We can use `Math.max()` to calculate `maximumArea` as well.
</Note>

<p>The Python version is also similar:</p>
<pre><code class="language-python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        left = 0
        right = len(height) - 1
        maximum_area = 0

        while left &lt; right:
            container_width = right - left
            container_height = min(height[right], height[left])
            current_area = container_width * container_height

            if current_area &gt; maximum_area:
                maximum_area = current_area

            if height[left] &lt; height[right]:
                left += 1 
            else:
                right -= 1
        
        return maximum_area
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity for this solution is $O(n)$ as we iterate through all the items in the array. The space complexity is just $O(1)$ because we don&#39;t need additional storage.</p>
<hr>
<p>This was the last problem in this chapter. Next up, we&#39;ll look at the <a href="https://leetcodethehardway.com/tutorials/basic-topics/sliding-window" target="_blank" rel="noopener noreferrer">Sliding Window</a> technique. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-container-with-most-water</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-container-with-most-water</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 05 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: 3Sum]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-04/11-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/3sum" target="_blank" rel="noopener noreferrer">this one</a>:</p>
<blockquote>
<p>Given an integer array <code>nums</code>, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">threeSum([-1, 0, 1, 2, -1, -4]);
// -&gt; [ [-1, -1, 2], [-1, 0, 1] ]

threeSum([0, 1, 1]);
// []

threeSum([0, 0, 0]);
// [ [0, 0, 0] ]
</code></pre>
<hr>
<p>First of all, let&#39;s admit, this problem is a bit challenging. The first thing that comes to mind is that we can brute force our way to find all three. But in order to do that, we need to create three nested loops, which is not a good idea.<br>Still, we can try it, but beware; it is <mark>terrifying</mark>:</p>
<pre><code class="language-ts">function threeSum(nums: number[]): number[][] {
  let s: Set&lt;string&gt; = new Set();
  for (let i = 0; i &lt; nums.length; i++) {
    for (let j = i + 1; j &lt; nums.length; j++) {
      for (let k = j + 1; k &lt; nums.length; k++) {
        if (nums[i] + nums[j] + nums[k] === 0) {
          let triplets = JSON.stringify([nums[i], nums[j], nums[k]].sort((a, b) =&gt; a - b));
          if (!s.has(triplets)) { 
            s.add(triplets) 
          }
        }
      }
    }
  }

  return [...s].map(item =&gt; JSON.parse(item));
};
</code></pre>
<Note>
Because [arrays are objects in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), even though two arrays might look the same, they will be different objects, so our set `s` won't hold unique values, that's why I used `JSON.stringify()` to use their stringified values instead. 

<p>For example:</p>
<pre><code class="language-js">let s = new Set();
let arr1 = [1, 2, 3];
let arr2 = [1, 2, 3];

s.add(arr1);

if (!s.has(arr2)) {
  s.add(arr2);
}

console.log(s); 
// -&gt; Set(2) { [ 1, 2, 3 ], [ 1, 2, 3 ] }

// But what we want is Set(1) { [ 1, 2, 3 ] }.
</code></pre>
</Note>

<p>It passes the most of the tests, but as expected, it results in a <strong>Time Limit Exceeded</strong> error in one of them. And, it has a $O(n^3)$ time complexity.</p>
<p>So, let&#39;s take a deep breath and look at another approach.</p>
<hr>
<p>We can start with the sorted version of <code>nums</code>. Then, starting with the first number as the first value for the three numbers that add up to <code>0</code>, we can use the <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers" target="_blank" rel="noopener noreferrer">Two Pointers technique</a> to find the rest of the two values. </p>
<pre><code class="language-ts">function threeSum(nums: number[]): number[][] {
  let result: number[][] = [];
  nums = nums.sort((a, b) =&gt; a - b);

  for (let i = 0; i &lt; nums.length; i++) {
    // Ignore the number if it&#39;s not the first value and a duplicate
    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) {
      continue;
    }

    let left = i + 1;
    let right = nums.length - 1;

    while (left &lt; right) {
      let sum = nums[i] + nums[left] + nums[right];

      if (sum &gt; 0) {
        right--;
      } else if (sum &lt; 0) {
        left++;
      } else {
        result.push([nums[i], nums[left], nums[right]]);
        left++;
        while (nums[left] === nums[left - 1] &amp;&amp; left &lt; right) {
          left++;
        }
      }
    }
  }

  return result;
};
</code></pre>
<p>The outer <code>for</code> loop picks a value for the first number to make the sum. Then, with <code>left</code> and <code>right</code> pointers, we check if the sum equals our target value of <code>0</code>, if it&#39;s greater than <code>0</code>, we decrement <code>right</code> to find a smaller value for that position; and if the sum is less than <code>0</code>, we increment <code>left</code> to find a greater value. Otherwise, if we find a triplet that adds up to <code>0</code>, we add it to our <code>result</code> array, and continue incrementing <code>left</code>. Note that we need another <code>while</code> loop at this point to ignore a duplicate.</p>
<p>This solution comes from <a href="https://neetcode.io" target="_blank" rel="noopener noreferrer">NeetCode</a>, who does a great explanation of it in <a href="https://www.youtube.com/watch?v=jzZsG8n2R9A" target="_blank" rel="noopener noreferrer">this video</a>. </p>
<h4>Time and space complexity</h4>
<p>The time complexity for this solution is $O(n^2)$ because as we iterate through each item, we have an inner loop (<code>while (left &lt; right)</code>) that iterates through $n - 1$ items in the worst case.<br>Note that we have a sorting operation that takes $O(n \ log \ n)$ time, but in this case, $n^2$ will dominate.</p>
<p>The space complexity is $O(1)$ as we don&#39;t need additional space.</p>
<hr>
<p>Next up is the problem <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener noreferrer">Container with Most Water</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-3sum</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-3sum</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 04 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Valid Palindrome]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-03-02/10-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/valid-palindrome" target="_blank" rel="noopener noreferrer">this problem</a> is:</p>
<blockquote>
<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>
<p>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">isPalindrome(&#39;A man, a plan, a canal: Panama&#39;);
// -&gt; true
// Because &quot;amanaplanacanalpanama&quot; is a palindrome.

isPalindrome(&#39; &#39;);
// -&gt; true
// Since an empty string reads the same forward and backward, it is a palindrome.
</code></pre>
<hr>
<p>As we&#39;ve seen in the introduction to the <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers" target="_blank" rel="noopener noreferrer">Two Pointers</a> technique, checking for palindromes can be done easily. But here, we need to check only the <em>alphanumeric</em> and <em>lowercase</em> characters.</p>
<p>So, we can build a string getting those characters first, then use our two pointers to see if it&#39;s a palindrome or not:</p>
<pre><code class="language-ts">function isPalindrome(s: string): boolean {
  let str = &#39;&#39;;
  for (const letter of s.toLowerCase()) {
    if (letter &gt;= &#39;a&#39; &amp;&amp; letter &lt;= &#39;z&#39; || letter &gt;= &#39;0&#39; &amp;&amp; letter &lt;= &#39;9&#39;) {
      str += letter;
    }
  }

  let left = 0;
  let right = str.length - 1;

  while (left &lt;= right) {
    if (str[left++] !== str[right--]) {
      return false;
    }
  }

  return true;
};
</code></pre>
<p>First, we iterate through each letter in the lowercase version of <code>s</code>, and concatenate it if it is alphanumeric, that is, if it is in the boundaries between <code>&#39;a&#39;</code> and <code>&#39;z&#39;</code>, or <code>&#39;0&#39;</code> and <code>&#39;9&#39;</code>.</p>
<p>Then we initialize two pointers: <code>left</code> to start at the beginning and <code>right</code> to start at the end of our new string. We check if two characters are different from each other, in that case, we immediately return <code>false</code>, otherwise when the iteration is over, we return <code>true</code>.</p>
<p>Python version of this code might look like this:</p>
<pre><code class="language-python">class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        new_s = &#39;&#39;.join([i for i in s.lower() if i.isalnum()])

        left = 0
        right = len(new_s) - 1

        while left &lt;= right:
            if (new_s[left] != new_s[right]):
                return False
            left += 1
            right -= 1

        return True
</code></pre>
<p>This time we get the alphanumeric characters with a handy method named <a href="https://docs.python.org/3/library/stdtypes.html#str.isalnum" target="_blank" rel="noopener noreferrer"><code>str.isalnum()</code></a> and using <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" target="_blank" rel="noopener noreferrer">list comprehensions</a>.</p>
<h4>Time and space complexity</h4>
<p>The time complexity for this version is $O(n)$, because we iterate through the array once for each loop. The space complexity is $O(n)$ because in the worst case where all characters are alphanumeric, we need as much space as <code>s</code> for our newly created string.</p>
<hr>
<p>There is another solution where we don&#39;t need $O(n)$ space. We can still use the two pointers technique, and we can do it without creating additional space for building a result string.</p>
<pre><code class="language-ts">function isPalindrome(s: string): boolean {
  let left = 0;
  let right = s.length - 1;

  while (left &lt;= right) {
    while (left &lt; right &amp;&amp; !isAlphaNum(s[left])) { 
      left++; 
    }
    while (right &gt; left &amp;&amp; !isAlphaNum(s[right])) { 
      right--; 
    }
     
    if (s[left++].toLowerCase() !== s[right--].toLowerCase()) {
      return false;
    }
  }

  return true;
};


function isAlphaNum(c: string) {
    return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);
}
</code></pre>
<p>Here we refactored checking if a character is alphanumeric—more properly, also checking for the uppercase characters. We increment the <code>left</code> pointer until it&#39;s alphanumeric, and likewise, we decrement the <code>right</code> pointer until it&#39;s alphanumeric too. Then, we just do the same as the first version, we check if two characters from both ends are the same, if not, return <code>false</code> immediately. </p>
<p>Here is the Python version:</p>
<pre><code class="language-python">class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        left = 0
        right = len(s) - 1

        while left &lt; right:
            while left &lt; right and not s[left].isalnum():
                left += 1
            while right &gt; left and not s[right].isalnum():
                right -= 1
            if s[left].lower() != s[right].lower():
                return False

            left += 1
            right -= 1

        return True
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity of this version is still $O(n)$ as we iterate through all the characters in the string. However, we don&#39;t need to keep an extra string, so the space complexity is just $O(1)$.</p>
<hr>
<p>You can see <a href="https://youtu.be/jJXJ16kPFWg?t=340&si=LWYKjwIeDm6-jwOb" target="_blank" rel="noopener noreferrer">NeetCode&#39;s video</a> for more explanation on this second solution with $O(1)$ space complexity.</p>
<p>Next problem is called <a href="https://leetcode.com/problems/3sum" target="_blank" rel="noopener noreferrer">3Sum</a>, until then, don&#39;t forget to breathe, and happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-valid-palindrome</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-valid-palindrome</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 02 Mar 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 2: Two Pointers]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-29/09-lm-ch2.png" alt="Cover image"></p>
<p>One of the techniques of iterating through an array is the <em>two pointers technique</em>, and it is as simple as it sounds: we just keep two pointers, one starting from the left, and the other from the right, gradually getting closer to each other.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-29/two-pointers.gif" alt="Two pointers"></p>
<h3>Palindrome example</h3>
<p>A very basic example can be the one where we check if a string is a palindrome or not. A palindrome is a string that reads the same forwards and backwards.</p>
<p>In an imaginary world where all the inputs always consist of lowercase English letters, we can do it like this:</p>
<pre><code class="language-ts">// s consists of lowercase English letters
function isPalindrome(s: string) {
  let left = 0;
  let right = s.length - 1;

  while (left &lt;= right) {
    if (s[left++] !== s[right--]) {
      return false;
    }
  }

  return true;
}
</code></pre>
<p>We initialize two pointers: <code>left</code> and <code>right</code>. <code>left</code> points to the start of the array, while the <code>right</code> points to the last element. As we loop while <code>left</code> is less than <code>right</code>, we check if they are equal. If not, we return <code>false</code> immediately. Otherwise, our <code>left</code> pointer is increased; that is, it&#39;s moved to the <em>right</em> one step, and our <code>right</code> pointer is decreased, meaning that it&#39;s moved to the <em>left</em> one step.<br>When they eventually overlap, the loop terminates, and we return <code>true</code>.</p>
<p>Let&#39;s say our string is <code>&#39;racecar&#39;</code>, which is a palindrome.<br>It will go like this:</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-29/palindrome.gif" alt="Palindrome example"></p>
<h3>Squares of a sorted array example</h3>
<p>Another example where we can use the two pointers technique is the problem <a href="https://leetcode.com/problems/squares-of-a-sorted-array" target="_blank" rel="noopener noreferrer">Squares of a Sorted Array</a>.</p>
<p>The description says:</p>
<blockquote>
<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>an array of <strong>the squares of each number</strong> sorted in non-decreasing order</em>.</p>
</blockquote>
<p>For example, if the input is <code>[-4, -1, 0, 3, 10]</code>, the output should be <code>[0, 1, 9, 16, 100]</code>. </p>
<p>Now obviously, we can just square each one, and then sort the array with a built-in sort method, and be done with it. But a sorting operation is never better than $O(n \ log \ n)$ runtime, so we can do it using two pointers in just $O(n)$ time:</p>
<pre><code class="language-ts">function sortedSquares(nums: number[]): number[] {
  let left = 0;
  let right = nums.length - 1;
  let result = [];

  while (left &lt;= right) {
    if (Math.abs(nums[left]) &gt; Math.abs(nums[right])) {
      result.push(nums[left++] ** 2);
    } else {
      result.push(nums[right--] ** 2);
    }
  }

  return result.reverse();
};
</code></pre>
<p>We compare the absolute value of the items that <code>left</code> and <code>right</code> are pointing to, and push the square of the greater one to our <code>result</code> array. And we return the reversed version of it. </p>
<Note>
The reason we return the reversed result is that the array is initially already sorted, and we get the largest absolute value first. The reason that works is related to how _two pointers_ work: as we start from both ends, we initially start with the smallest and largest values in the array.
</Note>

<p>Because we only make one pass through the array while comparing, and then later reversing, it ends up being $O(n)$, a better runtime than $O(n \ log \ n)$.</p>
<p>The first problem we&#39;ll see in this chapter will be <a href="https://leetcode.com/problems/valid-palindrome" target="_blank" rel="noopener noreferrer">Valid Palindrome</a>, which requires a more careful approach than the simplified version shown here.<br>Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-2-two-pointers</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 29 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Longest Consecutive Sequence]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-27/08-lm.png" alt="Cover image"></p>
<p>The description for <a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener noreferrer">Longest Consecutive Sequence</a> states:</p>
<blockquote>
<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>
<p>You must write an algorithm that runs in <code>O(n)</code> time.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">longestConsecutive([100, 4, 200, 1, 3, 2]);
// -&gt; 4
// The longest consecutive elements sequence is `[1, 2, 3, 4]`, the length is 4.

longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]);
// -&gt; 9
</code></pre>
<hr>
<p>The first idea is to get the non-duplicate elements, sort them, and then count how many of them follows a consecutive series. However, it won&#39;t be $O(n)$ time as the description says: any sorting can&#39;t be better than $O(n \ log \ n)$. But let&#39;s see how we can go about it nonetheless.</p>
<p>Getting the non-duplicate ones is easy: we can use a <code>Set</code>.<br>Sorting them is no problem either, but how can we count the consecutive ones?<br>Looping through each element, we can&#39;t just check if the current element + 1 is in the set and update the count, because that doesn&#39;t mean that there is a consecutive order.</p>
<p>So instead, we can keep track of <em>multiple counts</em>, rather than holding just one count variable.<br>In order to do that, we need to keep multiple starting points for each sequence that potentially exists. </p>
<p>The tricky part is when the sequences change. For example, in a sorted array like <code>[1, 2, 3, 4, 100, 150]</code>, it is obvious that the first sequence is of length $4$, but when it comes to <code>100</code>, we need to <em>reset our count</em> to start a new sequence.</p>
<p>In TypeScript, it might look like this:</p>
<pre><code class="language-ts">function longestConsecutive(nums: number[]): number {
  if (!nums.length) { 
    return 0; 
  }

  let counts: number[] = [];
  let count = 0;
  let numsSorted = [...new Set(nums)].sort((a, b) =&gt; a - b);

  for (let i = 0; i &lt; numsSorted.length; i++) {
    counts.push(++count);
    if (numsSorted[i + 1] !== numsSorted[i] + 1) {
      count = 0;
    }
  }

  return Math.max(...counts);
};
</code></pre>
<p>So, as we loop through each element, we keep count, and add it to our <code>counts</code> array, and only reset it when the next element is not the next one in sequence.</p>
<p>This solution passes the tests, but note that when we get to the last element, <code>numsSorted[i + 1]</code> is just <code>undefined</code>, so checking for inequality is meaningless. </p>
<h4>Time and space complexity</h4>
<p>Since we are sorting <code>nums</code>, time complexity can&#39;t be better than $O(n \ log \ n)$. The space complexity will be $O(n)$ because of the additional storage for <code>numsSorted</code> and <code>counts</code> arrays, which will grow linearly as the length <code>nums</code> increases.</p>
<p>In fact, there is a much better way of doing this, so let&#39;s take a deep breath, and see how we can improve.</p>
<hr>
<p>When you notice that we use a <code>Set</code> anyway, why not use it for what it&#39;s already good at, checking if an element is in it, instead of just pruning the duplicate elements?<br>The good part is that we don&#39;t even need to sort them.</p>
<pre><code class="language-ts">function longestConsecutive(nums: number[]): number {
  if (!nums.length) { 
    return 0;
  }

  let count: number;
  let nums_ = new Set(nums);
  let longestSeq = 0;
    
  for (let n of nums) {
    if (!nums_.has(n - 1)) {
      count = 0;
      while (nums_.has(n + count)) {
        count++;
      }

      if (count &gt; longestSeq) {
        longestSeq = count;
      }
    }
  }

  return longestSeq;
};
</code></pre>
<p>This time we check if an element has a previous one that comes <em>before</em> it; if not, we reset <code>count</code> and continue incrementing it while there is a consecutive sequence from that element onward. We update the longest sequence accordingly if the current count is greater than the previous longest sequence.</p>
<p>Here is the Python version:</p>
<pre><code class="language-python">class Solution:
    def longestConsecutive(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0

        nums_ = set(nums)
        longest_seq = 0

        for n in nums:
            if n - 1 not in nums_:
                count = 0
                while n + count in nums_:
                    count += 1

                if count &gt; longest_seq:
                    longest_seq = count

        return longest_seq
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity is just $O(n)$ this time, as we only iterate through the <code>nums</code> array.<br>The space complexity is again $O(n)$ though, because we need to allocate space for <code>nums_</code>.</p>
<hr>
<p>This was the last problem in Arrays &amp; Hashing section in <a href="https://neetcode.io/practice" target="_blank" rel="noopener noreferrer">Blind 75</a>. Next up, we&#39;ll look at the <a href="https://leetcodethehardway.com/tutorials/basic-topics/two-pointers" target="_blank" rel="noopener noreferrer">Two Pointers</a> technique. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-longest-consecutive-sequence</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-longest-consecutive-sequence</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 27 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Product of Array Except Self]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-25/07-lm.png" alt="Cover image"></p>
<p>The description of <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener noreferrer">this problem</a> states that:</p>
<blockquote>
<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>
<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>
<p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">productExceptSelf([1, 2, 3, 4]);
// -&gt; [24, 12, 8, 6]

productExceptSelf([-1, 1, 0, -3, 3]);
// -&gt; [0, 0, 9, 0, 0]
</code></pre>
<hr>
<p>If we want to ignore the runtime having to be $O(n)$, a <em>very</em> naive idea is to get the product of the <em>filtered</em> version of the array... <em>for each element</em> (where the indices of the array do not include the current item&#39;s index).</p>
<p>Yes, I know that sounds terrible, but well, it works for most of the test cases until it hits one with a <strong>Time Limit Exceeded</strong> error because it&#39;s far from optimal:</p>
<pre><code class="language-ts">function productExceptSelf(nums: number[]): number[] {
  let result = [];
  for (let i = 0; i &lt; nums.length; i++) {
    result[i] = nums
      .filter((_, idx) =&gt; idx !== i)
      .reduce((acc, item) =&gt; acc * item, 1);
  }

  return result;
};
</code></pre>
<h4>Time and space complexity</h4>
<p>This is <strong>not</strong> a solution to the problem, but the time complexity will be $O(n^3)$ as we do filter and reduce for each element. As we create another array using <code>filter()</code> for each iteration, the space complexity is, I think, $O(n^2)$.</p>
<p>So, after a deep breath, let&#39;s see <a href="https://neetcode.io/" target="_blank" rel="noopener noreferrer">NeetCode</a>&#39;s solution.</p>
<hr>
<p>Here is a very <a href="https://youtu.be/bNvIQI2wAjk?si=XTH7V8HePypZOcY_&t=129" target="_blank" rel="noopener noreferrer">clever solution</a>. We&#39;ll make use of <em>prefix</em> and <em>postfix</em> variables. They have to be <code>1</code> as default, as it is the identity for multiplication. <em>Prefix</em> will start from the first element of the array and calculate the product so far up to the last element, and it&#39;ll be updated with the new value as we go.</p>
<p>So, for example, if the <code>nums</code> array is <code>[2, 3, 5]</code>, we&#39;ll go up to <code>5</code>:</p>
<pre><code>[2, 3, 5] // nums


1 -&gt; initial value of prefix


2 * 1 = 2 -&gt; nums[0] * prefix = new prefix

3 * 2 = 6 -&gt; nums[1] * prefix = new prefix


[1, 2, 6] // result
</code></pre>
<p>It might be easier to see with code:</p>
<pre><code class="language-ts">let result: number[] = [];
let prefix = 1; // Initial value

for (let i = 0; i &lt; nums.length; i++) {
  result[i] = prefix;
  prefix *= nums[i];
}
</code></pre>
<p><em>Postfix</em> will start from the end of the array, and starting from the last item, it&#39;ll calculate the products so far as well. But we need to multiply it with the values calculated with the prefix, so that we get what we want: the total product of all elements <em>before</em> and <em>after</em> the $i$th element.</p>
<p>In the example above, our result looked like <code>[1, 2, 6]</code> so far. We&#39;re going reverse this time, starting from the last element, up to the first one:</p>
<pre><code>[2, 3, 5] // nums
[1, 2, 6] // result created so far thanks to prefix

1 -&gt; initial value for postfix


6 * 1 = 6
-&gt; result[result.length - 1] * postfix = new result[result.length - 1]

5 * 1 = 5
-&gt; nums[nums.length - 1] * postfix = new postfix



2 * 5 = 10
-&gt; result[result.length - 2] * postfix = new result[result.length - 2]

3 * 5 = 15
-&gt; nums[nums.length - 2] * postfix = new postfix



1 * 15 = 15
-&gt; result[result.length - 3] * postfix = new result[result.length - 3]


[15, 10, 6] // end result
</code></pre>
<p>Again, in code:</p>
<pre><code class="language-ts">let result: number[] = [];
let prefix = 1; // Initial value

for (let i = 0; i &lt; nums.length; i++) {
  result[i] = prefix;
  prefix *= nums[i];
}

// focus(1:6)
let postfix = 1; // Initial value

for (let i = nums.length - 1; i &gt; -1; i--) {
  result[i] *= postfix;
  postfix *= nums[i];
}
</code></pre>
<Note>
We multiply the value in `result[i]` with `postfix` this time, instead of just assigning `result[i]` the value of `postfix` (as we did with `prefix`).
</Note>

<hr>
<p>One deep breath, and here is the Python version of the whole thing:</p>
<pre><code class="language-python">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        result = [1] * (len(nums))
        prefix = 1
        postfix = 1

        for i in range(len(nums)):
            result[i] = prefix
            prefix *= nums[i]

        for i in range(len(nums) - 1, -1, -1):
            result[i] *= postfix
            postfix *= nums[i]

        return result
</code></pre>
<p>And here is the TypeScript version:</p>
<pre><code class="language-ts">function productExceptSelf(nums: number[]): number[] {
    let result = Array.from({ length: nums.length }, () =&gt; 1);
    let prefix = 1;
    let postfix = 1;

    for (let i = 0; i &lt; nums.length; i++) {
        result[i] = prefix;
        prefix *= nums[i];
    }

    for (let i = nums.length - 1; i &gt; -1; i--) {
        result[i] *= postfix;
        postfix *= nums[i];
    }

    return result;
};
</code></pre>
<hr>
<p>Once again, to understand the idea better, if our array is <code>[🌸, 🍁, 🍀, 🌼]</code> then, at the end of the first loop where we used <code>prefix</code>, <code>result</code> looks like this:</p>
<pre><code>[
    1, 
    🌸, 
    🌸 * 🍁, 
    🌸 * 🍁 * 🍀
]
</code></pre>
<p>And, after the second loop where we used <code>postfix</code>, <code>result</code> looks like this:</p>
<pre><code>[
    🍁 * 🍀 * 🌼 * (1),
    🍀 * 🌼 * (🌸),
    🌼 * (🌸 * 🍁),
    1 * (🌸 * 🍁 * 🍀)
]
</code></pre>
<Note>
The values inside the parentheses are the previous values of `result`.
</Note>

<h4>Time and space complexity</h4>
<p>This version has $O(n)$ time complexity, as each loop just iterates through the elements of <code>nums</code> once, which is linear time.</p>
<p>Since we use a fixed amount of space, the space complexity is technically $O(n)$ because we initialize <code>result</code> with the length of <code>nums</code>, but the description for this problem states that <em>the output array <strong>does not</strong> count as extra space</em>, so it is $O(1)$.</p>
<hr>
<p>Next up is <a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener noreferrer">Longest Consecutive Sequence</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-product-of-array-except-self</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-product-of-array-except-self</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 25 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Top K Frequent Elements]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-23/06-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">Top K Frequent Elements</a>:</p>
<blockquote>
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">topKFrequent([1, 1, 1, 2, 2, 3], 2);
// -&gt; Output: [1, 2]

topKFrequent([1], 1);
// -&gt; Output: [1]
</code></pre>
<p>One of the constraints indicates that <em>it is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</em></p>
<hr>
<p>The first obvious idea is to keep a frequency map. We can do it easily like:</p>
<pre><code class="language-ts">let count = new Map();

nums.forEach(n =&gt; {
  count.set(n, (count.get(n) ?? 0) + 1);
});
</code></pre>
<Note>
What we do here is a bit similar to `setdefault()` in Python; when `n` does not exist in `count`, we first set its value to `0`, otherwise just increment it.
</Note>

<p>Since we need to return the <em>k most frequent elements</em>, we need to do a bit more work. My idea is to sort the <code>count</code> map by values (the <em>frequencies</em>) in reverse order to keep the most frequent elements in front, then get only the keys (the <em>numbers</em>), and slice it until <em>k</em>:</p>
<pre><code class="language-ts">return [...count.entries()]
  .sort(([, a], [, b]) =&gt; b - a)
  .map((i) =&gt; i[0])
  .slice(0, k);
</code></pre>
<p>All in all, it looks like this:</p>
<pre><code class="language-ts">function topKFrequent(nums: number[], k: number): number[] {
  let count = new Map();

  nums.forEach(n =&gt; {
    count.set(n, (count.get(n) ?? 0) + 1);
  });

  return [...count.entries()]
    .sort(([, a], [, b]) =&gt; b - a)
    .map(i =&gt; i[0])
    .slice(0, k);
};
</code></pre>
<h4>Time and space complexity</h4>
<p>Since we have a sorting operation, the time complexity cannot be better than $O(n \ log \ n)$. The space complexity is $O(n)$ as it will grow linearly as the <code>nums</code> array grows.</p>
<hr>
<h5>Using Python</h5>
<p>After one deep breath, we can try converting the above code into Python:</p>
<pre><code class="language-python">class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        count = {}

        for n in nums:
            count[n] = count.get(n, 0) + 1

        sorted_items = sorted(count.items(), key=lambda i: i[1], reverse=True)

        return list(map(lambda x: x[0], sorted_items))[:k]
</code></pre>
<p>What we do is pretty much the same as the TypeScript version above. </p>
<p>The problem description also adds a &quot;<strong>follow up</strong>,&quot; that the algorithm&#39;s time complexity must be better than $O(n \ log \ n)$, where $n$ is the array&#39;s size. Because we&#39;re doing the sorting, it doesn&#39;t satisfy this criterion. So, after one more deep breath, let&#39;s see <a href="https://neetcode.io/" target="_blank" rel="noopener noreferrer">NeetCode</a>&#39;s solution.</p>
<hr>
<p>It turns out, there is a <a href="https://youtu.be/YPTqKIgVk-k?si=-3tyBJiMZ1e0K0W3&t=178" target="_blank" rel="noopener noreferrer">better solution</a> with $O(n)$ time complexity using the <a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener noreferrer">bucket sort algorithm</a>.</p>
<p>We can create an array of size $n$ where each index corresponds to the <em>count</em> of elements. So, the values that occur twice will be stored in the second index, if all the elements are unique, all of them will be in the index <code>1</code>, etc. </p>
<p>In that case, if all elements are the same, they will be at the very last index because the count of that element will be $n$, the length of the <code>nums</code> array.</p>
<pre><code class="language-python">class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)]

        for n in nums:
            count[n] = 1 + count.get(n, 0)
        for n, c in count.items():
            freq[c].append(n)

        res = []
        for i in range(len(freq) - 1, 0, -1):
            for n in freq[i]:
                res.append(n)
                if len(res) == k:
                    return res
</code></pre>
<p>Note that in the last loop, we go in reverse, because higher the index, higher the frequency of values.</p>
<p>In TypeScript, it might look like this:</p>
<pre><code class="language-ts">function topKFrequent(nums: number[], k: number): number[] {
  let count = new Map();
  let freq = Array.from({ length: nums.length + 1 }, () =&gt; []);

  for (const n of nums) {
    count.set(n, (count.get(n) ?? 0) + 1);
  }

  for (const [n, c] of count.entries()) {
    freq[c].push(n);
  }
    
  let res = [];
  for (let i = freq.length - 1; i &gt; 0; i--) {
    for (const n of freq[i]) {
      res.push(n);
      if (res.length === k) { 
        return res;
      }
    }
  }
};
</code></pre>
<h4>Time and space complexity</h4>
<p>The time complexity is $O(n)$ this time, because in the worst case where each element is unique, each loop will iterate over $n$ elements at most. And, the space complexity is $O(n)$ as well, because the storage we use will grow linearly as the <code>nums</code> itself grows.</p>
<hr>
<p>Next up is the problem <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener noreferrer">Product of Array Except Self</a>. Until then, don&#39;t forget to take deep breaths, and happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-top-k-frequent-elements</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-top-k-frequent-elements</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 23 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Group Anagrams]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-21/05-lm.png" alt="Cover image"></p>
<p>Let&#39;s start with the description for <a href="https://leetcode.com/problems/group-anagrams/description/" target="_blank" rel="noopener noreferrer">Group Anagrams</a>:</p>
<blockquote>
<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">groupAnagrams([&#39;eat&#39;, &#39;tea&#39;, &#39;tan&#39;, &#39;ate&#39;, &#39;nat&#39;, &#39;bat&#39;]);
// -&gt; [ [&#39;bat&#39;], [&#39;nat&#39;, &#39;tan&#39;], [&#39;ate&#39;, &#39;eat&#39;, &#39;tea&#39;] ]

groupAnagrams([&#39;&#39;]);
// -&gt; [ [&#39;&#39;] ]

groupAnagrams([&#39;a&#39;]);
// -&gt; [ [&#39;a&#39;] ]
</code></pre>
<p>And, as one of the constraints says, <em>each of the strings will consist of lowercase English letters</em>.</p>
<hr>
<p>One thing to remember from the previous <a href="https://rivea0.github.io/blog/leetcode-meditations-valid-anagram" target="_blank" rel="noopener noreferrer">Valid Anagram</a> problem is that we can easily check if two strings are anagrams of each other by comparing their <em>sorted</em> versions.</p>
<p>So, we can use a hash table to store the sorted words. In that case, all words that are anagrams of each other will be grouped together in an <em>array</em>, and share the same key:</p>
<pre><code class="language-ts">function groupAnagrams(strs: string[]): string[][] {
  let words: { [word: string]: string[] } = {};

  for (let s of strs) {
    let sortedWord = [...s].sort().join(&#39;&#39;);
    (sortedWord in words) ? words[sortedWord].push(s) : words[sortedWord] = [s];
  }

  return Object.values(words);
};
</code></pre>
<h4>Time and space complexity</h4>
<p>Since we&#39;re using the sorting operation, time complexity will be $O(n \ log \ n)$ as it is the best we can do with sorting. But we&#39;re doing the sorting operation <em>for each element in <code>strs</code></em>, so the loop itself has an $O(n)$ time complexity.<br>To not confuse ourselves, we&#39;ll use another variable, $m$, to denote the length of <code>strs</code>, that is, the number of times we&#39;ll iterate for each element. Overall, the time complexity will be $O(m \cdot n \ log \ n)$.</p>
<p>We can say that space complexity is $O(m \cdot n)$ where $m$ is the length of <code>strs</code> and $n$ is the length of the longest string, because in the worst case where all strings are anagrams of each other, the value array can contain $m$ strings, and the key&#39;s length will be $n$, so, <code>words</code> will grow proportionally.</p>
<h5>Using Python</h5>
<Note>
To reflect the ternary operation in the TypeScript version:

<pre><code class="language-ts">(sortedWord in words) ? words[sortedWord].push(s) : words[sortedWord] = [s];
</code></pre>
<p>We could write it in Python like:</p>
<pre><code class="language-python">words[sorted_word].append(s) if sorted_word in words else words[sorted_word] = [s]
</code></pre>
<p>But since it&#39;s a bit clunky, we can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" target="_blank" rel="noopener noreferrer"><code>setdefault()</code></a> where we&#39;re setting the default value of  <code>words[sorted_word]</code> to <code>[]</code>.<br></Note></p>
<p>It might look like this in Python:</p>
<pre><code class="language-python">class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        words = {}

        for s in strs:
            sorted_word = &#39;&#39;.join(sorted(s))
            words.setdefault(sorted_word, []).append(s)

        return words.values()
</code></pre>
<p>Now, after taking a deep breath, we can look at NeetCode&#39;s solution.</p>
<hr>
<p>And, voilà, <a href="https://youtu.be/vzdNOK2oB2E?si=Y4OxVBiArZYomm5t&t=118" target="_blank" rel="noopener noreferrer">a more efficient solution</a> exists:</p>
<pre><code class="language-python">from collections import defaultdict

class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        res = defaultdict(list)

        for s in strs:
            count = [0] * 26 # a ... z

            for c in s:
                count[ord(c) - ord(&#39;a&#39;)] += 1

            res[tuple(count)].append(s)

        return res.values()
</code></pre>
<p>Here, the constraint we mentioned in the beginning gives some perspective to this solution:<br>For each string, we can count the number of characters from <code>&#39;a&#39;</code> to <code>&#39;z&#39;</code>, because the strings will be just lowercase English letters. </p>
<p>We can still use a hash table, and map each of the 26 letters to an index, and increase the value at that index every time we see that letter. The keys will be these arrays of length 26, and the values will be the arrays of strings themselves.</p>
<p>For example, if we have these strings:</p>
<pre><code class="language-python">[&#39;eat&#39;, &#39;tea&#39;, &#39;tan&#39;]
</code></pre>
<p>Then, <code>res</code> will look like this:</p>
<pre><code class="language-python">{
    (1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0): [&#39;tan&#39;],
    (1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0): [&#39;eat&#39;, &#39;tea&#39;]
}
</code></pre>
<Note>
`count` is converted into a `tuple` because `list`s cannot be keys as they are mutable. You can [read more on this](https://wiki.python.org/moin/DictionaryKeys).
</Note>

<p>Also note that in the code, we use the ASCII numbers of the characters to get their index, for example, the count of <code>&#39;a&#39;</code> will be at the 0th index, so it&#39;s basic offset arithmetic.</p>
<p>For instance, the ASCII number of <code>&#39;z&#39;</code> is <code>122</code>, and <code>&#39;a&#39;</code> is <code>97</code>, when you get the difference, it will be <code>25</code>, meaning that the <code>&#39;z&#39;</code> will be at the end of the array, that is, the 25th index.</p>
<hr>
<p>After taking another deep breath, let&#39;s try converting it into TypeScript:</p>
<pre><code class="language-ts">function groupAnagrams(strs: string[]): string[][] {
  let result: { [count: string]: string[] } = {};

  for (let s of strs) {
    let count = new Array(26).fill(0);

    for (let c of s) {
      count[c.charCodeAt(0) - &#39;a&#39;.charCodeAt(0)]++;
    }

    const key = count.toString();

    !(key in result) ? result[key] = [s] : result[key].push(s);
  }

  return Object.values(result);
};
</code></pre>
<Note>
While we couldn't use lists as keys in the Python version, we'll just convert the `count` array into string with `toString()` in this TypeScript version and use it as key. 
</Note>

<h4>Time and space complexity</h4>
<p>The time complexity will be $O(m \cdot n)$ where $m$ is the total number of strings and the $n$ is the length of a string.</p>
<p>For the space complexity, the dominant item will be the <code>res</code> variable (<em>the <code>count</code> array won&#39;t matter much because it won&#39;t grow with the input size, it is constant, or $O(1)$</em>).<br>In the case where each key is unique, the space complexity will be $O(m \cdot n)$ where $m$ is the total number of strings, and $n$ is the length of the longest string.</p>
<hr>
<p>And, that&#39;s the end of Group Arrays. The next one will be <a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">Top K Frequent Elements</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-group-anagrams</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-group-anagrams</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 21 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Two Sum]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-19/04-lm.png" alt="Cover image"></p>
<p>Let&#39;s see what the description says for <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener noreferrer">this one</a>:</p>
<blockquote>
<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order. </p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">twoSum([2, 7, 11, 15], 9);
// -&gt; [0, 1]
// Because nums[0] + nums[1] == 9, we return [0, 1].

twoSum([3, 2, 4], 6);
// -&gt; [1, 2]

twoSum([3, 3], 6);
// -&gt; [0, 1]
</code></pre>
<p>And, as the constraints say, <strong>only one valid answer exists</strong>.</p>
<hr>
<p>The very first naive solution I thought of was this:</p>
<pre><code class="language-ts">function twoSum(nums: number[], target: number): number[] {
  for (let i = 0; i &lt; nums.length; i++) {
    for (let j = i + 1; j &lt; nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
};
</code></pre>
<h4>Time and space complexity</h4>
<p>This solution passes the tests alright, but, the time complexity is $O(n^2)$ because we have a nested loop. The good thing is that the space complexity is $O(1)$ as we don&#39;t use additional memory.</p>
<p>Still, the time complexity ruins our day, so there must be a better way.</p>
<hr>
<p>A better way is a &quot;one-pass solution,&quot; where NeetCode explains the concept <a href="https://youtu.be/KLlXCFG5TnA?t=111" target="_blank" rel="noopener noreferrer">around the second minute mark of the video</a>.</p>
<p>The idea is that for each item, we can check if <code>target - item</code> exists in the array that has a different index than that item. And the crux of the idea is that we can use a hash table to store the indices, and return immediately after finding the complementary item:</p>
<pre><code class="language-ts">function twoSum(nums: number[], target: number): number[] {
  let indicesOfNums: { [n: number]: number } = {};

  for (let i = 0; i &lt; nums.length; i++) {
    if (target - nums[i] in indicesOfNums) {
      return [indicesOfNums[target - nums[i]], i];
    }
    indicesOfNums[nums[i]] = i;
  }
};
</code></pre>
<p>And, indeed, it passes the tests. 🎉</p>
<h4>Time and space complexity</h4>
<p>Here, time complexity is $O(n)$ because in the worst case, we&#39;re iterating through the whole array, so, as the length of the array increases, the time complexity will increase linearly. Nevertheless, it is better than our initial solution. </p>
<p>The space complexity, however, becomes $O(n)$ because we&#39;re storing an additional data structure, and in the worst case, it is proportional to the array&#39;s length.</p>
<h5>Using Python</h5>
<p>We can translate the above code into Python:</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        indices_of_nums = {}

        for i, num in enumerate(nums):
            if target - num in indices_of_nums:
                return [indices_of_nums[target - num], i]
            
            indices_of_nums[num] = i
</code></pre>
<p>Now it&#39;s time to take a deep breath. </p>
<p>Let&#39;s take a look at NeetCode&#39;s solution.</p>
<hr>
<p>NeetCode&#39;s solution turns out to be the same as the Python version above, except that it is slightly more explicit:</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        prevMap = {} # val : index

        for i, n in enumerate(nums):
            diff = target - n
            if diff in prevMap:
                return [prevMap[diff], i]
            prevMap[n] = i
        
        return
</code></pre>
<p>And, that&#39;s it for Two Sums, we can take one more deep breath. </p>
<p>Next up is <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener noreferrer">Group Anagrams</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-two-sum</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-two-sum</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 19 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Valid Anagram]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-17/03-lm.png" alt="Cover image"></p>
<p>For <a href="https://leetcode.com/problems/valid-anagram" target="_blank" rel="noopener noreferrer">this one</a>, let&#39;s start with the description:</p>
<blockquote>
<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
</blockquote>
<p>And, both arguments will consist of lowercase English letters.</p>
<p>For example:</p>
<pre><code class="language-ts">isAnagram(&#39;anagram&#39;, &#39;nagaram&#39;);
// -&gt; true

isAnagram(&#39;rat&#39;, &#39;car&#39;);
// -&gt; false
</code></pre>
<hr>
<p>Here, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener noreferrer"><code>Map</code></a> to store the letter counts in both strings. If the same letter in the second string doesn&#39;t occur the same number of times as in the first string, we know that they are not anagrams.</p>
<p>Of course, the first thing to check is if the lengths of the strings are equal, because if they are not, then there is no way they are anagrams in the first place.</p>
<pre><code class="language-ts">function isAnagram(s: string, t: string): boolean {
  if (s.length !== t.length) {
    return false;
  }

  let isValid = true;

  let sDict = new Map();
  let tDict = new Map();

  // Initialize the objects with letters mapping to letter counts 
  for (const letter of s) {
    const letterCount = sDict.get(letter);
    !letterCount ? sDict.set(letter, 1) : sDict.set(letter, letterCount + 1);
  }

  for (const letter of t) {
    const letterCount = tDict.get(letter);
    !letterCount ? tDict.set(letter, 1) : tDict.set(letter, letterCount + 1);
  }
    
  // Check if a letter doesn&#39;t occur the same number of times
  sDict.forEach((letterCount, letter) =&gt; {
    if (tDict.get(letter) !== letterCount) {
      isValid = false;
    }
  });

  return isValid;
};
</code></pre>
<h4>Time and space complexity</h4>
<p>My guess for the time complexity is $O(n)$ as we iterate through the string&#39;s length to create the map. Space complexity would be $O(n)$ as well, because creating the map grows linearly as the length of the string increases.</p>
<h5>Using Python</h5>
<p>Many things are potential one-liners in Python, so </p>
<pre><code class="language-python">collections.Counter(s) == collections.Counter(t)
</code></pre>
<p>is the easiest thing to do. </p>
<p>But to recreate the above code, it might look like this:</p>
<pre><code class="language-python">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        if len(s) != len(t):
            return False
        
        s_dict = {}
        t_dict = {}

        for letter in s:
            s_dict[letter] = s_dict.get(letter, 0) + 1

        for letter in t:
            t_dict[letter] = t_dict.get(letter, 0) + 1

        for letter, letter_count in s_dict.items():
            if t_dict.get(letter, 0) != letter_count:
                return False
        
        return True
</code></pre>
<p>Note that we don&#39;t need an <code>isValid</code> flag in this case, as we&#39;re not checking the letter counts inside a function with limited scope inside some function like a <code>forEach</code>.</p>
<p>Also inside the last loop, as the letter in <code>s_dict</code> may not be in <code>t_dict</code>, we&#39;re using <code>t_dict.get(letter, 0)</code>, so if it doesn&#39;t exist, it would be initialized with the count <code>0</code>.<br>I don&#39;t think that&#39;s a good solution at all, though.<br>So let&#39;s take a deep breath, and look at NeetCode&#39;s solution.</p>
<hr>
<p>NeetCode&#39;s solution was pretty similar to the Python version above.</p>
<pre><code class="language-python">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        if len(s) != len(t):
            return False
        
        countS, countT = {}, {}

        for i in range(len(s)):
            countS[s[i]] = 1 + countS.get(s[i], 0)
            countT[t[i]] = 1 + countT.get(t[i], 0)

        for c in countS:
            if countS[c] != countT.get(c, 0):
                return False
        
        return True
</code></pre>
<p>The time and space complexity in this case are $O(n)$ as well.</p>
<p>To get rid of the extra memory usage and make the space complexity $O(1)$, he mentions the solution where you can compare the sorted versions of the strings:</p>
<pre><code class="language-python">sorted(s) == sorted(t)
</code></pre>
<p>In the case of TypeScript (or JavaScript) it could be:</p>
<pre><code class="language-ts">[...s].sort().join(&#39;&#39;) === [...t].sort().join(&#39;&#39;);
</code></pre>
<Note>
This one wouldn't work as intended:

<pre><code class="language-ts">[...s].sort() === [...t].sort();
</code></pre>
<p>Because <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#description" target="_blank" rel="noopener noreferrer">arrays are objects</a>, they&#39;ll be equal to each other only if they point to the same object in memory. In this case, even if <code>[...s].sort()</code> and <code>[...t].sort()</code> look like they are the same, they won&#39;t be equal to each other.<br></Note></p>
<p>But, of course, sorting algorithms can&#39;t get better than $O(n \ log \ n)$ when it comes to time complexity, and some of them use $O(n)$ space to create additional storage as well, so it&#39;s another trade-off.</p>
<p>We can take one more deep breath now.</p>
<p>Next up is <a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noopener noreferrer">Two Sum</a>, until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-valid-anagram</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-valid-anagram</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 17 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Contains Duplicate]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-15/02-lm.png" alt="Cover image"></p>
<p>For <a href="https://leetcode.com/problems/contains-duplicate/description/" target="_blank" rel="noopener noreferrer">this problem</a>, let&#39;s start with the description: </p>
<blockquote>
<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>
</blockquote>
<p>For example:</p>
<pre><code class="language-ts">[1, 2, 3, 1] // true
[1, 2, 3, 4] // false
[1, 1, 1, 3, 3, 4, 3, 2, 4, 2] // true
</code></pre>
<hr>
<p>We can use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener noreferrer"><code>Set</code></a> which only keeps the values without duplicates.</p>
<p>For each example, it would look like this:</p>
<pre><code class="language-js">new Set([1, 2, 3, 1]);
// -&gt; Set(3) { 1, 2, 3 }

new Set([1, 2, 3, 4]);
// -&gt; Set(4) { 1, 2, 3, 4 }

new Set([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]);
// -&gt; Set(4) { 1, 3, 4, 2 }
</code></pre>
<p>In that case, the difference between the <em>size</em> of the set and the length of the original array will tell us whether it contains duplicates or not. If they are not equal to each other, that means the array has duplicates.</p>
<p>Using TypeScript, my solution was this:</p>
<pre><code class="language-ts">function containsDuplicate(nums: number[]): boolean {
  return !(new Set(nums).size === nums.length);
};
</code></pre>
<p>It&#39;s obvious from the size and length comparison that this solution works, and indeed, it passes the tests.</p>
<h4>Time &amp; space complexity</h4>
<p>My guess for the time complexity is that it&#39;s $O(n)$, because the <code>Set</code> constructor iterates over each element in the array it is given as the argument.<br>I think that the space complexity is also $O(n)$, because in the worst case where each element is unique, <code>Set</code> needs to allocate memory for each of them. </p>
<h5>Using Python</h5>
<p>We can translate this solution into Python like this as well:</p>
<pre><code class="language-python">class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        return len(set(nums)) != len(nums)
</code></pre>
<hr>
<p>It&#39;s now time to take a breath.</p>
<p>Let&#39;s look at <a href="https://www.youtube.com/watch?v=3OamzN90kPg" target="_blank" rel="noopener noreferrer">NeetCode&#39;s solution</a>:</p>
<pre><code class="language-python">class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        hashset = set()

        for n in nums:
            if n in hashset:
                return True
            hashset.add(n)

        return False
</code></pre>
<p>The worst case is still $O(n)$, and space complexity is $O(n)$ as well in the case of each element being unique.</p>
<p>However, I think it&#39;s an improvement as compared to my initial solution, because instead of creating the set in one go, we can return immediately if the element is in the set as we go through adding each one.</p>
<p>As we have reached the end of this meditation, we can take one more deep breath. Next up is the <a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener noreferrer">Valid Anagram</a> problem. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-contains-duplicate</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-contains-duplicate</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 15 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations — Chapter 1: Arrays & Hashing]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-13/01-lm-ch1.png" alt="Cover image"></p>
<p>Before starting the <a href="https://neetcode.io/practice" target="_blank" rel="noopener noreferrer">Arrays &amp; Hashing section in the Blind 75 list</a>, let&#39;s <em>very briefly</em> get to know our prerequisite topics for now:</p>
<ul>
<li>dynamic arrays</li>
<li>hash tables</li>
<li>prefix sums</li>
</ul>
<br />

<h2>Dynamic Arrays</h2>
<p>Dynamic arrays are, well, dynamic. They&#39;re flexible, and can change their size during execution.</p>
<p>Python&#39;s <code>list</code> type is a dynamic array.<br>We can create an <code>items</code> list, for example:</p>
<pre><code class="language-python">items = [3, 5]
</code></pre>
<p>The <em>length</em> of <code>items</code> is obviously 2, but its <em>capacity</em> is greater than or equal to its length. In fact, <strong>capacity</strong> refers to the total size, whereas <strong>length</strong> is the actual size.</p>
<p>Since dynamic arrays are still arrays, they need a <em>contiguous block of memory</em>.</p>
<p>We can easily add an item to <code>items</code>:</p>
<pre><code class="language-python">items.append(7)
</code></pre>
<p>And add some more:</p>
<pre><code class="language-python">items.append(9)
items.append(11)
items.append(13)
</code></pre>
<p>All the while, the length and capacity of <code>items</code> keeps growing dynamically.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-13/dynamic-arrays.gif" alt="Dynamic arrays example"></p>
<h4>Time and space complexity</h4>
<p>Accessing an element is $O(1)$ as we have <a href="https://en.wikipedia.org/wiki/Random_access" target="_blank" rel="noopener noreferrer">random access</a>.</p>
<p>Inserting a new element or deleting an element is $O(n)$ (think about having to shift all the elements before inserting or after deleting an item). But, <a href="https://en.wikipedia.org/wiki/Amortized_analysis" target="_blank" rel="noopener noreferrer">in order to not be too pessimistic, we can look at amortized analysis</a>, in that case, inserting/deleting at the end of the array becomes $O(1)$.  </p>
<p>Space complexity is $O(n)$, because of the excess space.</p>
<br />

<h2>Hash Tables</h2>
<p>A hash table maps keys to values, implementing an <em>associative array</em>.</p>
<p>Python&#39;s <code>dict</code> is one example:</p>
<pre><code class="language-python">number_of_petals = {
    &#39;Euphorbia&#39;: 2, 
    &#39;Trillium&#39;: 3, 
    &#39;Columbine&#39;: 5,
}
</code></pre>
<p>Also JavaScript&#39;s &quot;object&quot;s:</p>
<pre><code class="language-js">let numberOfMoons = {
  &#39;Earth&#39;: 1,
  &#39;Mars&#39;: 2,
  &#39;Jupiter&#39;: 95,
  &#39;Saturn&#39;: 146,
  &#39;Uranus&#39;: 27,
  &#39;Neptune&#39;: 14,
};
</code></pre>
<p>There are two important ingredients for a hash table:</p>
<ul>
<li>an array of &quot;buckets&quot; to store the data</li>
<li>a hash function to map the data to a specific index in the array</li>
</ul>
<p>Hashes are usually large integers, so to find an index, we can take the result of the hash modulo the array&#39;s length.</p>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-13/hash-tables.gif" alt="Hash tables example"></p>
<Note>
The **hash function** that's mapping the elements to buckets is <mark>not</mark> the `hash()` used in the visual (it's just a [Python function](https://docs.python.org/3/library/functions.html#hash) to calculate the hash value of an object). The hash function in this case is the modulo ( `%` ) operation.
</Note>

<p>Here, with the hash value of each item&#39;s key, we calculate the remainder when it&#39;s divided by the length of the array to find which &quot;bucket&quot; it should go to.</p>
<p>The ratio of the number of elements to the number of buckets is called the <strong>load factor</strong>, and the higher it gets, the more <strong>collisions</strong> (when elements have to be inserted at the same place in the array) occur.</p>
<p>There are some collusion resolution tactics like <strong>linear probing</strong> (probing through the array until finding an empty bucket) and <strong>chaining</strong> (chaining multiple elements as linked lists), but we&#39;ll not go into those for now.</p>
<h4>Time and Space Complexity</h4>
<p>The average case for searching, inserting, and deleting operations are $O(1)$ as we use keys to look up the values.</p>
<p>Space complexity is $O(n)$ as it grows linearly with the amount of elements.</p>
<br />

<h2>Prefix Sums</h2>
<p>A prefix sum is the sequence of numbers we get after adding the sums of running totals of another sequence.<br>It&#39;s also called the <strong>cumulative sum</strong>.</p>
<p>The first element of the resulting array is the first element of the input array. That&#39;s fine. We start at the second item, and add the previous numbers each time as we go. That is:</p>
<p>$$result[i] = \begin{cases} nums[0] &amp; \text{if } i \text{ is zero} \ result[i - 1] + nums[i] &amp; \text{if  } i \geq 1 \end{cases}$$</p>
<p>In code, we can implement that easily:</p>
<pre><code class="language-python">def runningSum(nums):
    result = [nums[0]]
    
    for i in range(1, len(nums)):
        result.append(result[i - 1] + nums[i])

    return result
</code></pre>
<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-13/prefix-sums.gif" alt="Prefix sums example"></p>
<h4>Time and space complexity</h4>
<p>Time complexity for a prefix sum is $O(n)$ because we&#39;re iterating over each of the elements in the array.<br>The space complexity is also $O(n)$ because the need of space grows as the length of the original array grows.</p>
<hr>
<p>And, we&#39;re done with the introduction to the first chapter, now it&#39;s time to take a breath and notice your surroundings. Maybe it&#39;s raining, or a bird sings nearby, or there&#39;s just the silence of the night. Or neither of them, that&#39;s all fine.</p>
<p>The first problem to look at will be <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener noreferrer">Contains Duplicate</a>, so until then, happy coding.</p>
<h5>References</h5>
<ul>
<li><a href="https://brilliant.org/wiki/dynamic-arrays/#dynamic-arrays-in-python" target="_blank" rel="noopener noreferrer">Dynamic Arrays in Python - brilliant.org</a></li>
<li><a href="https://brilliant.org/wiki/hash-tables" target="_blank" rel="noopener noreferrer">Hash Tables - brilliant.org</a></li>
<li><a href="https://medium.com/basecs/taking-hash-tables-off-the-shelf-139cbf4752f0" target="_blank" rel="noopener noreferrer">&quot;Taking Hash Tables Off The Shelf&quot; - Vaidehi Joshi</a></li>
<li><a href="https://leetcodethehardway.com/tutorials/basic-topics/prefix-sum" target="_blank" rel="noopener noreferrer">Prefix Sum - LeetCode The Hard Way</a></li>
</ul>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-chapter-1-arrays-and-hashing</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-chapter-1-arrays-and-hashing</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 13 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[LeetCode Meditations: Introduction]]></title>
            <description><![CDATA[<p><img src="https://raw.githubusercontent.com/rivea0/leetcode-meditations-assets/main/src/2024-02-13/00-lm-intro.png" alt="Cover image"></p>
<p>It may seem like an oxymoron when the words &quot;LeetCode&quot; and &quot;meditation&quot; are used together; after all, one thing that almost everyone can agree is that <a href="https://leetcode.com/" target="_blank" rel="noopener noreferrer">LeetCode</a> is challenging. It&#39;s called <em>grinding</em> LeetCode for a reason.</p>
<p>It doesn&#39;t have anything to do with the platform, of course, but rather what it represents: tackling problems for hours on end, usually to find a solution that is even harder to understand.</p>
<p>However, what is more challenging is finding a roadmap to solve those problems with very little knowledge of data structures and algorithms. There are prerequisites to solve one type of problem, and there are prerequisites for understanding those prerequisites in the first place.<br>It&#39;s just intimidating when you consider yourself a beginner.</p>
<p>That&#39;s why finding out about <a href="https://neetcode.io/roadmap" target="_blank" rel="noopener noreferrer">this roadmap</a> from <a href="https://neetcode.io/" target="_blank" rel="noopener noreferrer">neetcode.io</a> gave me an idea. LeetCode can be a good resource as you go about learning the concepts. In fact, why not take a more structured and <em>calmer</em> approach? If you don&#39;t have an interest in competitive programming or things of that sort, it doesn&#39;t have to be a pain.<br>We can treat learning about the topics and solving the problems on the list like taking a brief walk in nature, and maybe even pay attention to our breathing as much as we pay attention to the runtime analyses.<br>Also, an important point: it&#39;s not necessary to spend way too much time trying to solve one problem in one sitting; it is not only unhealthy, but it won&#39;t provide any value after some point.</p>
<p>The NeetCode roadmap contains a lot of problems, but in this series, I intend to follow the <a href="https://leetcode.com/discuss/general-discussion/460599/Blind-75-LeetCode-Questions/1057039" target="_blank" rel="noopener noreferrer">Blind 75</a> list as the roadmap also includes it. I aim to &quot;get-to-know&quot; (or at least, introduce myself to if I&#39;m unfamiliar with) the &quot;prerequisite&quot; topics before each section, and for the problems, try my attempt at a solution one at a time, and when I get stuck, I&#39;ll at least try to reason about <em>an idea</em> of a solution. And, if I get really stuck and can&#39;t come up with an idea as well, then it&#39;s time to take a breath and learn about the solution(s) available.</p>
<p>In fact, if you&#39;ve read this far, why not take a deep breath now, too?</p>
<hr>
<p>The premium problems won&#39;t be included, as I want this series to be accessible. I&#39;ll provide NeetCode&#39;s solutions here and there for comparison at the end as well.</p>
<p>Now, time for some introspection. Is it likely that five years or so later I may regret putting up my first attempts for solutions to those problems? Probably. Will I be satisfied that writing about them is an aid to my learning, and shows an aspect of it? Yes, I guess.<br>Will I be satisfied that there is a chance this series might help someone out there? Absolutely.</p>
<p>Solving hundreds of LeetCode problems may be the gate to go through to get an interview at big tech companies, but learning the topics the problems are about is not under anyone&#39;s monopoly. </p>
<p>With that said, let&#39;s start the <a href="https://rivea0.github.io/blog/leetcode-meditations-chapter-1-arrays-and-hashing" target="_blank" rel="noopener noreferrer">first chapter</a>.</p>
]]></description>
            <link>https://rivea0.github.io/blog/leetcode-meditations-introduction</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/leetcode-meditations-introduction</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 13 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A recursive algorithm for incrementing natural numbers]]></title>
            <description><![CDATA[<p>Incrementing a natural number is simple as adding $1$ to it, so why would we ever want to think about a fancy way of doing it? All we need to do is to go from $y$ to $y + 1$, and well, that&#39;s pretty obvious.</p>
<p>But, let&#39;s take a look at one example:</p>
<pre><code class="language-python">from math import floor

def increment(y):
    if y == 0:
        return 1
    elif y % 2 == 1:
        return 2 * increment(floor(y / 2))

    return y + 1
</code></pre>
<p>It&#39;s a beautiful recursive algorithm for incrementing natural numbers, taken from Steven Skiena’s <em>The Algorithm Design Manual</em>.</p>
<p>But how do we know that it&#39;s correct?</p>
<p>The book answers it, by using <a href="https://rivea0.github.io/bite-sized-math-for-cs/unit-01-proofs/induction/" target="_blank" rel="noopener noreferrer">induction</a>.</p>
<p>The <em>base case</em> is when $y$ equals $0$, and if that&#39;s the case, we return $1$. That is correct: $0 + 1 = 1$.</p>
<p>Our <em>induction hypothesis</em> is that $\text{Increment}(n - 1)$ is $n$.<br>We assume that is the case, and go on to show that $\text{Increment}(n)$ holds as well, that is, $\text{Increment}(n) = n + 1$.</p>
<p>When $y$ is an even number (when $y \text{ mod }  2 = 0$), we return $y + 1$ in the last line, so that&#39;s correct.</p>
<p>So what&#39;s the deal with odd numbers, then?</p>
<p>When $y$ is odd (when $y \text{ mod }  2 = 1$), what is returned from the <code>increment</code> function is:</p>
<pre><code class="language-python">2 * increment(floor(y / 2))
</code></pre>
<p>Remember that we need to prove $\text{Increment}(n) = n + 1$, so we need to prove that what we return here is indeed <code>y + 1</code>.</p>
<p>When $y$ is odd, we can write it as $2m + 1$, for some integer $m$. In that case, what we have is:</p>
<pre><code class="language-python">2 * increment(floor(((2 * m) + 1) / 2))
</code></pre>
<p>Or:</p>
<p>$$2 \cdot \text{Increment}(\lfloor(2m + 1) / 2\rfloor)$$</p>
<Note>
$\lfloor$ and $\rfloor$ indicate the [floor function](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions).
</Note>

<p>We can simplify it by dividing the terms inside $\text{Increment}$ by $2$:</p>
<p>$$2 \cdot \text{Increment}(\lfloor{m + 1 / 2}\rfloor)$$</p>
<p>Taking the floor of $m + 1/2$, we have just $m$ (remember that $m$ is an integer):</p>
<p>$$ 2 \cdot \text{Increment}(m)$$</p>
<p>...which is (by our <em>induction hypothesis</em>):</p>
<p>$$2(m + 1)$$</p>
<p>...which is:</p>
<p>$$2m + 2$$</p>
<p>We said that $y$ is $2m + 1$. And the result of our increment function returns $2m + 2$, which is the correct answer: $y + 1$ 🎉</p>
<p>This is certainly a bit tricky at first, but it provides an important lesson that induction is a solid way of proving correctness, even though most of it feels like magic.</p>
<hr>
<p><em>The lectures based on the book <em>The Algorithm Design Manual</em> can be found <a href="https://www3.cs.stonybrook.edu/~skiena/373/videos/" target="_blank" rel="noopener noreferrer">here</a>.</em></p>
]]></description>
            <link>https://rivea0.github.io/blog/a-recursive-algorithm-for-incrementing-natural-numbers</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/a-recursive-algorithm-for-incrementing-natural-numbers</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 03 Feb 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[When in need of a Promise]]></title>
            <description><![CDATA[<p>If you&#39;re using a library that uses callbacks extensively, like <a href="https://www.npmjs.com/package/sqlite3" target="_blank" rel="noopener noreferrer"><code>sqlite3</code></a>, there&#39;s a good chance that it creates some frustration. There are libraries that add a promise-based API to <code>sqlite3</code>, such as <a href="https://www.npmjs.com/package/sqlite" target="_blank" rel="noopener noreferrer"><code>sqlite</code></a> that might be more convenient to use, but let&#39;s narrow our focus for now and take a look at a very simple (and somewhat contrived) case.</p>
<p>Let&#39;s say we have an <code>insertRow</code> function that simply inserts data into some <code>entries</code> table:</p>
<pre><code class="language-js">async function insertRow(db, data) {
  const { title, description, date } = data;

  db.run(
    `INSERT INTO entries(title, description, date) VALUES(?, ?, ?);`,
    title, 
    description, 
    date,
    async function (error) {
      if (error) {
        throw new Error(error.message);
      } else {
        console.log(
          `Inserted a row to entries with the ID: ${this.lastID}`
        );
      }
    }
  );
}
</code></pre>
<p>...which is called by <code>insert</code>:</p>
<pre><code class="language-js">async function insert(data) {
  const db = new sqlite3.Database(filepath);
  try {
    await insertRow(db, data);
  } catch (error) {
    throw new Error(error.message);
  }
}
</code></pre>
<p>...which is called by <code>createEntry</code>:</p>
<pre><code class="language-js">async function createEntry(formData) {
  const data = {
    title: formData.get(&#39;title&#39;),
    description: formData.get(&#39;description&#39;),
    date: formData.get(&#39;date&#39;),
  };

  try {
    await insert(data);
  } catch (error) {
    return { message: `Failed to create entry ${data.title}` };
  }
}
</code></pre>
<p>It might indeed be a contrived example, but if you&#39;re quick to notice, we&#39;re trying to rethrow the error (which was first thrown by <code>insertRow</code>) in <code>insert</code>, and catch it in <code>createEntry</code>. However, in <code>insertRow</code>, the error is thrown inside the callback, which is passed to <code>db.run</code> — which means it will never be caught, unless we do something about it. </p>
<p>Instead, we can return a promise from <code>insertRow</code> that <em>rejects</em> when an error happens:</p>
<pre><code class="language-js">async function insertRow(db, data) {
  const { title, description, date } = data;

  return new Promise((resolve, reject) =&gt; {
    db.run(
      `INSERT INTO entries(title, description, date) VALUES(?, ?, ?);`,
      title, 
      description, 
      date,
      async function (error) {
        if (error) {
          reject(error);
        } else {
          console.log(
            `Inserted a row to entries with the ID: ${this.lastID}`
          );
          resolve();
        }
      }
    );
  });
}
</code></pre>
<p>Since we&#39;re using <code>try...catch</code> in <code>insert</code> and rethrow the error, we&#39;ll eventually return with </p>
<pre><code class="language-js">{ message: `Failed to create entry ${data.title}` };
</code></pre>
<p>inside <code>createEntry</code> as we catch the error there.</p>
<p>This might not be ideal, and using a library that provides a promise-based API would be a better idea, but when you have to use a callback-based approach, wrapping it as a Promise is something to keep in mind.</p>
]]></description>
            <link>https://rivea0.github.io/blog/when-in-need-of-a-promise</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/when-in-need-of-a-promise</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 13 Jan 2024 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[The curious case of recursive and iterative processes]]></title>
            <description><![CDATA[<p>Note that the title is not <em>recursion vs. iteration</em>. Usually, the distinction between these two terms is clear-cut: recursion is about functions that call themselves, while iteration is  done through looping. That is correct, but here, we specifically refer to the shape of how a function evolves. </p>
<p>What do we mean by <em>the shape of how a function evolves</em>?</p>
<p>Let&#39;s say for now that if the shape grows and shrinks, then it is recursive, if it doesn&#39;t, then it is an iterative process.</p>
<p>The terminology here might be a bit confusing, but one thing to keep in mind throughout this post is:</p>
<p align="center">recursive function !== recursive process</p>

<p>Which means, what if there are recursive functions that have iterative processes?</p>
<p>Is this a recursive function?</p>
<pre><code class="language-ts">function plus(a, b) {
  if (a === 0) {
    return b;
  } else {
    return 1 + plus(a - 1, b);
  }
}
</code></pre>
<p>What about this one?</p>
<pre><code class="language-js">function plus(a, b) {
  if (a === 0) {
    return b;
  } else {
    return plus(a - 1, b + 1);
  }
}
</code></pre>
<p>They are both recursive functions alright, but the processes they generate are different. In fact, the second one is what is called a tail-recursive function, but let&#39;s not get ahead of ourselves.</p>
<p>Let&#39;s say we want to see how <code>plus(2, 3)</code> works with both examples.</p>
<p>With the first function, <code>a</code> is not equal to <code>0</code>, so we return <code>1 + plus(a - 1, b)</code>. But we first need to compute <code>plus(a - 1, b)</code> for that. So, we go on and call <code>plus</code> with new arguments: <code>plus(1, 3)</code>. Again, <code>a</code> is not equal to <code>0</code>, so we return <code>1 + plus(a - 1, b)</code>. But again, we need to do a recursive call first, so we go on to <code>plus(0, 3)</code>. Now the base case holds, and we return <code>b</code>, which is <code>3</code>. As this function is popped off the stack, the previous function takes this value and adds <code>1</code> to it. Our value is now <code>4</code>. When this one is popped off the stack as well, we&#39;re left with the very first function call; it adds <code>1</code> to the value it gets, which is <code>4</code>, and the result is <code>5</code>. And, we&#39;re done. This is good old recursion as we know it.</p>
<p>Here is a visual display of what is just described:</p>
<p><img src="/blog/post-images/2023-12-23/recursive-process.gif" alt="Recursive process"></p>
<p>To see the <em>shape</em> more clearly, let&#39;s give it different arguments: <code>5</code> and <code>3</code> this time. The process would look like this:</p>
<pre><code>plus(5, 3)
1 + plus(4, 3)
1 + (1 + plus(3, 3))
1 + (1 + (1 + plus(2, 3)))
1 + (1 + (1 + (1 + plus(1, 3))))
1 + (1 + (1 + (1 + (1 + plus(0, 3)))))
1 + (1 + (1 + (1 + (1 + 3))))
1 + (1 + (1 + (1 + 4)))
1 + (1 + (1 + 5))
1 + (1 + 6)
1 + 7
8
</code></pre>
<p>Now the <em>grow-and-shrink</em> part is more obvious.</p>
<p>The actual work of adding <code>1</code> is done on the way out, so to speak.</p>
<p>With the second example, though, things are a bit different. With this one, note that the final operation is a recursive call, there is no waiting to add <code>1</code> like in the other example. </p>
<p>Let&#39;s see it again with the same arguments, <code>plus(2, 3)</code>.</p>
<p><code>a</code> is not equal to <code>0</code>, so we call <code>plus(1, 4)</code>.</p>
<p>Once again, <code>a</code> is not equal to <code>0</code>, so we go on to <code>plus(0, 5)</code>.<br>And now the base case holds, <code>a</code> is <code>0</code>, so we return <code>b</code> which is <code>5</code>.</p>
<p>Here&#39;s how it goes:</p>
<p><img src="/blog/post-images/2023-12-23/iterative-process.gif" alt="Iterative process"></p>
<p>If we were to use <code>5</code> and <code>3</code>:</p>
<pre><code>plus(5, 3)
plus(4, 4)
plus(3, 5)
plus(2, 6)
plus(1, 7)
plus(0, 8)
8
</code></pre>
<p>So, while the first example has a <em><strong>recursive process</strong></em>, the second one has an <em><strong>iterative process</strong></em>.</p>
<p>The second one is also an example of a tail-recursive function because there is nothing left to do after the recursive call.</p>
<p>Note that the second function is still a recursive function, it calls itself, but it has an iterative process.</p>
<p>Most of these sound like a confusion of terminology, but they eventually make sense.</p>
<p>More information can be found at <a href="https://sourceacademy.org/sicpjs/1.2.1" target="_blank" rel="noopener noreferrer">https://sourceacademy.org/sicpjs/1.2.1</a>, in fact, the example is adapted from one of the exercises.<br>You can also read the section from <a href="https://web.mit.edu/6.001/6.037/sicp.pdf#subsection.1.2.1" target="_blank" rel="noopener noreferrer">the original book</a> or watch <a href="https://archive.org/details/ucberkeley_webcast_0G3tNuBBO5I" target="_blank" rel="noopener noreferrer">Brian Harvey&#39;s lecture</a>, which dives into the subject at the 17~ minute mark.</p>
<p><em>The animated GIFs are inspired by <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif" target="_blank" rel="noopener noreferrer">Lydia Hallie&#39;s JavaScript Visualized series</a>.</em></p>
]]></description>
            <link>https://rivea0.github.io/blog/the-curious-case-of-recursive-and-iterative-processes</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/the-curious-case-of-recursive-and-iterative-processes</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 23 Dec 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Applicative-order vs. normal-order evaluation]]></title>
            <description><![CDATA[<p>Let&#39;s look at this interesting sentence:</p>
<blockquote>
<p><em>The most noticeable effect of applicative-order evaluation is that recursive functions may not terminate.</em><a href="https://sookocheff.com/post/fp/evaluating-lambda-expressions/" target="_blank" rel="noopener noreferrer">^1</a></p>
</blockquote>
<p>Out of context, it sounds like a lot is going on.</p>
<p><em>Applicative-order evaluation?</em></p>
<p><em>Recursive functions that may not terminate?</em></p>
<p>It sounds very thrilling, in the sense that it might be straight out of your nightmares, especially when it comes to non-terminating recursive functions.</p>
<p>When it comes to functions, it is no mystery how they are evaluated in the code we write — even if you don&#39;t use the term <em>substitution</em>, you&#39;re aware of what is going on here:</p>
<pre><code class="language-js">function add(x, y) { 
  return x + y; 
}

add(7, 5); // 12
</code></pre>
<p>What is happening is that <code>7</code> is substituted for <code>x</code>, and <code>5</code> is substituted for <code>y</code>. That&#39;s great.</p>
<p>But first, let&#39;s look at an example.</p>
<p>Let&#39;s say we have to find the square root of a number, and we want to do it using <a href="https://ocw.mit.edu/courses/18-335j-introduction-to-numerical-methods-spring-2019/0a734ecc94b60a26213488e68588bc8d_MIT18_335JS19_lec1.pdf" target="_blank" rel="noopener noreferrer">Newton&#39;s method</a> of approximating guesses.</p>
<p>How it goes is simple. We take a guess for the square root of a number $a$, and we improve our guess until we have a good enough answer that is <em>really close</em> to the actual square root of $a$.</p>
<p>How to improve our guess looks like this:</p>
<p>$$x_{n + 1} = \frac{1}{2}\Big(x_n + \frac{a}{x_n}\Big)$$</p>
<p>Let&#39;s unpack it a bit.</p>
<ul>
<li>$a$ is the number that we want to know the square root of.</li>
<li>$x_n$ is our current guess.</li>
<li>$x_{n + 1}$ is the next (the <em>improved</em>) guess.</li>
</ul>
<p>So, the next guess will be the average of two numbers: <em>our guess</em> ($x_n$) and <em>the number we want to know the square root of divided by our guess</em> ($\frac{a}{x_n}$).</p>
<p>The example is not particularly important, so if you don&#39;t feel very warm with math, that&#39;s fine. The gist is that we improve our guess until it&#39;s very very close to the actual number.</p>
<p>In JavaScript, it can be written like this:</p>
<pre><code class="language-js">function square(x) {
  return x * x;
}

function average(x, y) {
  return (x + y) / 2;
}

function is_good_enough(guess, x) {
  return Math.abs(square(guess) - x) &lt; 0.001;
}

function improve(guess, x) {
  return average(guess, x / guess);
}

function sqrt_iter(guess, x) {
  return is_good_enough(guess, x) ? guess : sqrt_iter(improve(guess, x), x);
}

sqrt_iter(1, 4); // 2.0000000929222947
</code></pre>
<p>But, let&#39;s say we don&#39;t like ternary operations up in our face in <code>sqrt_iter</code>, so we want to abstract it out still further:</p>
<pre><code class="language-js">function check(predicate, then_clause, else_clause) {
  return predicate ? then_clause : else_clause;
}
</code></pre>
<Note>
A [predicate](https://en.wikipedia.org/wiki/Propositional_function) is just a function that returns a boolean.
</Note>

<p>Then we can use it like this, perhaps:</p>
<pre><code class="language-js">function sqrt_iter(guess, x) {
  return check(
    is_good_enough(guess, x),
    guess,
    sqrt_iter(improve(guess, x), x)
  );
}
</code></pre>
<p>However, when we run it, we have an error that you might be very familiar when doing recursion: <code>Maximum call stack size exceeded</code>.</p>
<p>Why is that?</p>
<p>In the first iteration, when <code>sqrt_iter</code> was looking like this:</p>
<pre><code class="language-js">function sqrt_iter(guess, x) {
  return is_good_enough(guess, x) ? guess : sqrt_iter(improve(guess, x), x);
}
</code></pre>
<p>Everything worked fine, and we got our answer.</p>
<p>Why do we have an error when passing the recursive call to another function, then?</p>
<p>Well, the quote was a foreshadowing. The reason is what is called the evaluation order.</p>
<p>If you&#39;ve ever read or intend to read <a href="https://web.mit.edu/6.001/6.037/sicp.pdf" target="_blank" rel="noopener noreferrer"><em>the wizard book</em></a>, this is one of the subjects that is touched upon in the early pages.</p>
<p>The authors (or <em>wizards</em>, I should say) talk about two distinct evaluation orders:</p>
<ul>
<li><strong>applicative-order --&gt;</strong> &quot;evaluate the arguments and then apply&quot;</li>
<li><strong>normal-order --&gt;</strong> &quot;fully expand and then reduce&quot;</li>
</ul>
<p>With <em>applicative-order</em>, a function&#39;s arguments are evaluated before the function is applied, and with <em>normal-order</em>, none of the arguments are evaluated until they are needed in the function body.</p>
<p>In our example, when we pass <code>sqrt_iter</code> to <code>check</code>, it is evaluated first, hence the recursion error. The reason is that JavaScript makes use of applicative-order, so the arguments are evaluated first.</p>
<p>Let&#39;s see it with a much simpler example, using Python this time. Let&#39;s say we have a <code>sum_of_squares</code> function that returns, well, <em>the sum of squares</em> of two numbers <code>n</code> and <code>m</code>:</p>
<pre><code class="language-python">def sum_of_squares(n, m):
    return square(n) + square(m)

def square(x):
    return x * x
</code></pre>
<p>And, we pass <code>5 + 1</code> and <code>5 * 2</code> as arguments:</p>
<pre><code class="language-python">sum_of_squares(5 + 1, 5 * 2)
</code></pre>
<p>With applicative-order, the process looks like this:</p>
<pre><code>-&gt;  square(6) + square(10)
-&gt;    (6 * 6) + (10 * 10)
-&gt;         36 + 100
-&gt;           136
</code></pre>
<p>But with normal-order:</p>
<pre><code>-&gt;      square(5 + 1)   +   square(5 * 2)
-&gt;  ((5 + 1) * (5 + 1)) + ((5 * 2) * (5 * 2))
-&gt;             (6 * 6)  +  (10 * 10)
-&gt;                36    +    100
-&gt;                     136
</code></pre>
<p>Note that with normal-order, the evaluations of <code>(5 + 1)</code> and <code>(5 * 2)</code> are done twice, so we&#39;re doing extra work.</p>
<p>With languages like JavaScript that most people are familiar with, it looks like what&#39;s being used is applicative-order evaluation. I guess that is sort of true, but neither are said to be used in the <em>strict sense</em>:</p>
<blockquote>
<p>In practice, no programming language uses normal-order evaluation because of the performance penalty, and it is also difficult to use strict applicative-order evaluation because of the increase in non-terminating cases. Rather, programming languages tend to use <em>lazy-evaluation</em> as a means of enabling the performance benefit of applicative-order evaluation without the risk.<a href="https://sookocheff.com/post/fp/evaluating-lambda-expressions/#summary" target="_blank" rel="noopener noreferrer">^2</a></p>
</blockquote>
<p>As another nightmare fuel for the non-terminating recursive case, let&#39;s take a look at this one last example:</p>
<pre><code class="language-js">function p() { 
  return p(); 
}

function test(x, y) {
  return x === 0 ? 0 : y;
}

test(0, p());
</code></pre>
<p>With applicative-order, what will happen when we call <code>test</code> is that both of the arguments will get evaluated first. When we call <code>p()</code>, you know what will happen: a good old <code>Maximum call stack size exceeded</code>. So, it will never terminate.</p>
<p>With normal-order evaluation, though, realize what happens.<br>The evaluation of the arguments won&#39;t happen until <code>test</code> goes on to evaluate <code>x === 0 ? 0 : y</code>. Only then, <code>0</code> is substituted for <code>x</code>, and since <code>0 === 0</code> is true, the function will return <code>0</code> and terminate. It doesn&#39;t need to evaluate <code>p()</code> further because of <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation" target="_blank" rel="noopener noreferrer">short-circuiting</a>; the else condition (<code>:</code>) is not reached.</p>
<p>So, it is not true that both kinds of evaluations will yield the same answer all the time. </p>
<p>The takeaway is that, like many things, there is a tradeoff.<br>It is entertaining, though, that even a simple matter of substitution has intricacies, probably far more than what is mentioned in this post.</p>
<hr>
<p><em><code>sum_of_squares</code> is adapted from the original <a href="https://web.mit.edu/6.001/6.037/sicp.pdf#subsection.1.1.5" target="_blank" rel="noopener noreferrer">Structure and Interpretation of Computer Programming</a>, and the JavaScript examples are adapted from the JavaScript version of the book (yes, <a href="https://sourceacademy.org/sicpjs" target="_blank" rel="noopener noreferrer">it does exist</a>).</em></p>
]]></description>
            <link>https://rivea0.github.io/blog/applicative-order-vs-normal-order</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/applicative-order-vs-normal-order</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 21 Dec 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Converting MDX files with frontmatter into an MDX Component in Next.js 13]]></title>
            <description><![CDATA[<p><a href="https://mdxjs.com" target="_blank" rel="noopener noreferrer">MDX</a> <em>is a superset of markdown that lets you write JSX directly in markdown files</em>.<br>If you&#39;re using Next.js (this post was written for Next.js 13 specifically), you might know that it has a built-in support for MDX. You can read more about how to configure it <a href="https://nextjs.org/docs/app/building-your-application/configuring/mdx" target="_blank" rel="noopener noreferrer">in the docs</a>.</p>
<p>The most basic way to use it looks like this:</p>
<pre><code class="language-tsx">import HelloWorld from &#39;./hello.mdx&#39;

export default function Page() {
  return &lt;HelloWorld /&gt;
}
</code></pre>
<p>If you get the files dynamically, though, and use a frontmatter, things might be a bit confusing.</p>
<p>The MDX documentation <a href="https://mdxjs.com/guides/frontmatter/" target="_blank" rel="noopener noreferrer">recommends using a remark plugin, <code>remark-frontmatter</code></a> to ignore the frontmatter and get only the MDX content like this:</p>
<pre><code class="language-tsx">import fs from &#39;node:fs/promises&#39;
import remarkFrontmatter from &#39;remark-frontmatter&#39;
import {compile} from &#39;@mdx-js/mdx&#39;

console.log(
  await compile(await fs.readFile(`./posts/${params.slug}.mdx`), {
    remarkPlugins: [remarkFrontmatter]
  })
)
</code></pre>
<p>Say, if we have a <code>hello.mdx</code> file that looks something like this:</p>
<pre><code class="language-mdx">---
title: Hello world
---

# Hi

This is an example MDX file.
</code></pre>
<p>What is logged for that <code>hello.mdx</code> looks like this:</p>
<pre><code>VFile {
  data: {},
  messages: [],
  history: [],
  cwd: &#39;/Users/me/projects/demo-site&#39;,
  value: &#39;/*@jsxRuntime automatic @jsxImportSource react*/\n&#39; +
    &#39;import {Fragment as _Fragment, jsxDEV as _jsxDEV} from &quot;react/jsx-dev-runtime&quot;;\n&#39; +
    &#39;function _createMdxContent(props) {\n&#39; +
    &#39;  const _components = Object.assign({\n&#39; +
    &#39;    h1: &quot;h1&quot;,\n&#39; +
    &#39;    p: &quot;p&quot;\n&#39; +
    &#39;  }, props.components);\n&#39; +
    &#39;  return _jsxDEV(_Fragment, {\n&#39; +
    &#39;    children: [_jsxDEV(_components.h1, {\n&#39; +
    &#39;      children: &quot;Hi&quot;\n&#39; +
    &#39;    }, undefined, false, {\n&#39; +
    &#39;      fileName: &quot;&lt;source.js&gt;&quot;,\n&#39; +
    &#39;      lineNumber: 5,\n&#39; +
    &#39;      columnNumber: 1\n&#39; +
    &#39;    }, this), &quot;\\n&quot;, _jsxDEV(_components.p, {\n&#39; +
    &#39;      children: &quot;This is an example MDX file.&quot;\n&#39; +
    &#39;    }, undefined, false, {\n&#39; +
    &#39;      fileName: &quot;&lt;source.js&gt;&quot;,\n&#39; +
    &#39;      lineNumber: 6,\n&#39; +
    &#39;      columnNumber: 1\n&#39; +
    &#39;    }, this)]\n&#39; +
    &#39;  }, undefined, true, {\n&#39; +
    &#39;    fileName: &quot;&lt;source.js&gt;&quot;,\n&#39; +
    &#39;    lineNumber: 1,\n&#39; +
    &#39;    columnNumber: 1\n&#39; +
    &#39;  }, this);\n&#39; +
    &#39;}\n&#39; +
    &#39;function MDXContent(props = {}) {\n&#39; +
    &#39;  const {wrapper: MDXLayout} = props.components || ({});\n&#39; +
    &#39;  return MDXLayout ? _jsxDEV(MDXLayout, Object.assign({}, props, {\n&#39; +
    &#39;    children: _jsxDEV(_createMdxContent, props, undefined, false, {\n&#39; +
    &#39;      fileName: &quot;&lt;source.js&gt;&quot;\n&#39; +
    &#39;    }, this)\n&#39; +
    &#39;  }), undefined, false, {\n&#39; +
    &#39;    fileName: &quot;&lt;source.js&gt;&quot;\n&#39; +
    &#39;  }, this) : _createMdxContent(props);\n&#39; +
    &#39;}\n&#39; +
    &#39;export default MDXContent;\n&#39;,
  map: undefined
}
</code></pre>
<p>That is an object called <code>VFile</code>.<br>What matters is its <code>value</code> because that is the function body that we are going to <em>run</em> to compile MDX content into JavaScript.</p>
<p>In order to do that, we need to add the <code>outputFormat</code> option as <code>&#39;function-body&#39;</code> to the <code>compile()</code> function, and also change the development to <code>false</code>. We also convert it into a <code>String</code>:</p>
<pre><code class="language-tsx">import fs from &#39;node:fs/promises&#39;
import remarkFrontmatter from &#39;remark-frontmatter&#39;
import {compile} from &#39;@mdx-js/mdx&#39;

const code = String(
  await compile(
    await fs.readFile(`./posts/${params.slug}.mdx`, {
      remarkPlugins: [remarkFrontmatter],
      outputFormat: &#39;function-body&#39;,
      development: false
      /* …otherOptions */
    })
  )
)
</code></pre>
<p>The default <code>outputFormat</code> of <code>compile()</code> is <code>&#39;program&#39;</code>, it uses <code>import</code> and <code>export</code> statements, but we need to change it into <code>function-body</code>, otherwise we&#39;ll get a dreaded error: <code>Error: Cannot use import statement outside a module</code>.<br>These are not so important details, you can read more in the <a href="https://mdxjs.com/packages/mdx/#optionsoutputformat" target="_blank" rel="noopener noreferrer">docs</a>.</p>
<p>The only thing left is to run it, and we can finally return it as an MDX component with these two more lines:</p>
<pre><code class="language-tsx">const {default: Content} = await run(code, runtime)

return &lt;Content /&gt;
</code></pre>
<p>Putting it together, what we have written looks like this:</p>
<pre><code class="language-blog/[slug]/page.tsx">export default async function Page({ params }: {
  params: { slug: string }
}) {
  const code = String(
    await compile(await fs.readFile(`./posts/${params.slug}.mdx`), {
      remarkPlugins: [remarkFrontmatter],
      outputFormat: &#39;function-body&#39;,
      development: false
    })
  )

  const {default: Content} = await run(code, runtime)

  return &lt;Content /&gt;
}
</code></pre>
<p>We can do many different things such as overriding the components of <code>Content</code>, using plugins to add KateX support, etc. MDX offers a lot of flexibility.<br>As always, the first place to check out more of what we can do is <a href="https://mdxjs.com/docs/" target="_blank" rel="noopener noreferrer">the official docs</a>.</p>
]]></description>
            <link>https://rivea0.github.io/blog/converting-mdx-files-with-frontmatter-into-an-mdx-component-nextjs-13</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/converting-mdx-files-with-frontmatter-into-an-mdx-component-nextjs-13</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 29 Aug 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Implicit vs. explicit JOINs]]></title>
            <description><![CDATA[<p>Let&#39;s say we have a <code>customers</code> table that looks similar to this:</p>
<Table>
| customer_id | first_name | last_name |
| --- | --- | --- |
| 1 | John | Doe |
| 2 | Jane | Smith |
</Table>

<p>And an <code>items_ordered</code> table that&#39;s looking like this:</p>
<Table>
| customer_id | order_date | item | price |
| --- | --- | --- | ---|
| 1 | 2020-01-01 | Apple | 1.99 |
| 2 | 2020-02-02 | Banana | 0.99 |
</Table>

<p>Usually, we can join them using the <code>INNER JOIN</code> (or just <code>JOIN</code>) clause:</p>
<pre><code class="language-sql">SELECT customer_id, first_name, last_name, order_date, item, price
FROM customers
INNER JOIN items_ordered
ON customers.customer_id = items_ordered.customer_id;
</code></pre>
<p>But, there is also another way to do the same thing, which is the <em>implicit JOIN</em>:</p>
<pre><code class="language-sql">SELECT
    customers.customer_id,
    customers.first_name,
    customers.last_name,
    items_ordered.order_date,
    items_ordered.item,
    items_ordered.price
FROM customers, items_ordered
WHERE customers.customer_id = items_ordered.customer_id;
</code></pre>
<p>Looks a bit more cluttered.</p>
<p>For clarity&#39;s sake, using an explicit JOIN syntax makes more sense, and from what I&#39;ve read, it seems to be no significant performance difference between the two, and the ANSI 92 standard is <a href="https://stackoverflow.com/a/53061589" target="_blank" rel="noopener noreferrer">said to be recommending</a> using modern explicit joins.</p>
]]></description>
            <link>https://rivea0.github.io/blog/implicit-vs-explicit-joins</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/implicit-vs-explicit-joins</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A simple example of a nested SQL query]]></title>
            <description><![CDATA[<p>Let&#39;s say we have this table:</p>
<Table>
|city|country|population|latitude|longitude|
|---|---|---|---|---|
|Guadalajara|Mexico|1500800|20.659699|-103.349609|
|Toronto|Canada|2795060|43.653226|-79.383184|
|Houston|United States|2195914|29.760427|-95.369803|
|New York|United States|8405837|40.712784|-74.005941|
|Philadelphia|United States|1553165|39.952584|-75.165222|
|Havana|Cuba|2106146|23.05407|-82.345189|
|Mexico City|Mexico|8555500|19.432608|-99.133208|
|Phoenix|United States|1513367|33.448377|-112.074037|
|Los Angeles|United States|3884307|34.052234|-118.243685|
|Ecatepec de Morelos|Mexico|1742000|19.601841|-99.050674|
|Montreal|Canada|1717767|45.501689|-73.567256|
|Chicago|United States|2718782|41.878114|-87.629798|
</Table>

<p>We want to get all the cities west of Chicago.<br>As we go towards the west, the longitude must be less than the longitude of Chicago — the west of the prime meridian has longitudes that are negative numbers.</p>
<p>Here is the pseudocode:</p>
<pre><code>SELECT * FROM north_american_cities
WHERE longitude &lt; ${Chicago&#39;s longitude}
</code></pre>
<p>So, what we need to do is somehow get the value of Chicago&#39;s longitude and use it as comparison.<br>It is by itself easy:</p>
<pre><code class="language-sql">SELECT longitude FROM north_american_cities
WHERE city = &#39;Chicago&#39;;
</code></pre>
<p>What we can do is simply put it inside the parenthesis and use it as a value itself, just like a variable:</p>
<pre><code class="language-sql">SELECT * FROM north_american_cities
WHERE longitude &lt; (
    SELECT longitude
    FROM north_american_cities
    WHERE city = &#39;Chicago&#39;
);
</code></pre>
<p>The result is this:</p>
<Table>
|city|country|population|latitude|longitude|
|---|---|---|---|---|
|Guadalajara|Mexico|1500800|20.659699|-103.349609|
|Houston|United States|2195914|29.760427|-95.369803|
|Mexico City|Mexico|8555500|19.432608|-99.133208|
|Phoenix|United States|1513367|33.448377|-112.074037|
|Los Angeles|United States|3884307|34.052234|-118.243685|
|Ecatepec de Morelos|Mexico|1742000|19.601841|-99.050674|
</Table>

<p>Furthermore, we can order the longitudes from west to east using the <code>ORDER BY</code> clause:</p>
<pre><code class="language-sql">SELECT * FROM north_american_cities
WHERE longitude &lt; (
    SELECT longitude
    FROM north_american_cities
    WHERE city = &#39;Chicago&#39;
)
ORDER BY longitude;
</code></pre>
<p>And, voilà:</p>
<Table>
|city|country|population|latitude|longitude|
|---|---|---|---|---|
|Los Angeles|United States|3884307|34.052234|-118.243685|
|Phoenix|United States|1513367|33.448377|-112.074037|
|Guadalajara|Mexico|1500800|20.659699|-103.349609|
|Mexico City|Mexico|8555500|19.432608|-99.133208|
|Ecatepec de Morelos|Mexico|1742000|19.601841|-99.050674|
|Houston|United States|2195914|29.760427|-95.369803|
</Table>

<p><em>The example is taken from <a href="https://sqlbolt.com/lesson/select_queries_review" target="_blank" rel="noopener noreferrer">sqlbolt.com</a></em>.</p>
]]></description>
            <link>https://rivea0.github.io/blog/a-simple-example-of-a-nested-sql-query</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/a-simple-example-of-a-nested-sql-query</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 16 Aug 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A reminder to use single quotes when writing commit messages]]></title>
            <description><![CDATA[<p>Using backticks in the shell results in <em>command expansion</em>, for example:</p>
<pre><code>echo `which cp`
</code></pre>
<p>is the same as </p>
<pre><code>echo $(which cp)
</code></pre>
<p>It finds the directory the <code>cp</code> command is in (executes the <code>which</code> command), and then prints it to the screen.</p>
<p>Normally, when using double quotes, many types of expansions do not work (like word-splitting and brace expansions), but with command expansion, this is not the case.</p>
<p>Commands inside backticks are executed if they are inside double quotes.</p>
<p>When writing a message to <code>git commit</code>, rendering the name of a function in monospace, for example, is easy to do using backticks.</p>
<p>So, my hypothesis is that when I do something like</p>
<pre><code>git commit -m &quot;Add `doThis` function&quot;
</code></pre>
<p>If <code>doThis</code> is a command, it will be executed.</p>
<p>So, if we write something like:</p>
<pre><code>git commit -m &quot;Add `which cp` thing&quot;
</code></pre>
<p>It will replace it with the directory that <code>cp</code> is in, so that our commit message will look like:</p>
<pre><code>Add /bin/cp thing
</code></pre>
<p>In fact, after trying it, it turns out to be true, and this <a href="https://stackoverflow.com/a/71155997" target="_blank" rel="noopener noreferrer">Stack Overflow answer</a> has a nice short explanation.</p>
<p>Single quotes, on the other hand, suppress all expansions, so if written like this:</p>
<pre><code>git commit -m &#39;Add `which cp` thing&#39;
</code></pre>
<p>It won&#39;t execute <code>which cp</code>, but write it as it is: </p>
<pre><code>Add `which cp` thing
</code></pre>
<p>So, I think it is safer to use single quotes, whether you want to use a code block a la markdown styling or not.</p>
<hr>
<p><em>This enlightenment is thanks to the &quot;Seeing the World as the Shell Sees It&quot; chapter from William E. Shotts&#39; book <a href="https://archive.org/details/tlcl-19.01/page/76/mode/2up" target="_blank" rel="noopener noreferrer">The Linux Command Line: A Complete Introduction</a>.</em></p>
]]></description>
            <link>https://rivea0.github.io/blog/a-reminder-to-use-single-quotes-when-writing-commit-messages</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/a-reminder-to-use-single-quotes-when-writing-commit-messages</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 13 Jul 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Excluding files (and folders) with `git add`]]></title>
            <description><![CDATA[<p>When you&#39;re using <code>git add</code>, there is a chance that you might be in a situation where you want to include a bunch of files (or folders) but exclude only some of them. Adding each file one by one manually is, of course, unthinkable, but thankfully there is a very short and sweet way to do it. </p>
<p>Here comes the magical command:</p>
<pre><code>git add -A &#39;:!&lt;file_path&gt;&#39;
</code></pre>
<p>In my case, I had to rename a lot of folders, and wanted to <code>git add</code> them all at once, but exclude one of the untracked folders and a couple of other modified files. </p>
<p>Besides tons of other deleted files, <code>git status</code> was showing this:</p>
<p><img src="/blog/post-images/2023-07-03/git-add-screenshot0.png" alt="Changes not staged for commit and untracked files"></p>
<p>Since I wanted to exclude only the <code>list-ops</code> folder and the <code>wordy</code> files, I had to use the command:</p>
<pre><code>git add -A &#39;:!list-ops&#39; &#39;:!wordy/wordy.py&#39; &#39;:!wordy/wordy_test.py&#39;
</code></pre>
<p>And, it worked 🎉:</p>
<p><img src="/blog/post-images/2023-07-03/git-add-screenshot.png" alt="Changes to be commited with those not staged for commit and untracked files"></p>
<p>All thanks to <a href="https://kodewithchirag.com/easy-way-to-exclude-files-during-git-add" target="_blank" rel="noopener noreferrer">Chirag Chhuchha&#39;s blog post</a>.</p>
]]></description>
            <link>https://rivea0.github.io/blog/excluding-files-with-git-add</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/excluding-files-with-git-add</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 03 Jul 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[MongoDB Aggregation Pipeline Stages 101]]></title>
            <description><![CDATA[<p>In database management, <strong>aggregation</strong> is defined as (to quote Wikipedia):</p>
<blockquote>
<p>a function where the values of multiple rows are grouped together to form a single summary value.</p>
</blockquote>
<p>Simply, it is the <em>collection and summary of data</em>.</p>
<p>In MongoDB, an <strong>aggregation pipeline</strong> is a <em>series of stages completed on the data in order</em>, where a <strong>stage</strong> is a built-in method that does not permanently alter the data.<br>Aggregation pipeline can be used for many tasks like filtering or grouping data.</p>
<p>To use an aggregation operation, we can use <code>.aggregate()</code> method on the collection, like below:</p>
<pre><code class="language-js">db.collection.aggregate([
  {
    $match: {
      { size: &quot;small&quot; }
    },
    ...
  }
])
</code></pre>
<p>In this example, <code>.aggregate()</code> is the <em>aggregation method</em>, <code>$match</code> is the <em>aggregation stage</em>, and <code>{ size: &quot;small&quot; }</code> is the <em>expression</em> we use to query the collection where the <code>size</code> field is <code>&quot;small&quot;</code>. After <code>$match</code>, we can continue listing stages in the aggregation pipeline. Of course, since this is a pipeline, and each stage forwards the values on to the next stage, the ordering of stages matters.</p>
<p>Let&#39;s take a look at some of the aggregation pipeline stages we can use in MongoDB.</p>
<h3>Using <code>$match</code></h3>
<p><code>$match</code> filters the documents that match a given expression, and pass them to the next stage in the pipeline.<br>Since it filters the documents, it reduces the number of documents to operate on, and therefore lessens the amount of processing required. So, it is better if we use it early in our pipeline.</p>
<h3>Using <code>$group</code></h3>
<p><code>$group</code>, groups the documents by a given group key, and for each unique value of a group key, the output is only one document.</p>
<p>Let&#39;s look at an example data first. To see a sample document in a given collection, we can use <code>.findOne()</code> method.</p>
<p>Let&#39;s say we&#39;re inside a <code>bird_data</code> database and want to look at how a document looks like in the <code>sightings</code> collection:</p>
<pre><code class="language-js">db.sightings.findOne()
</code></pre>
<p>A sample document is returned:</p>
<pre><code class="language-js">{
  _id: ObjectId(&quot;62cf32bdcfe5bbb25ee815fc&quot;),
  species_common: &#39;Eastern Bluebird&#39;,
  species_scientific: &#39;Sialia sialis&#39;,
  date: ISODate(&quot;2022-01-18T18:24:00.000Z&quot;),
  location: { type: &#39;Point&#39;, coordinates: [ 40, -73 ] }
}
</code></pre>
<p>Let&#39;s now use an aggregation pipeline:</p>
<pre><code class="language-js">db.sightings.aggregate([
  {
    $match: {
      &quot;species_common&quot;: &quot;Eastern Bluebird&quot;
    }
  }, 
  {
    $group: {
      _id: &quot;$location.coordinates&quot;, 
      number_of_sightings: { $count: { } }
    }
  }
])
</code></pre>
<p>In this example, we first want to filter a specific bird species, Eastern Bluebird. We do that with <code>$match</code>.<br>Then we create a <code>$group</code> stage where we group the documents based on location coordinates. And, within the groups, we create a field called <code>number_of_sightings</code> to show how many documents there are in each group.</p>
<p>The output looks like this:</p>
<pre><code class="language-js">[
  { _id: [ 40, -74 ], number_of_sightings: 3 },
  { _id: [ 41, -74 ], number_of_sightings: 1 },
  { _id: [ 40, -73 ], number_of_sightings: 1 }
]
</code></pre>
<h3>Using <code>$sort</code></h3>
<p><code>$sort</code> does what you think it does, it sorts the documents. If the value given is <code>1</code>, it sorts in the ascending order, if the value is <code>-1</code> —you guessed it— it sorts in the descending order.</p>
<h3>Using <code>$limit</code></h3>
<p><code>$limit</code> is also clear, it limits the number of documents to show.<br>We know that the order is important, and here is a chance to remember that. Say, we are going to use both <code>$sort</code> and <code>$limit</code> stages. If we sort before limit, the output will be the first <code>&lt;number-of-limit&gt;</code> documents on sorted data. Otherwise, if we limit before sorting, it will return the sorted version of the first <code>&lt;number-of-limit&gt;</code> documents in our collection.</p>
<p>Let&#39;s see an example of them together:</p>
<pre><code class="language-js">db.sightings.aggregate([
  {
    $sort: { &quot;location.latitude&quot;: 1 } 
  }, 
  {
    $limit: 4
  }
])
</code></pre>
<p>Here, we have a <code>$sort</code> stage that sorts the data according to the <code>location.latitude</code> field in the ascending order. <em>Then</em>, we limit the number of documents to 4.</p>
<h3>Using <code>$set</code></h3>
<p>To create new fields, or change the value of existing fields, we can use the <code>$set</code> stage.</p>
<pre><code class="language-js">db.birds.aggregate([
  {
    $set: { &quot;class&quot;: &quot;bird&quot; }
  }
])
</code></pre>
<p>It simply adds the field of <code>class</code> with the value of <code>&quot;bird&quot;</code> to the returned document.</p>
<h3>Using <code>$count</code></h3>
<p><code>$count</code> creates a new document with the given field name with the value of the number of documents at that stage in the aggregation pipeline.</p>
<p>An example usage after the <code>$match</code> stage:</p>
<pre><code class="language-js">db.sightings.aggregate([ 
  { 
    $match: { 
      date: { 
        $gt: ISODate(&#39;2022-01-01T00:00:00.000Z&#39;), 
        $lt: ISODate(&#39;2023-01-01T00:00:00.000Z&#39;) 
      }, 
      species_common: &#39;Eastern Bluebird&#39; 
    } 
  }, 
  { 
    $count: &#39;bluebird_sightings_2022&#39; 
  } 
])
</code></pre>
<h3>Using <code>$project</code></h3>
<p>We can choose to include or exclude fields with the <code>$project</code> stage. It is similar to the <code>.find()</code> method, where the second value we pass is the <em>projection</em>. The value <code>1</code> indicates that we want that field to be included, <code>0</code> indicates that we want it to be excluded. </p>
<p><code>$project</code> stage is more appropriate to use last in the aggregation pipeline, as it just <em>projects</em> the given fields.</p>
<p>Here is an example where we only want the fields of <code>date</code>, <code>species_common</code>, and <code>_id</code> to be shown:</p>
<pre><code class="language-js">db.sightings.aggregate([
  {
    $project: { &quot;date&quot;: 1, &quot;species_common&quot;: 1, _id: 1 } 
  }
])
</code></pre>
<h3>Using <code>$out</code></h3>
<p><code>$out</code> is a stage that you can only use as the last one, it just writes the documents in an aggregation pipeline into a collection. If the collection exists, it overwrites it.</p>
<pre><code class="language-js">db.sightings.aggregate([
  {
    $match: {
      date: {
        $gte: ISODate(&quot;2022-01-01T00:00:00.000Z&quot;)
      }
    }
  }, 
  {
    $out: &quot;sightings_2022&quot;
  }
])
</code></pre>
<p>There are a lot of aggregation pipeline stages to use, and as always, the best place to look for and learn about them is the <a href="https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/" target="_blank" rel="noopener noreferrer">official documentation</a>.</p>
<p>Happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/mongodb-aggregation-pipeline-stages-101</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/mongodb-aggregation-pipeline-stages-101</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Fri, 05 May 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Learning React's `useReducer` with a Very Basic Example]]></title>
            <description><![CDATA[<p>If you are setting the value of a state variable in multiple places in your React application, the state hook <code>useReducer</code> might be another option to consider.</p>
<p>The first example that I&#39;m going to use is an extremely basic and somewhat stupid one, nevertheless, I think we need the simplest examples when learning something new. And, this is by no means how <code>useReducer</code> should be used — <strong>quite the opposite</strong>, for simple state management, <code>useState</code> is more than enough, and you absolutely don&#39;t even need a reducer at all. This is just for <em>&quot;explain me like I&#39;m five&quot; kind of</em> demonstration purposes.</p>
<p>With that said, now let&#39;s say we have this piece of code:</p>
<pre><code class="language-jsx">import { useState } from &#39;react&#39;;

export default function App() {
  const [text, setTextValue] = useState(&#39;&#39;);

  function handleChange(e) {
    setTextValue(e.target.value);
  }

  function handleClearClick() {
    setTextValue(&#39;&#39;);
  }

  return (
    &lt;div&gt;
      &lt;InputForm
        text={text}
        handleChange={handleChange}
        handleClearClick={handleClearClick}
      /&gt;
    &lt;/div&gt;
  );
}

function InputForm({ text, handleChange, handleClearClick }) {
  return (
    &lt;form onClick={e =&gt; e.preventDefault()}&gt;
      &lt;input type=&quot;text&quot; name=&quot;text&quot; value={text} onChange={handleChange} /&gt;
      &lt;ClearButton onClick={handleClearClick} /&gt;
    &lt;/form&gt;
  );
}

function ClearButton({ onClick }) {
  return (
    &lt;button onClick={onClick} type=&quot;button&quot;&gt;
      Clear
    &lt;/button&gt;
  );
}
</code></pre>
<p>What it is, is obvious, the <code>App</code> component renders the <code>InputForm</code>, which returns a form element that has an <code>&lt;input&gt;</code> field, and a <code>ClearButton</code> component as a button. </p>
<p>Now imagine for a moment that you&#39;ve read about <a href="https://react.dev/learn/extracting-state-logic-into-a-reducer" target="_blank" rel="noopener noreferrer">extracting state logic into a reducer</a> for the first time, and are still a little confused. Let&#39;s see how we might use it for our code above.</p>
<pre><code class="language-jsx">import { useReducer } from &#39;react&#39;;

export default function App() {
  const [text, dispatch] = useReducer(textReducer, &#39;&#39;);

  function handleChange(e) {
    dispatch({
      type: &#39;changed&#39;,
      text: e.target.value,
    });
  }

  function handleClearClick() {
    dispatch({
      type: &#39;clear_click&#39;,
    });
  }

  return (
    &lt;div&gt;
      &lt;InputForm
        text={text}
        handleChange={handleChange}
        handleClearClick={handleClearClick}
      /&gt;
    &lt;/div&gt;
  );
}

function InputForm({ text, handleChange, handleClearClick }) {
  return (
    &lt;form onClick={e =&gt; e.preventDefault()}&gt;
      &lt;input type=&quot;text&quot; name=&quot;text&quot; value={text} onChange={handleChange} /&gt;
      &lt;ClearButton onClick={handleClearClick} /&gt;
    &lt;/form&gt;
  );
}

function ClearButton({ onClick }) {
  return (
    &lt;button onClick={onClick} type=&quot;button&quot;&gt;
      Clear
    &lt;/button&gt;
  );
}

function textReducer(state, action) {
  switch (action.type) {
    case &#39;changed&#39;: {
      return action.text;
    }
    case &#39;clear_click&#39;: {
      return &#39;&#39;;
    }
    default:
      throw new Error(&#39;error: this shouldn\&#39;t have happened&#39;);
  }
}
</code></pre>
<p><em>Note that components usually have to be on their own files, but we use all of them together in this example for simplicity&#39;s sake.</em></p>
<p>You can see how unpleasant this is, especially with the unused variable <code>state</code> inside <code>textReducer()</code>. It is because we&#39;re missing the point, the purpose of a reducer is to accumulate actions over time. From the React docs:</p>
<blockquote>
<p>[a reducer] takes the <em>result so far</em> and the <em>current item,</em> then it returns the <em>next result.</em></p>
</blockquote>
<p>The example above has nothing to do with the previous state, each time it is set anew. But, you can understand the idea, after all. We used the <code>dispatch</code> function inside our handler functions, and give it an <a href="https://react.dev/reference/react/useReducer#dispatch-parameters" target="_blank" rel="noopener noreferrer"><em>action object</em></a> that has information about what happened. And, inside <code>handleChange</code>, we also provided <code>e.target.value</code> as the value of <code>text</code> property.</p>
<p>Maybe a better example could be a simple counter that actually needs the previous state. Let&#39;s see how we can do it with <code>useState</code> first:</p>
<pre><code class="language-jsx">import { useState } from &#39;react&#39;;

export default function Counter() {
  const [count, setCount] = useState(0);

  function increment() {
    setCount(prevCount =&gt; prevCount + 1);
  }

  function decrement() {
    setCount(prevCount =&gt; prevCount - 1);
  }

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>It is self-explanatory. Now let&#39;s see how we might do it with <code>useReducer</code>:</p>
<pre><code class="language-jsx">import { useReducer } from &#39;react&#39;;

export default function Counter() {
  const [count, dispatch] = useReducer(countReducer, 0);

  function increment() {
    dispatch({
      type: &#39;increment&#39;,
    });
  }

  function decrement() {
    dispatch({
      type: &#39;decrement&#39;,
    });
  }

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}

function countReducer(state, action) {
  switch (action.type) {
    case &#39;increment&#39;: {
      return state + 1;
    }
    case &#39;decrement&#39;: {
      return state - 1;
    }
    default: {
      throw new Error(&#39;error: this shouldn\&#39;t have happened&#39;);
    }
  }
}
</code></pre>
<p>Realize that we don&#39;t have to separately define <code>increment</code> and <code>decrement</code> functions, we can pass them directly to <code>onClick</code>:</p>
<pre><code class="language-jsx">&lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;
</code></pre>
<pre><code class="language-jsx">&lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;
</code></pre>
<p>Let&#39;s now compare both versions. This is the <code>useState</code> version:</p>
<pre><code class="language-jsx">import { useState } from &#39;react&#39;;

export default function CounterWithState() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>And, this is the <code>useReducer</code> one:</p>
<pre><code class="language-jsx">import { useReducer } from &#39;react&#39;;

export default function CounterWithReducer() {
  const [count, dispatch] = useReducer(countReducer, 0);
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}

function countReducer(state, action) {
  switch (action.type) {
    case &#39;increment&#39;: {
      return state + 1;
    }
    case &#39;decrement&#39;: {
      return state - 1;
    }
    default: {
      throw new Error(&#39;error: this shouldn\&#39;t have happened&#39;);
    }
  }
}
</code></pre>
<p>Inside <code>countReducer</code>, returning something like <code>state + 1</code> is a bit ambiguous, so let&#39;s define our state as an object instead. In that case, the final code should look like this:</p>
<pre><code class="language-jsx">import { useReducer } from &#39;react&#39;;

export default function CounterWithReducer() {
  const initialState = { count: 0 };
  const [state, dispatch] = useReducer(countReducer, initialState);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}

function countReducer(state, action) {
  switch (action.type) {
    case &#39;increment&#39;: {
      return { count: state.count + 1 };
    }
    case &#39;decrement&#39;: {
      return { count: state.count - 1 };
    }
    default: {
      throw new Error(&#39;error: this shouldn\&#39;t have happened&#39;);
    }
  }
}
</code></pre>
<p>Even though <code>useState</code> and <code>useReducer</code> <a href="https://react.dev/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer" target="_blank" rel="noopener noreferrer">are equivalent</a>, <code>useReducer</code> can be used especially when you have to update the state in a lot of places, and for refactoring, but in the most simple cases, <code>useState</code> might be a better option. </p>
<p>Lastly, if we try to implement the <code>useReducer</code> hook ourselves, this is how it might look like: </p>
<pre><code class="language-jsx">import { useState } from &#39;react&#39;;

export function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch(action) {
    setState(s =&gt; reducer(s, action));
  }

  return [state, dispatch];
}
</code></pre>
<p>There are a lot of places where you can learn about <code>useReducer</code>, but as always, the first place to go is <a href="https://react.dev/reference/react/useReducer" target="_blank" rel="noopener noreferrer">the official docs</a> when learning about something new. I&#39;ve found <a href="https://dmitripavlutin.com/react-usereducer/" target="_blank" rel="noopener noreferrer">Dmitri Pavlutin&#39;s blog post</a> very helpful as well. As he also points out, <code>useReducer</code> introduces a lot more complexity, so, you&#39;re probably good with <code>useState</code> for simple state management.</p>
]]></description>
            <link>https://rivea0.github.io/blog/learning-reacts-useReducer-with-a-very-simple-example</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/learning-reacts-useReducer-with-a-very-simple-example</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 08 Apr 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving Some Config Issues for Testing React]]></title>
            <description><![CDATA[<p>Now that the <a href="https://github.com/reactjs/react.dev/pull/5487#issuecomment-1409720741" target="_blank" rel="noopener noreferrer">Create React App is already dead</a> (and, <a href="https://react.dev/" target="_blank" rel="noopener noreferrer">the new React docs</a> don&#39;t even mention it), when using a great tool like <a href="https://vitejs.dev/" target="_blank" rel="noopener noreferrer">Vite</a>, you might realize that it does not come with the usual testing libraries included as opposed to Create React App. While there is <a href="https://vitest.dev/guide/" target="_blank" rel="noopener noreferrer">Vitest</a> that is powered by Vite itself for unit testing, let&#39;s take a look at solving some basic configuration problems for Vite using <a href="https://jestjs.io/" target="_blank" rel="noopener noreferrer">Jest</a> and <a href="https://testing-library.com/" target="_blank" rel="noopener noreferrer">Testing Library</a>.</p>
<p><em>Note that this post is written assuming that you already have a working app, but want to try using Jest and Testing Library. This is of course not the way of test-driven development, but hey, we&#39;re just learning.</em></p>
<p>The very first thing is to install Jest:</p>
<pre><code class="language-shell">npm install --save-dev jest
</code></pre>
<p>Since we are using Testing Library, we need to install it as well:</p>
<pre><code class="language-shell">npm install --save-dev @testing-library/react
</code></pre>
<p>Of course, we need to add <code>&quot;test&quot;: &quot;jest&quot;</code> to <code>&quot;scripts&quot;</code> in our <code>package.json</code> so that we can use <code>npm run test</code> command:</p>
<pre><code class="language-package.json">&quot;scripts&quot;: {
  &quot;test&quot;: &quot;jest&quot;
}
</code></pre>
<p>Note that if you are using <code>eslint</code>, we need to add the piece below to our <code>.eslintrc.json</code> (or, your choice of <code>eslint</code> config file) so that you don&#39;t get any <code>undefined</code> errors:</p>
<pre><code class="language-.eslintrc.json">&quot;env&quot;: {
  &quot;jest&quot;: true
}
</code></pre>
<p>Considering that we already have an <code>App.jsx</code>, and created an <code>App.test.jsx</code> with the most basic form of something like this:</p>
<pre><code class="language-App.test.jsx">import React from &#39;react&#39;;
import { render, screen } from &#39;@testing-library/react&#39;;

import App from &#39;./App&#39;;

describe(&#39;App&#39;, () =&gt; {
  it(&#39;renders App component&#39;, () =&gt; {
    render(&lt;App /&gt;);
    screen.getByRole(&#39;heading&#39;, { level: 1, name: &#39;This is a heading&#39; });
  });
});
</code></pre>
<p>If we are quick to run <code>npm run test</code>, we might get some errors related to encountering an &quot;unexpected token.&quot; Such as this one:</p>
<p><img src="/blog/post-images/2023-04-03/jest-unexpected-token.png" alt="Jest error: Jest encountered an unexpected token"></p>
<p>The hint might be related to Babel, indeed, we need to install Babel to get things working:</p>
<pre><code class="language-shell">npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
</code></pre>
<p>Also, we need to create a <code>babel.config.json</code> and include this in it:</p>
<pre><code class="language-babel.config.json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;targets&quot;: {
          &quot;node&quot;: &quot;current&quot;
        }
      }
    ],
    [&quot;@babel/preset-react&quot;, {&quot;runtime&quot;: &quot;automatic&quot;}]
  ]
}
</code></pre>
<p>Now, everything is almost okay, but not quite. Let&#39;s run <code>npm run test</code> again, and take a look at what we might see this time:</p>
<p><img src="/blog/post-images/2023-04-03/jest-jsdom.png" alt="Jest error: Consider using the &quot;jsdom&quot; test environment."></p>
<p>Now, for versions previous to 28, adding this to <code>package.json</code> would have been enough:</p>
<pre><code class="language-package.json">&quot;jest&quot;: {
  &quot;testEnvironment&quot;: &quot;jsdom&quot;
}
</code></pre>
<p>But, we need to install <code>jest-environment-jsdom</code> explicitly in order for this to work because <a href="https://jestjs.io/blog/2022/04/25/jest-28#breaking-changes" target="_blank" rel="noopener noreferrer">Jest removed it from the default package</a>.  See <a href="https://stackoverflow.com/a/69228464" target="_blank" rel="noopener noreferrer">this Stack Overflow answer</a> for a better explanation.</p>
<p>So, let&#39;s install it as well:</p>
<pre><code class="language-shell">npm install --save-dev jest-environment-jsdom
</code></pre>
<p>Now, everything is alright.<br>Perhaps.</p>
<p>If you have an <code>import</code> statement for, say, a CSS file like the one below in one of your files, you might encounter yet another <code>Jest encountered an unexpected token</code> error:</p>
<pre><code class="language-js">import &#39;katex/dist/katex.min.css&#39;; // Or, any kind of css file
</code></pre>
<p>We can use a proxy to mock CSS modules. And yes, we can install yet another package for that:</p>
<pre><code class="language-shell">npm install --save-dev identity-obj-proxy
</code></pre>
<p>We also need to update our config. You can add the below in our <code>package.json</code>&#39;s <code>jest</code> configuration (depending on the files you have, you might add additional extensions):</p>
<pre><code class="language-package.json">moduleNameMapper: {
  &quot;\\.(css|less)$&quot;: &quot;identity-obj-proxy&quot;
}
</code></pre>
<p>It is what the <a href="https://jestjs.io/docs/webpack#mocking-css-modules" target="_blank" rel="noopener noreferrer">Jest docs say about mocking CSS modules</a> as well.</p>
<p>If you don&#39;t like your Jest configs being in <code>package.json</code>, you can create a whole new <code>jest.config.json</code> as its own configuration file. This is how it looks like for now:</p>
<pre><code class="language-jest.config.json">{
  &quot;testEnvironment&quot;: &quot;jsdom&quot;,
  &quot;moduleNameMapper&quot;: {
    &quot;\\.(css|less)$&quot;: &quot;identity-obj-proxy&quot;
  }
}
</code></pre>
<p>And, for now, it is enough to get going. Of course, there is never a catch-all solution for all kinds of problems, but it works for my current setting, and I hope someone might find it helpful as well.</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-some-config-issues-for-testing-react</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-some-config-issues-for-testing-react</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Mon, 03 Apr 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[async and await: Promises Simplified]]></title>
            <description><![CDATA[<p><a href="https://rivea0.github.io/blog/javascript-promises/" target="_blank" rel="noopener noreferrer">Promises in JavaScript</a> were there to save the day from being stuck in callback hell. But the thing is, <code>.then()</code> chains could eventually turn into a hell of their own. Since the human mind works synchronously, it might be hard to grasp asynchronous code when it becomes too tangled. Luckily, we have yet another thing to save the day — <code>async</code> and <code>await</code>!</p>
<p>We can write asynchronous functions that look like synchronous code with the keyword <code>async</code> in front of the <code>function</code> keyword:</p>
<pre><code class="language-javascript">async function doStuff { /* body */ }
</code></pre>
<p>Async functions always return a promise implicitly, even if you do something like this:</p>
<pre><code class="language-javascript">async function getTheMeaning() {
  return 42;
}
</code></pre>
<p>What is returned will be a promise with the resolved value of <code>42</code>.<br>It might look similar to the piece of code below (there will come a &quot;<em>but</em>&quot;):  </p>
<pre><code class="language-javascript">function getTheMeaning() {
  return Promise.resolve(42);
}
</code></pre>
<p><em>But</em>, they are not equivalent. The subtlety lies in the references these two functions will point to for a given promise. For example, let&#39;s create a new promise that both the plain function and the async function will resolve:</p>
<pre><code class="language-javascript">let theMeaning = new Promise((resolve, reject) =&gt; {
  resolve(42);
});

function plainGetTheMeaning() {
  return Promise.resolve(theMeaning);
}

async function asyncGetTheMeaning() {
  return theMeaning;
}
</code></pre>
<p>When we inspect if they are pointing to the same value, we see that they behave differently:</p>
<pre><code class="language-javascript">console.log(theMeaning === plainGetTheMeaning()); // true
console.log(theMeaning === asyncGetTheMeaning()); // false
</code></pre>
<p>So, in fact, maybe it is better to think of an <code>async</code> function as a function that returns a promise, and wrapped around our original function, like this one:</p>
<pre><code class="language-javascript">function getTheMeaning() {
  return new Promise(function(resolve, reject) {
    try {
      resolve((function() { return 42; } )()); 
    }
    catch(e) {
      reject(e);
    }
  });
}
</code></pre>
<p>Now in this case, we see that it is not like <code>plainGetTheMeaning()</code>, and much more like the <code>async</code> function itself when it comes to references:</p>
<pre><code class="language-javascript">let theMeaning = new Promise((resolve, reject) =&gt; {
  resolve(42);
});

function getTheMeaning() {
  return new Promise(function(resolve, reject) {
    try {
      resolve((function() { return 42; } )());
    }
    catch(e) {
      reject(e);
    }
  });
}

console.log(theMeaning === getTheMeaning()); // false
</code></pre>
<p><code>async</code> functions can also have <code>await</code> expressions. In fact, <code>await</code> can only be used within <code>async</code> functions (as long as it is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener noreferrer">not inside a module</a>).</p>
<p><code>await</code> basically waits for a promise to settle, and returns the fulfillment value of that promise. A simple example:</p>
<pre><code class="language-javascript">async function getToDo(toDoId) {
  let response = await fetch(`https://jsonplaceholder.typicode.com/todos/${toDoId}`);
  /*
  toDo is going to be the json object:
  { userId: 1, id: 1, title: &#39;delectus aut autem&#39;, completed: false }
  */
  let toDo = await response.json();
  return toDo.completed;
}
</code></pre>
<p>Here, the return value itself will be a promise, so it feels like we need to use <code>await</code> for it. Like this:</p>
<pre><code class="language-javascript">let isCompleted = await getToDo(1); // Not really...
</code></pre>
<p>But remember, <code>await</code> can be used inside another <code>async</code> function! Now that we can&#39;t use <code>await</code>, we need to handle this thing with our good friends <code>.then()</code> and <code>.catch()</code>:</p>
<pre><code class="language-javascript">getToDo(1)
  .then(isCompleted =&gt; console.log(isCompleted))
  .catch(e =&gt; { throw e });
</code></pre>
<p>The important thing to point out is that <code>await</code> just waits for its promise to settle and pauses the execution of the function. It is what <code>await</code> does, it just waits. So if there are multiple <code>await</code> expressions in succession, each of them will be executed sequentially, instead of running in parallel. It could be a good thing if each of them depends on the expression before it, but when it is not the case, it might create a performance issue where the execution of the code is slower.</p>
<p>In the <code>getToDo()</code> example, <code>todo</code> needs <code>response</code>, so it makes sense to use <code>await</code> one after the other. But, let&#39;s say we have multiple URLs to fetch, multiple <code>toDos</code>, and they are all independent of each other. In that case, we want them to run in parallel. We can use <code>Promise.all()</code> with <code>await</code> to do that:</p>
<pre><code class="language-javascript">async function getToDos(toDoIds) {
  let responses = toDoIds.map(async (id) =&gt; await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`));
  let [response1, response2, response3] = await Promise.all(responses);
  let toDos = await Promise.all([response1.json(), response2.json(), response3.json()])
  return toDos.map(toDo =&gt; toDo.completed);
}

let ids = [1, 2, 3];

getToDos(ids)
  .then(toDosCompletedStatus =&gt; console.log(toDosCompletedStatus))
  .catch(e =&gt; { throw e });
</code></pre>
<p>Inside <code>getToDos()</code>, it seems like a lot going on, but it is actually simple to reason about. We take an array of <code>ids</code> as argument, and map them to their <code>fetch</code> responses of their corresponding URLs. Here, notice that we use an arrow function inside <code>.map()</code> that is defined as <code>async</code>.<br>Then, we use <code>await Promise.all(responses)</code> to get the fulfillment values of <code>responses</code>. After that, we get each response&#39;s <code>.json()</code> value, since <code>.json()</code> returns a promise, we again use <code>Promise.all()</code> with <code>await</code>. At this point, what we have is the fulfillment values of <code>toDos</code>, and we map them to the <code>completed</code> property of each. </p>
<p>And, here is the beauty of <code>async</code> and <code>await</code>, our code looks like it is synchronous, hence easier to read and think about.</p>
<p>Although using <code>async</code> and <code>await</code> is just a &quot;better&quot; way to use promises, and there is almost no difference between them, <code>async</code> and <code>await</code> might have a slight performance advantage when it comes to <a href="https://v8.dev/" target="_blank" rel="noopener noreferrer">V8 JavaScript engine</a> as the stack trace is not captured and stored when using <code>await</code>. Read more about it here: <a href="https://mathiasbynens.be/notes/async-stack-traces" target="_blank" rel="noopener noreferrer">https://mathiasbynens.be/notes/async-stack-traces</a></p>
<p>We have seen that promises were there to save us from callback hell, and that async functions make our code even better and simpler for us to read and write. Remember that there is always a &quot;better&quot; solution, depending on how you look at it, and of course, there is always the <a href="https://tc39.es/ecma262/" target="_blank" rel="noopener noreferrer">spec</a> and perhaps the friendlier <a href="https://developer.mozilla.org/en-US/" target="_blank" rel="noopener noreferrer">docs</a> to consult. 💜</p>
]]></description>
            <link>https://rivea0.github.io/blog/async-and-await-promises-simplified</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/async-and-await-promises-simplified</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 07 Mar 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[JavaScript Promises]]></title>
            <description><![CDATA[<p>Pour a hot cup of coffee, and find a comfy chair, because it is time for learning about promises in JavaScript!<br>First off, let&#39;s take a look at the <em>shape</em> of the code below: </p>
<pre><code class="language-javascript">fs.readdir(source, function (err, files) {
  if (err) {
    console.log(&#39;Error finding files: &#39; + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log(&#39;Error identifying file size: &#39; + err)
        } else {
          console.log(filename + &#39; : &#39; + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log(&#39;resizing &#39; + filename + &#39;to &#39; + height + &#39;x&#39; + height)
            this.resize(width, height).write(dest + &#39;w&#39; + width + &#39;_&#39; + filename, function(err) {
              if (err) console.log(&#39;Error writing file: &#39; + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
</code></pre>
<p>This is an example of <a href="http://callbackhell.com/" target="_blank" rel="noopener noreferrer">callback hell</a> ― in fact, taken directly from that site. No one certainly wants to read, let alone write, such code. One clean way to deal with situations like these is through using promises. But, what is a <em>promise</em> in the first place?</p>
<p>Let&#39;s take a look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener noreferrer">MDN</a>:</p>
<blockquote>
<p>A <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer"><code>Promise</code></a> is an object representing the eventual completion or failure of an asynchronous operation.</p>
</blockquote>
<p>Sounds clear enough. But, is it?</p>
<p>Imagine for a second the everyday promises that you make to someone. It could be anything; let&#39;s say that you have promised your friend to call them as soon as you are available.</p>
<p>Now, one of three things can happen. They might still hold on to your promise, waiting for your call. Or, you might actually call them and fulfill your promise, showing how good of a friend you are. Or, you might outright reject to call them back, breaking your promise. </p>
<p>Well, how your friendships go in terms of promises is up to you, but the idea is similar with using promises in JavaScript; a promise has one of three states:</p>
<ul>
<li><strong>pending</strong>: the initial state.</li>
<li><strong>fulfilled</strong>: a successful operation.</li>
<li><strong>rejected</strong>: a failed operation.</li>
</ul>
<p>Let&#39;s take a look at this example:</p>
<pre><code class="language-js">let isCloseFriend = true;

let goingToCallFriend = new Promise((resolve, reject) =&gt; {
  if (isCloseFriend) {
    resolve(&#39;Hello, friend!&#39;);
  } else {
    reject(new Error(&#39;I don\&#39;t want to talk.&#39;));
  }
});

goingToCallFriend
  .then((fulfilled) =&gt; { console.log(fulfilled); })
  .catch((error) =&gt; { console.log(error); });
</code></pre>
<p>Here, we define a global variable (for this example) called <code>isCloseFriend</code>, and a <code>Promise</code> object <code>goingToCallFriend</code>. It takes a function as an argument, an <em>executor</em> function. It accepts two arguments, <code>resolve</code> and <code>reject</code> ― each of which is a function.<br>Inside the body of the <em>executor</em> function, we check if they are a close friend of ours, if so, we resolve the promise with the <code>resolve</code> function, passing it the <em>value</em> <code>&#39;Hello, friend!&#39;</code>. This is the fulfillment value that we want. This is what the docs say about it:</p>
<blockquote>
<p>The argument passed to the resolve function represents the eventual value of the deferred action and can be either the actual fulfillment value or another promise which will provide the value if it is fulfilled.</p>
</blockquote>
<p>Otherwise, if they are not a close friend, we call the <code>reject</code> function to reject it, passing it an error that has a message of <code>&#39;I don\&#39;t want to talk.&#39;</code> (the backslash here is for escaping the quote). </p>
<p>Also from the documentation:</p>
<blockquote>
<p>The argument passed to the reject function is used as the rejection value of the promise. Typically it will be an Error object.</p>
</blockquote>
<Note>
  You can always refer to the docs about [the Promise constructor](https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-executor).
</Note>

<p>Here is the more interesting part, after defining <code>goingToCallFriend</code>, we can invoke other methods on it, like <code>.then()</code> and <code>.catch()</code>. </p>
<p><code>.then()</code> needs a function as argument which itself takes two arguments <code>onFulfilled</code> and <code>onRejected</code>. This might be a bit confusing because we usually see examples of <code>.then()</code> with one argument, the fulfilled value. It is the value that was passed to <code>resolve()</code>. Notice that <code>.then()</code> returns another promise, so we can chain many more methods.</p>
<p><code>.catch()</code> is just a syntactic sugar for  <code>.then()</code> with the first argument <code>undefined</code>, and the second being the reason of error. </p>
<pre><code class="language-js">goingToCallFriend
  .then((fulfilled) =&gt; { console.log(fulfilled); })
  .catch((error) =&gt; { console.log(error); });

// ^ the shorthand for:
goingToCallFriend
  .then((fulfilled) =&gt; { console.log(fulfilled); })
  .then((undefined, error) =&gt; { console.log(error); });
</code></pre>
<p>Finally, there is another instance method called <code>.finally()</code> that will be called no matter what is the state of the promise.</p>
<p>There is one thing to point out that a resolved promise does not necessarily mean a fulfilled promise. A promise can be resolved, but it does not mean that it is fulfilled. Just like life itself.</p>
<p>The famous <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" target="_blank" rel="noopener noreferrer">States and Fates</a> from the original Promises proposal details the terminology, and there is a very helpful <a href="https://stackoverflow.com/a/56850392" target="_blank" rel="noopener noreferrer">Stack Overflow answer</a> that explains this. Here is the table that the author uses in the answer that illustrates it clearly:</p>
<Table>
| action | dependency | state | resolved? | settled? |
| --- | --- | --- | --- | --- | 
| `new Promise((resolve, reject) => ...)` | autonomous | pending | no | no |
| ...`resolve(thenable)` | locked-in | pending* | yes | no |
| ...`resolve(other)` | autonomous | fulfilled | yes | yes |
| ...`reject(any)` | autonomous | rejected | yes | yes |
</Table>

<br />

<blockquote>
<ul>
<li>The thenable is now in control over the future state of our promise object.</li>
</ul>
</blockquote>
<p>Oh, and a thenable is just what it sounds like — you can think of it as an object that has a <code>.then()</code> method that accepts two callbacks, <code>onFulfilled</code> and <code>onRejected</code>.</p>
<p>There are a lot more things to consider when it comes to promises, such as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#static_methods" target="_blank" rel="noopener noreferrer">the static methods</a> like <code>Promise.all()</code>, <code>Promise.any()</code>, but they are kind of self-explanatory and clear in the docs.</p>
<p>One more thing that I want to mention is that <em>promises are guaranteed to be asynchronous</em>. Take a look at the code below:</p>
<pre><code class="language-js">let theMeaning = new Promise((resolve, reject) =&gt; {
  resolve(42)
});

theMeaning.then(value =&gt; console.log(&#39;From inside .then()&#39;));

console.log(&#39;Hello from the outside&#39;);

// &gt; Hello from the outside
// &gt; From inside .then()
</code></pre>
<p><code>&#39;Hello from the outside&#39;</code> gets logged first, even though the promise is already settled.<br>The reason for this has to do with the <a href="https://javascript.info/microtask-queue" target="_blank" rel="noopener noreferrer">microtask queue</a>. What it is might be slightly confusing for absolute beginners, but to very simply put it, a <code>.then()</code> function goes inside the microtask queue and waits for the stack to be cleared. Only after the stack is cleared, it is pushed on to the stack and runs. In this case, <code>theMeaning.then(value =&gt; console.log(&#39;From inside .then()&#39;));</code> can&#39;t run before <code>console.log(&#39;Hello from the outside&#39;);</code> and everything else is popped off the stack.</p>
<p>While we are here, it is important to note that learning about the <a href="https://javascript.info/event-loop" target="_blank" rel="noopener noreferrer">event loop</a> makes everything much clear when it comes it asynchronicity.<br><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener noreferrer">Philip Roberts&#39;s excellent talk</a> is a good starting point, as well as <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif" target="_blank" rel="noopener noreferrer">the JavaScript Visualized article from Lydia Hallie</a>.</p>
<p>There is even more delicious way to work with promises —<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await" target="_blank" rel="noopener noreferrer">async and await</a>— but, that is for another article.<br>Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/javascript-promises</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/javascript-promises</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 05 Mar 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A Quick Refresher on DOM Node Types and Element Node]]></title>
            <description><![CDATA[<p>DOM (Document Object Model) represents the structure of the HTML document in a tree-like model. It contains many types of nodes, <em>some</em> of them are: </p>
<ul>
<li><code>ELEMENT_NODE</code> — an HTML element, for example, a <code>&lt;div&gt;</code>.</li>
<li><code>TEXT_NODE</code> — text content, for example, <code>Hey</code> in <code>&lt;div&gt;Hey&lt;/div&gt;</code>.</li>
<li><code>COMMENT_NODE</code> — a comment, for example, <code>&lt;!-- comment --&gt;</code>.</li>
<li><code>DOCUMENT_NODE</code> — <code>document</code> itself.</li>
<li><code>DOCUMENT_TYPE_NODE</code> — the document type, <code>&lt;!DOCTYPE html&gt;</code>.</li>
</ul>
<p>Other node types can be found <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType" target="_blank" rel="noopener noreferrer">here</a>.</p>
<p>Node types also have values, such as <code>1</code> corresponding to <code>ELEMENT_NODE</code>, <code>3</code> corresponding to <code>TEXT_NODE</code>, <code>8</code> for <code>COMMENT_NODE</code>, <code>9</code> for  <code>DOCUMENT_NODE</code>, and so on.</p>
<p>We can see the type of a node with its aptly named <code>nodeType</code> property. For example, let&#39;s say we have only one <code>&lt;div&gt;</code> inside the <code>&lt;body&gt;</code> of our document (I know, not <em>a real world example</em>, but bear with it):</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;div&gt;Hey&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="language-js">document.querySelector(&#39;div&#39;).nodeType; // 1
document.querySelector(&#39;div&#39;).firstChild.nodeType; // 3
</code></pre>
<p>Since it is an <code>ELEMENT_NODE</code>, the <code>nodeType</code> is <code>1</code>.<br>When we look at the <code>nodeType</code> of its <code>firstChild</code> which is the <code>Hey</code> text, we can see that it is <code>3</code>, which corresponds to a <code>TEXT_NODE</code>.</p>
<Note>
  We can see the text node (which is not an element) because we use the `firstChild` property. If we were to see only the first element child, we could have used the `firstChildElement` property. But, in this case, it would be `null` as our `<div>` does not have any child elements.
</Note>

<p>You can see the properties and methods list of a <code>Node</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node" target="_blank" rel="noopener noreferrer">here</a>.</p>
<p>One thing to mention is that all documents have root nodes that even if the document is blank, they will be there. These root nodes are<br><code>html</code> (<code>document.documentElement</code>), <code>head</code> (<code>document.head</code>), and <code>body</code> (<code>document.body</code>). And, of course, <code>document</code> itself is the root of all nodes.</p>
<Note>
  `document` is a property of the `window` object. Take a look at MDN for more information: https://developer.mozilla.org/en-US/docs/Web/API/Window
</Note>


<h2>Element Nodes</h2>
<p><code>Element</code> represents all element objects. It would be pretty exhausting to list all its properties and methods, since it has a lot of them. You can always refer to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank" rel="noopener noreferrer">MDN</a>.</p>
<p>One interesting aspect is that each element is constructed with a unique constructor. HTML elements inherit from <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" target="_blank" rel="noopener noreferrer"><code>HTMLElement</code> interface</a> (as well as <code>Element</code>, <code>Node</code>, and <code>Object</code>). But, each has their own constructor. For example, <code>&lt;form&gt;</code> element is constructed with <code>HTMLFormElement</code>, <code>&lt;img&gt;</code> element with <code>HTMLImageElement</code>, and so on. Read more about them in <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API#html_element_interfaces_2" target="_blank" rel="noopener noreferrer">here</a>.</p>
<p>We can get all the elements in the document using <code>querySelectorAll</code> method:</p>
<pre><code class="language-js">document.querySelectorAll(&#39;*&#39;);
</code></pre>
<p>It returns a <a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList#static_nodelists" target="_blank" rel="noopener noreferrer">static <code>NodeList</code></a> containing all the elements in the page.</p>
<p>To get all the child elements, we can use <code>children</code> property. Let&#39;s say our <code>body</code> now contains a <code>div</code> element with an <code>img</code> element inside of it:</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;div&gt;Hey
    &lt;img src=&quot;https://unsplash.com/photos/LaNLiftpmQc&quot; alt=&quot;Oxalis triangularis&quot;&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>If we look at the <code>children</code> of our <code>div</code>, it is an <code>HTMLCollection</code> that only contains the <code>img</code> element:</p>
<pre><code class="language-js">document.querySelector(&#39;div&#39;).children;
// -&gt; HTMLCollection { 0: img, length: 1 }
</code></pre>
<p>An <code>HTMLCollection</code> is live, which means that if there is any change in the document, it will be reflected dynamically.</p>
<p>Now, let&#39;s see what happens if we use <code>childNodes</code> property on our <code>div</code>:</p>
<pre><code class="language-js">document.querySelector(&#39;div&#39;).childNodes;
// -&gt; NodeList(3) [ #text, img, #text ]
</code></pre>
<p>Now, it returns a <code>NodeList</code> which is live. It&#39;s clear that our first <code>#text</code> node is <code>Hey</code>,  our <code>img</code> is there, but what about the last <code>#text</code>?</p>
<p>If we take a look at this <code>NodeList</code>, we can see what is going on:</p>
<pre><code class="language-js">0: #text &quot;Hey\n &quot;
1: &lt;img src=&quot;https://images.unsplash.…f64?width=640&amp;height=360&quot; alt=&quot;Oxalis triangularis&quot;&gt;
2: #text &quot;\n &quot;
</code></pre>
<p>Whitespace are also text nodes, and because we use line breaks in our HTML document, it is obvious that they are also counted as text nodes.</p>
<p>This is just a quick reminder of some differences between properties like <code>childNodes</code> and <code>children</code>, as their return values will have items depending on the types of nodes they include.</p>
<p>As always, when in doubt, go to <a href="https://dom.spec.whatwg.org/" target="_blank" rel="noopener noreferrer">the documentation</a>.</p>
]]></description>
            <link>https://rivea0.github.io/blog/a-quick-refresher-on-dom-node-types-and-element-node</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/a-quick-refresher-on-dom-node-types-and-element-node</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 03 Jan 2023 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[CSV Operations 101 — with Python's Own `csv` Module]]></title>
            <description><![CDATA[<p>There is a great chance that you have come across, or have to work with a CSV (comma-separated values) file. A CSV file holds data similar to a spreadsheet. It separates the values with a <em>delimiter</em> character, so it does not always have to be a comma. However, since it is a <em>comma-separated values</em> file, let&#39;s see an example as such:</p>
<pre><code># 📁 students.csv

first,last,house
Harry,Potter,Gryffindor
Hermione,Granger,Gryffindor
Luna,Lovegood,Ravenclaw
Draco,Malfoy,Slytherin
</code></pre>
<p>As in the example above, the very first row (<code>first,last,house</code>) can be used for headers as column names.</p>
<p>Python conveniently has a built-in <code>csv</code> module to work with CSV files in an efficient way. The two basic operations are reading and writing; with Python, we can do these operations using lists (or, more generally, any iterable), or dictionaries.</p>
<h2><code>csv.reader()</code></h2>
<p>To read a CSV file, one option is to use <code>csv.reader()</code> method. Let&#39;s see an example for our simple <code>students.csv</code> file:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;) as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        if row == [&#39;first&#39;, &#39;last&#39;, &#39;house&#39;]:
            continue
        print(f&#39;{row[0]} {row[1]} is in {row[2]}.&#39;)


# Harry Potter is in Gryffindor.
# Hermione Granger is in Gryffindor.
# Luna Lovegood is in Ravenclaw.
# Draco Malfoy is in Slytherin.
</code></pre>
<p>We use a <a href="https://docs.python.org/3/glossary.html#term-context-manager" target="_blank" rel="noopener noreferrer">context manager</a> to open our file. (Note that we do not need to specify the <code>&#39;r&#39;</code> argument as the mode for the reading operation because it is the default; see <a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener noreferrer">the official docs</a>.)<br>When we use <code>csv.reader()</code>, it returns a reader object, which we store in the <code>reader</code> variable. Then, with a <code>for</code> loop, we iterate through each row, which is a list — and, because our first row is actually the headers, we pass that iteration and continue. Actually, <code>csv.DictReader()</code> has better usability for this, which we will see later on. One important point here is that each row is a <code>list</code> containing three elements, and we access them with indexing (<code>row[0]</code>, <code>row[1]</code>, <code>row[2]</code>). This is not the most elegant implementation, but a simple enough example to see how <code>csv.reader()</code> works.</p>
<h2><code>csv.writer()</code></h2>
<p>Let&#39;s say we want to add Ron Weasley to our CSV file, because we want our Golden Trio to be together. Let&#39;s see how we can go about doing it:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;, &#39;a&#39;) as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow([&#39;Ron&#39;, &#39;Weasley&#39;, &#39;Gryffindor&#39;])
</code></pre>
<p>Here, we are again using a context manager to open our CSV file, this time with the <code>&#39;a&#39;</code> argument as the mode for appending to it. After that, we use <code>csv.writer()</code>, passing into it our file object. It returns a writer object, which we store in the <code>writer</code> variable. Then, we call <code>writerow()</code> method to add Ron Weasley. One important thing is that we pass a <code>list</code> as an argument, although it does not have to be a <code>list</code> — we could have used an iterable like a tuple, but using lists is more common.</p>
<p>Now, our file looks like:</p>
<pre><code># 📁 students.csv

first,last,house
Harry,Potter,Gryffindor
Hermione,Granger,Gryffindor
Luna,Lovegood,Ravenclaw
Draco,Malfoy,Slytherin
Ron,Weasley,Gryffindor
</code></pre>
<h2><code>csv.DictReader()</code></h2>
<p>We can improve on our last example for reading our CSV file. Let&#39;s use <code>csv.DictReader()</code> this time:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;) as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        print(f&#39;{row[&quot;first&quot;]} {row[&quot;last&quot;]} is in {row[&quot;house&quot;]}.&#39;)


# Harry Potter is in Gryffindor.
# Hermione Granger is in Gryffindor.
# Luna Lovegood is in Ravenclaw.
# Draco Malfoy is in Slytherin.
# Ron Weasley is in Gryffindor.
</code></pre>
<p>Like <code>csv.reader()</code>, <code>csv.DictReader()</code> returns a reader object, but this time, as the documentation says, it &quot;maps the information in each row to a <code>dict</code> whose keys are given by the optional <em>fieldnames</em> parameter.&quot;<br>If you have realized already, we have not specified the <em>fieldnames</em> parameter, so the first row is used as default fieldnames instead. We can see it with looking at the <code>fieldnames</code> attribute of our reader object:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;) as csvfile:
    reader = csv.DictReader(csvfile)
    print(reader.fieldnames) # [&#39;first&#39;, &#39;last&#39;, &#39;house&#39;]
</code></pre>
<p><code>csv.DictReader()</code> definitely made the code more readable than the previous method before. Let&#39;s see how we can use a dictionary again, this time for writing to our file.</p>
<h2><code>csv.DictWriter()</code></h2>
<p>We have added Ron Weasley to our <code>students.csv</code> before, let&#39;s add another Weasley this time, Ginny. Let&#39;s see how we can do it with <code>csv.DictWriter()</code>:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;, &#39;a&#39;) as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=[&#39;first&#39;, &#39;last&#39;, &#39;house&#39;])
    writer.writerow({&#39;first&#39;: &#39;Ginny&#39;, &#39;last&#39;: &#39;Weasley&#39;, &#39;house&#39;: &#39;Gryffindor&#39;})
</code></pre>
<p>We are again appending to our file, like we did with <code>csv.writer()</code>. We create a writer object with <code>csv.DictWriter()</code>, of course passing into it the file object itself, then assigning the writer object returned to the variable <code>writer</code>. Notice here that we pass an argument called <code>fieldnames</code> as well, which is a list containing, well, the fieldnames. It is not an optional argument, so we have to provide it each time we use <code>csv.DictWriter()</code>.<br>We use the <code>writerow()</code> method again, but this time, we pass it a dictionary whose keys are the fieldnames we have just specified.<br>Now our file looks like this:</p>
<pre><code># 📁 students.csv

first,last,house
Harry,Potter,Gryffindor
Hermione,Granger,Gryffindor
Luna,Lovegood,Ravenclaw
Draco,Malfoy,Slytherin
Ron,Weasley,Gryffindor
Ginny,Weasley,Gryffindor
</code></pre>
<p>Now, what if inside <code>writerow()</code> you pass in a key that is not in fieldnames? Obviously, we will have a <code>ValueError</code>, but let&#39;s see with an example. They say a house is not a home, but imagine that we mistakenly write Gryffindor as Ginny&#39;s <code>home</code>, instead of her <code>house</code> as we have in the <em>fieldnames</em>. Let&#39;s see:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;, &#39;a&#39;) as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=[&#39;first&#39;, &#39;last&#39;, &#39;house&#39;])
    writer.writerow({&#39;first&#39;: &#39;Ginny&#39;, &#39;last&#39;: &#39;Weasley&#39;, &#39;home&#39;: &#39;Gryffindor&#39;})
    

# ValueError: dict contains fields not in fieldnames: &#39;home&#39;
</code></pre>
<p>This actually comes from the optional <code>extrasaction</code> parameter inside <code>csv.DictWriter()</code>. Its default value is <code>&#39;raise&#39;</code>, so when the key is not found in the <em>fieldnames</em>, it raises a <code>ValueError</code>. However, we can force it to ignore it with passing the value <code>&#39;ignore&#39;</code>. So, if we do it:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;, &#39;a&#39;) as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=[&#39;first&#39;, &#39;last&#39;, &#39;house&#39;], extrasaction=&#39;ignore&#39;)
    writer.writerow({&#39;first&#39;: &#39;Ginny&#39;, &#39;last&#39;: &#39;Weasley&#39;, &#39;home&#39;: &#39;Gryffindor&#39;})
</code></pre>
<p>In that case, we would have ignored the key altogether, resulting in our file looking like this:</p>
<pre><code># 📁 students.csv

first,last,house
Harry,Potter,Gryffindor
Hermione,Granger,Gryffindor
Luna,Lovegood,Ravenclaw
Draco,Malfoy,Slytherin
Ron,Weasley,Gryffindor
Ginny,Weasley,
</code></pre>
<p>This is not the wisest decision, though, it is better to have an error in such cases, unless we somehow have a reason to do otherwise.</p>
<p>We can also use the <code>writerows()</code> method, to pass write more than one row. It takes an iterable as argument, so let&#39;s say we have two dictionaries in a list for the Weasley twins, we can add them both at once:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;, &#39;a&#39;) as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=[&#39;first&#39;, &#39;last&#39;, &#39;house&#39;])
    twins = [
        {&#39;first&#39;: &#39;Fred&#39;, &#39;last&#39;: &#39;Weasley&#39;, &#39;house&#39;: &#39;Gryffindor&#39;},
        {&#39;first&#39;: &#39;George&#39;, &#39;last&#39;: &#39;Weasley&#39;, &#39;house&#39;: &#39;Gryffindor&#39;}
    ]
    writer.writerows(twins)
</code></pre>
<p>Now, our file looks like:</p>
<pre><code># 📁 students.csv

first,last,house
Harry,Potter,Gryffindor
Hermione,Granger,Gryffindor
Luna,Lovegood,Ravenclaw
Draco,Malfoy,Slytherin
Ron,Weasley,Gryffindor
Ginny,Weasley,Gryffindor
Fred,Weasley,Gryffindor
George,Weasley,Gryffindor
</code></pre>
<h2>Quote constants</h2>
<p>Especially when working with writer objects, we may need to specify how to quote fields — for example, to handle a situation where our fields might include the delimiter character itself. For this, we can use the optional <code>quoting</code> parameter for the writer methods, along with <code>quotechar</code> parameter to specify which character to use for quotes.</p>
<p>The <code>csv</code> module has four constants to use for <code>quoting</code>:</p>
<ul>
<li><p><code>csv.QUOTE_ALL</code>: To quote all fields.</p>
</li>
<li><p><code>csv.QUOTE_MINIMAL</code>: To quote the fields which have special characters (such as the delimiter itself).</p>
</li>
<li><p><code>csv.QUOTE_NONNUMERIC</code>: To quote all non-numeric fields.</p>
</li>
<li><p><code>csv.QUOTE_NONE</code>: To never quote fields. If the delimiter character occurs in one of the fields, then the <code>escapechar</code> character is used. If <code>escapechar</code> is not provided, it will raise an error.</p>
</li>
</ul>
<p>Let&#39;s see a simple example with <code>csv.QUOTE_ALL</code> using <code>csv.DictWriter()</code>. As you can imagine, it is going to quote all the fields:</p>
<pre><code class="language-python">import csv

with open(&#39;students.csv&#39;, &#39;a&#39;) as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=[&#39;first&#39;, &#39;last&#39;, &#39;house&#39;], quotechar=&#39;&quot;&#39;, quoting=csv.QUOTE_ALL)
    writer.writerow({&#39;first&#39;: &#39;Cho&#39;, &#39;last&#39;: &#39;Chang&#39;, &#39;house&#39;: &#39;Ravenclaw&#39;})
</code></pre>
<p>Now, Cho Chang&#39;s field is all in quotes:</p>
<pre><code># 📁 students.csv

first,last,house
Harry,Potter,Gryffindor
Hermione,Granger,Gryffindor
Luna,Lovegood,Ravenclaw
Draco,Malfoy,Slytherin
Ron,Weasley,Gryffindor
Ginny,Weasley,Gryffindor
Fred,Weasley,Gryffindor
George,Weasley,Gryffindor
&quot;Cho&quot;,&quot;Chang&quot;,&quot;Ravenclaw&quot;
</code></pre>
<h2>Conclusion</h2>
<p>The convenience that Python provides with its built-in modules is really valuable, and it is no different with the <code>csv</code> module, too. This article explored very simple operations for reading and writing CSV files, but there is always a lot more to explore, and the first stop is always <a href="https://docs.python.org/3/library/csv.html" target="_blank" rel="noopener noreferrer">the official documentation</a>. Hopefully, you now understand some of the basics of dealing with CSV files.<br>Happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/csv-operations-101</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/csv-operations-101</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sun, 28 Aug 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Simple Implementation of Stacks and Queues with Deque in Python]]></title>
            <description><![CDATA[<p>Two of the <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank" rel="noopener noreferrer">abstract data types</a> that you are most likely to have encountered before are <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" target="_blank" rel="noopener noreferrer">stacks</a> and <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" target="_blank" rel="noopener noreferrer">queues</a>. One important aspect is that each of them has different principles when it comes to their behavior when inserting and removing elements — LIFO (last in, first out) for stacks, FIFO (first in, first out) for queues. With a stack, the last item inserted is the first to go out, so, we <em>push</em> and <em>pop</em> from one end of the stack. With a queue, the first item inserted is going to be removed first, similar to a queue in real life, so, <em>enqueue</em> and <em>dequeue</em> operations are done from the opposite ends of the queue.</p>
<p>With a &quot;double-ended queue&quot;, or a <a href="https://en.wikipedia.org/wiki/Double-ended_queue" target="_blank" rel="noopener noreferrer">deque</a>—pronounced as &quot;deck&quot;—, we can enqueue or dequeue, or, push and pop items from both ends at any time. Implemented as a <a href="https://en.wikipedia.org/wiki/Doubly_linked_list" target="_blank" rel="noopener noreferrer">doubly-linked list</a> under the hood, insertion and deletion operations will take <em>O(1)</em>, constant time. This is also another reason why a deque is great — you can imagine that we can also use a Python <code>list</code> for the same goal, but in that case, if we want to insert and remove from the beginning (say, from the left end), the operation will take <em>O(n)</em> time, which is, well, not so good.</p>
<p>Let&#39;s take a look at it. Using a <code>list</code>, you might have seen a stack as implemented as such*:</p>
<pre><code class="language-python">class Stack:
    &quot;&quot;&quot;Stack implementation as a list.&quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;Create new stack.&quot;&quot;&quot;
        self._items = []

    def is_empty(self):
        &quot;&quot;&quot;Check if the stack is empty.&quot;&quot;&quot;
        return not bool(self._items)

    def push(self, item):
        &quot;&quot;&quot;Add an item to the stack.&quot;&quot;&quot;
        self._items.append(item)

    def pop(self):
        &quot;&quot;&quot;Remove an item from the stack.&quot;&quot;&quot;
        return self._items.pop()

    def peek(self):
        &quot;&quot;&quot;Get the value of the top item in the stack.&quot;&quot;&quot;
        return self._items[-1]
    
    def size(self):
        &quot;&quot;&quot;Get the number of items in the stack.&quot;&quot;&quot;
        return len(self._items)
</code></pre>
<p>And, a queue like this:</p>
<pre><code class="language-python">class Queue:
    &quot;&quot;&quot;Queue implementation as a list.&quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;Create new queue.&quot;&quot;&quot;
        self._items = []

    def is_empty(self):
        &quot;&quot;&quot;Check if the queue is empty.&quot;&quot;&quot;
        return not bool(self._items)

    def enqueue(self, item):
        &quot;&quot;&quot;Add an item to the queue.&quot;&quot;&quot;
        self._items.insert(0, item)

    def dequeue(self):
        &quot;&quot;&quot;Remove an item from the queue.&quot;&quot;&quot;
        return self._items.pop()

    def size(self):
        &quot;&quot;&quot;Get the number of items in the queue.&quot;&quot;&quot;
        return len(self._items)
</code></pre>
<p>Since we want to use a <code>deque</code> here instead of a list, let&#39;s take a simple look at it.</p>
<p>We can initialize a <code>deque</code> object with optionally passing an iterable as argument. It is in the <code>collections</code> module, so we also have to import it:</p>
<pre><code class="language-python">from collections import deque

d = deque([7, 3, 0, 1])
print(d) # deque([7, 3, 0, 1])

empty_d = deque()
print(empty_d) # deque([])
</code></pre>
<p>Also, remember that strings are sequences, in that case, our <code>deque</code> would look like this:</p>
<pre><code class="language-python">d = deque(&#39;hey&#39;)
print(d) # deque([&#39;h&#39;, &#39;e&#39;, &#39;y&#39;])
</code></pre>
<p>We can also provide a <code>maxlen</code> argument to specify the maximum length of items we want our <code>deque</code> to have — to make it <em>bounded</em>.</p>
<p>This is a trivial example, but let&#39;s get a sense of how it is working:</p>
<pre><code class="language-python">from collections import deque

d = deque([4, 5, 3, 1, 8], maxlen=3)
print(d) # deque([3, 1, 8], maxlen=3)

d = deque([4, 5, 3, 1, 8], maxlen=4)
print(d) # deque([5, 3, 1, 8], maxlen=4)
</code></pre>
<p>As the items in the iterable are appended from one end, removing the other items (in the case of <code>maxlen=3</code> example, 4 and 5) will be from the opposite end.</p>
<p>Of course, the efficiency of a <code>deque</code> also comes from its <code>appendleft()</code> and <code>popleft()</code> methods, which are aptly named, and better than a <code>list</code> in terms of time complexity.</p>
<pre><code class="language-python">from collections import deque

d = deque([7, 11])
d.appendleft(3)
print(d) # deque([3, 7, 11])

d.appendleft(1)
print(d) # deque([1, 3, 7, 11])

first_i = d.popleft()
print(first_i) # 1
print(d) # deque([3, 7, 11])
</code></pre>
<p>We also have the <code>append()</code> and <code>pop()</code> methods which do their operations to/from the right — like a regular <code>list</code>:</p>
<pre><code class="language-python">from collections import deque

d = deque([2, 4, 6])
d.append(8)
print(d) # deque([2, 4, 6, 8])

first_popped = d.pop()
second_popped = d.pop()

print(f&#39;Popped {first_popped} first, then {second_popped} second.&#39;)
# -&gt; Popped 8 first, then 6 second.

print(d) # deque([2, 4])
</code></pre>
<p>Now that we have seen the append and pop operations from both sides, let&#39;s implement a queue first, similar to the <code>list</code> version at the beginning of the article:</p>
<pre><code class="language-python">from collections import deque

class Queue:
    &quot;&quot;&quot;Queue implementation as a deque.&quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;Create new queue.&quot;&quot;&quot;
        self._items = deque()

    def is_empty(self):
        &quot;&quot;&quot;Check if the queue is empty.&quot;&quot;&quot;
        return not bool(self._items)

    def enqueue(self, item):
        &quot;&quot;&quot;Add an item to the queue.&quot;&quot;&quot;
        self._items.append(item)

    def dequeue(self):
        &quot;&quot;&quot;Remove an item from the queue.&quot;&quot;&quot;
        return self._items.popleft()

    def size(self):
        &quot;&quot;&quot;Get the number of items in the queue.&quot;&quot;&quot;
        return len(self._items)
</code></pre>
<p>For the stack version, as we need to append and pop from the same end, <code>append()</code> and <code>pop()</code> methods using a <code>list</code> might seem okay at first, too. But, let&#39;s modify the previous stack version above to implement it as a <code>deque</code>:</p>
<pre><code class="language-python">from collections import deque

class Stack:
    &quot;&quot;&quot;Stack implementation as a deque.&quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;Create new stack.&quot;&quot;&quot;
        self._items = deque()

    def is_empty(self):
        &quot;&quot;&quot;Check if the stack is empty.&quot;&quot;&quot;
        return not bool(self._items)

    def push(self, item):
        &quot;&quot;&quot;Add an item to the stack.&quot;&quot;&quot;
        self._items.append(item)

    def pop(self):
        &quot;&quot;&quot;Remove an item from the stack.&quot;&quot;&quot;
        return self._items.pop()

    def peek(self):
        &quot;&quot;&quot;Get the value of the top item in the stack.&quot;&quot;&quot;
        return self._items[-1]
</code></pre>
<p>Nothing much seems different, but you can also imagine using the other end, using <code>appendleft()</code> together with <code>popleft()</code> as well.</p>
<p>We have explored a very simple way to create stacks and queues using a deque, but of course, there is a lot more to dive into. <a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank" rel="noopener noreferrer">The official documentation</a> is the first place to go, and you can also check out a <a href="https://realpython.com/python-deque/" target="_blank" rel="noopener noreferrer">Real Python article</a> on the subject. As with many things, it is up to you what you want to achieve, and a double-ended queue is just another tool in your toolkit to consider.</p>
<p>* The examples of stack and queue implementations as a list are from <a href="https://runestone.academy/ns/books/published/pythonds3/index.html" target="_blank" rel="noopener noreferrer">Brad Miller and David Ranum&#39;s wonderful book on algorithms and data structures</a>.</p>
]]></description>
            <link>https://rivea0.github.io/blog/simple-implementation-of-stacks-and-queues-with-deque-in-python</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/simple-implementation-of-stacks-and-queues-with-deque-in-python</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 06 Aug 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Final Project and Beyond]]></title>
            <description><![CDATA[<p>The final week has arrived, and today we do not have any problem sets. Before anything, give yourself a pat on the back for coming this far!<br>It has been quite a delightful journey. We have started with the basic blocks of programming, <a href="https://cs50.harvard.edu/python/2022/weeks/0/" target="_blank" rel="noopener noreferrer">variables and functions</a>, dealt with flow control using <a href="https://cs50.harvard.edu/python/2022/weeks/1/" target="_blank" rel="noopener noreferrer">conditionals</a>, iterated with <a href="https://cs50.harvard.edu/python/2022/weeks/2/" target="_blank" rel="noopener noreferrer">loops</a>, handled <a href="https://cs50.harvard.edu/python/2022/weeks/3/" target="_blank" rel="noopener noreferrer">exceptions</a>, scratched the surface of the world of Python <a href="https://cs50.harvard.edu/python/2022/weeks/4/" target="_blank" rel="noopener noreferrer">libraries</a>, written <a href="https://cs50.harvard.edu/python/2022/weeks/5/" target="_blank" rel="noopener noreferrer">tests</a> for our programs to make sure that they work as we intend them to do, worked with <a href="https://cs50.harvard.edu/python/2022/weeks/6/" target="_blank" rel="noopener noreferrer">files</a>, learned to love <a href="https://cs50.harvard.edu/python/2022/weeks/7/" target="_blank" rel="noopener noreferrer">regular expressions</a>, and last week, peeked into the realm of <a href="https://cs50.harvard.edu/python/2022/weeks/8/" target="_blank" rel="noopener noreferrer">object-oriented programming</a>. Today in <a href="https://cs50.harvard.edu/python/2022/weeks/9/" target="_blank" rel="noopener noreferrer">et cetera</a> we will be looking at some other tools in our toolkit. Phew! If you have started this journey from absolute zero, you have indeed come far! Even if you already have some knowledge before starting the course, congratulations to you as well! It is not easy to dedicate oneself through all these weeks. You can always find the posts on previous problem sets in <a href="https://rivea0.github.io/blog/" target="_blank" rel="noopener noreferrer">the archive</a> as well. </p>
<p>The theme of this series, as well as the course, has been one important point: <em>when in doubt, read the documentation</em>. Even though <a href="https://docs.python.org/3/" target="_blank" rel="noopener noreferrer">the official Python documentation</a> might not seem as friendly at first, you have been using it for many weeks and must be familiar with it already. There are lots more to discover, of course, and it is our number-one friend. Some of these things to discover are already shown in the lecture, so, let&#39;s remember them with very simple examples. (And, get ready for a bunch of Harry Potter references.)</p>
<h2>Sets</h2>
<p>A set is, at the very basic level, a data structure that has no duplicates. So, let&#39;s say you want to look at the distinct broomsticks that Harry Potter used for Quidditch. Easy to do it with a set:</p>
<pre><code class="language-python">broomsticks = [
    &#39;Nimbus 2000&#39;, 
    &#39;Nimbus 2000&#39;, 
    &#39;Firebolt&#39;,
    &#39;Firebolt&#39;, 
    &#39;Firebolt&#39;,
    &#39;Firebolt&#39;,
]

print(set(broomsticks)) # {&#39;Firebolt&#39;, &#39;Nimbus 2000&#39;}
</code></pre>
<h2>Globals</h2>
<p>Global variables are usually frowned upon; especially, using the <code>global</code> keyword is something you must avoid unless you are absolutely sure what you are doing. You can think of a global variables as simply variables outside a function. They cannot just be changed right away inside a function, but are read only in that sense. To change the value of a global variable inside a function, you use the <code>global</code> keyword. Let&#39;s say we are completing the title of our favorite book in the Harry Potter series:</p>
<pre><code class="language-python">half_title = &#39;Chamber of Secrets&#39;

def change_half_title():
    half_title = &#39;Goblet of Fire&#39;

change_half_title()

print(f&#39;Harry Potter and the {half_title}&#39;)
# -&gt; Harry Potter and the Chamber of Secrets
</code></pre>
<p>Of course, it did not change as we expected. However, with the <code>global</code> keyword, it works:</p>
<pre><code class="language-python">half_title = &#39;Chamber of Secrets&#39;

def change_half_title():
    global half_title
    half_title = &#39;Goblet of Fire&#39;

change_half_title()

print(f&#39;Harry Potter and the {half_title}&#39;)
# -&gt; Harry Potter and the Goblet of Fire
</code></pre>
<p>Again, it is not very nice to look at, so avoid this kind of implementation as much as you can.</p>
<h2>Constants</h2>
<p>If you have seen the lecture, you already know that Python do not have constant types. A &quot;constant&quot; variable, though, is indicated with capital letters:</p>
<pre><code class="language-python">SCHOOL_NAME = &#39;Hogwarts School of Witchcraft and Wizardry&#39;


def invite_student():
    return f&#39;We are pleased to inform you that you have been accepted at {SCHOOL_NAME}.&#39;


print(invite_student())
# -&gt; We are pleased to inform you that you have been accepted at Hogwarts School of Witchcraft and Wizardry.
</code></pre>
<h2>Type Hints</h2>
<p>Python is a dynamically-typed language, however, we can still use type hints to make sure we avoid <code>TypeError</code>s.</p>
<p>For example, as you can find the similar example in the <a href="https://docs.python.org/3/library/typing.html" target="_blank" rel="noopener noreferrer">documentation for typing</a>, we can indicate the expected types for arguments and return values of a function:</p>
<pre><code class="language-python">def greeting(name: str) -&gt; str:
    return f&#39;Hello, {name}!&#39;
</code></pre>
<p>Also, as mentioned in the lecture, <code>mypy</code> is a popular <a href="https://mypy.readthedocs.io/en/stable/" target="_blank" rel="noopener noreferrer">library</a> that you can use for type hinting.</p>
<h2>Docstrings</h2>
<p>Docstrings can occur in a module, a function, or a class. The simplest one-line docstring looks like this:</p>
<pre><code class="language-python">def add(n, n1):
    &quot;&quot;&quot;Add two numbers.&quot;&quot;&quot;
    return n + n1
</code></pre>
<p>The conventions on how to use docstrings can be found here in <a href="https://peps.python.org/pep-0257/" target="_blank" rel="noopener noreferrer">this PEP</a>.</p>
<h2>argparse</h2>
<p><code>argparse</code> is a <a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener noreferrer">module</a> that comes built-in with Python, literally a &quot;parser for command-line options, arguments and sub-commands&quot;. </p>
<p>There is a <a href="https://docs.python.org/3/howto/argparse.html#id1" target="_blank" rel="noopener noreferrer">great tutorial</a> on the official documentation already, so, we are not going to dive deep into it here. The simplest thing you can do might look like this. Say, we have a file called <code>spell.py</code>, and we want to pass in the argument <code>-s</code> to our program to indicate the type of spell we want to create. We want the proper incantation printed on our terminal. Let&#39;s see:</p>
<pre><code class="language-python"># 📁 spell.py

import argparse


incantations = {
    &#39;patronus&#39;: &#39;Expecto Patronum!&#39;,
    &#39;summon&#39;: &#39;Accio!&#39;,
    &#39;unlock&#39;: &#39;Alohomora!&#39;,
    &#39;explode&#39;: &#39;Bombarda!&#39;,
    &#39;levitate&#39;: &#39;Wingardium Leviosa!&#39;,
    &#39;stun&#39;: &#39;Stupefy!&#39;
}

parser = argparse.ArgumentParser()
parser.add_argument(&#39;-s&#39;)
args = parser.parse_args()

print(incantations[args.s])
</code></pre>
<p>We can see it with the right command:</p>
<pre><code class="language-shell">$ python spell.py -s unlock
Alohomora!
</code></pre>
<h2>*args, **kwargs</h2>
<p>We have mentioned the unpacking operators briefly in a previous post on <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-4/" target="_blank" rel="noopener noreferrer">problem set 4</a>. The example looked like this:</p>
<pre><code class="language-python">values = [0, 5, 2]
print(*values) # 0 5 2

# Prints 0, 2, 4 respectively
for i in range(*values):
    print(i)


houses = {
    &#39;Gryffindor&#39;: &#39;courage&#39;,
    &#39;Ravenclaw&#39;: &#39;intelligence&#39;,
    &#39;Hufflepuff&#39;: &#39;loyalty&#39;,
    &#39;Slytherin&#39;: &#39;ambition&#39;
}

people = {
    &#39;Harry Potter&#39;: &#39;Gryffindor&#39;,
    &#39;Hermione Granger&#39;: &#39;Gryffindor&#39;,
    &#39;Luna Lovegood&#39;: &#39;Ravenclaw&#39;
}

print({**houses, **people}) # {&#39;Gryffindor&#39;: &#39;courage&#39;, &#39;Ravenclaw&#39;: &#39;intelligence&#39;, &#39;Hufflepuff&#39;: &#39;loyalty&#39;, &#39;Slytherin&#39;: &#39;ambition&#39;, &#39;Harry Potter&#39;: &#39;Gryffindor&#39;, &#39;Hermione Granger&#39;: &#39;Gryffindor&#39;, &#39;Luna Lovegood&#39;: &#39;Ravenclaw&#39;}
</code></pre>
<p>They are super handy for many kinds of problems you encounter, so, another great tool in our toolkits.</p>
<h2>map</h2>
<p>With the <code>map</code> function, we can <em>map</em> a function to each item of an iterable. Creating a list of the squares of each number in a &quot;numbers&quot; list might look like this:</p>
<pre><code class="language-python">numbers = [3, 5, 7, 11, 13]

squared = list(map(lambda n: n**2, numbers))

print(squared) # [9, 25, 49, 121, 169]
</code></pre>
<p>Notice that we also convert the return value of <code>map</code> to a <code>list</code>, as the <code>map</code> function returns a <code>Map</code> object.</p>
<h2>List comprehensions</h2>
<p>If you have been following the series, you already know about the list comprehensions way <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-2/" target="_blank" rel="noopener noreferrer">back in Problem Set 2</a>. It is a Pythonic way to <em>append</em> to a list, so instead of doing something like this:</p>
<pre><code class="language-python">word = &#39;CS50&#39;

digits_in_word = []

for char in word:
    if char.isdigit():
        digits_in_word.append(char)

print(digits_in_word) # [&#39;5&#39;, &#39;0&#39;]
</code></pre>
<p>Just write a one-liner that achieves the same result:</p>
<pre><code class="language-python">word = &#39;CS50&#39;

digits_in_word = [char for char in word if char.isdigit()]

print(digits_in_word) # [&#39;5&#39;, &#39;0&#39;]
</code></pre>
<h2>filter</h2>
<p>We can also filter an iterable, returning only the values we are interested in. </p>
<p>The same example above in list comprehensions can also be solved like this:</p>
<pre><code class="language-python">word = &#39;CS50&#39;

digits_in_word = list(filter(str.isdigit, word))

print(digits_in_word) # [&#39;5&#39;, &#39;0&#39;]
</code></pre>
<p>Also, just like in <code>map</code>, notice we also convert the return value to a <code>list</code>. We also do not call the <code>str.isdigit</code> inside <code>filter</code>, we only pass a reference to that function.</p>
<h2>Dictionary comprehensions</h2>
<p>Similar to list comprehensions, dictionary comprehensions are also another —sometimes elegant, sometimes not— way to create dictionaries. To implement a very simple one, let&#39;s initialize all the Hogwarts house points to 0 for the start of the term:</p>
<pre><code class="language-python">houses = [&#39;Gryffindor&#39;, &#39;Hufflepuff&#39;, &#39;Ravenclaw&#39;, &#39;Slytherin&#39;]

house_points = {house: 0 for house in houses}

print(house_points) # {&#39;Gryffindor&#39;: 0, &#39;Hufflepuff&#39;: 0, &#39;Ravenclaw&#39;: 0, &#39;Slytherin&#39;: 0}
</code></pre>
<p>It works as intended, and initializes all the house points 0.</p>
<h2>enumerate</h2>
<p>Here is a Pythonic way to iterate over an iterable. Similar to the lecture example, let&#39;s say that this time we want to print the names of the houses, also indicated with the first value of &#39;1&#39;, instead of &#39;0&#39;. We do not have to write something like this:</p>
<pre><code class="language-python">houses = [&#39;Gryffindor&#39;, &#39;Hufflepuff&#39;, &#39;Ravenclaw&#39;, &#39;Slytherin&#39;]

for i in range(len(houses)):
    print(i + 1, houses[i])

# -&gt;
# 1 Gryffindor
# 2 Hufflepuff
# 3 Ravenclaw
# 4 Slytherin
</code></pre>
<p>There is a more elegant way to do it:</p>
<pre><code class="language-python">houses = [&#39;Gryffindor&#39;, &#39;Hufflepuff&#39;, &#39;Ravenclaw&#39;, &#39;Slytherin&#39;]

for index, house in enumerate(houses, start=1):
    print(index, house)

# -&gt;
# 1 Gryffindor
# 2 Hufflepuff
# 3 Ravenclaw
# 4 Slytherin
</code></pre>
<p>Notice that the <code>enumerate</code> function also takes a <code>start</code> argument to start from the number that is passed.</p>
<h2>Generators</h2>
<p>Finally, also mentioned in the lecture, a generator function is a &quot;function that returns a generator iterator&quot;. With a generator function that <em>yields</em> as opposed <em>returns</em> a value, we can save memory with <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="noopener noreferrer">lazy evaluation</a>. The Python documentation also has a <a href="https://docs.python.org/3/howto/functional.html#generators" target="_blank" rel="noopener noreferrer">tutorial on generators</a>, and similar to the example in the lecture, the very simplest implementation might look like this:</p>
<pre><code class="language-python">def main():
    for _ in gen(1000000):
        print(_)

def gen(n):
    for _ in range(n):
        yield _

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>These are all the topics we have explored this week. From now on, we are left with our very own <a href="https://cs50.harvard.edu/python/2022/project/" target="_blank" rel="noopener noreferrer">Final Project</a> to implement. For this, you are free to create anything that excites you, any kind of problem that you want to solve — of course, following the given specifications for the project. And, after that, you might think that is all, and that we are finished, but, are we?</p>
<h2>Conclusion</h2>
<p>Now, looking back, we have gathered many useful tools in our toolkit to do whatever we want to do. But, should we do whatever we want to do just because we can?<br>You probably have ideas for the answer to that question. It is easy to get excited about all kinds of things you can create once you know how to do them. But, once you start to create things, always remember that using and trusting technology as a solution to all problems is not always the case. Now that you have the power and knowledge to do so, remember that it is absolutely <em>vital</em> to create software that respects users&#39; freedom, that is open and trustworthy. Remember that <a href="https://www.privacyinternational.org/explainer/56/what-privacy" target="_blank" rel="noopener noreferrer">privacy is a human right</a>, even if there might have already been much talk about it — yet, usually without honesty. Do not underestimate your current level of knowledge, you have tremendous power in your hands with the tools you can use. And, yes, one more thing to remember — <a href="https://www.britannica.com/event/Bernstein-vs-the-US-Department-of-State" target="_blank" rel="noopener noreferrer">code is speech</a>.<br>These all might sound like out of context, why should you even bother to think about them? After all, assuming you only have taken this introductory course, and are still at the beginning of your programming journey, and have a long way to go. But, hopefully, you undoubtedly agree that we need good things in life — good software that respects human dignity and helps the progress of humanity is one of them. If you think these are some grand ideologies for a &quot;beginner&quot; like you —which, honestly, I also consider myself a &quot;beginner&quot; in many things at this point—, remember that each piece of knowledge will eventually add up to another, so, even if you are not going to pursue a programming path in your life at all; that is fine, because at least this will be how you look at things, have a stronger sense of self-agency, and a more educated opinion in the decisions that affects us all.</p>
<p>With that in mind, that is the end of the series!<br>If you have read so far, thank you. And, as always, happy coding. 💜</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-final</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-final</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 08 Jun 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 8]]></title>
            <description><![CDATA[<p><a href="https://cs50.harvard.edu/python/2022/weeks/8/" target="_blank" rel="noopener noreferrer">This week</a>, we are solving <a href="https://cs50.harvard.edu/python/2022/psets/8/" target="_blank" rel="noopener noreferrer">the last problem set</a> of the course. We have covered so much, solved many beautiful problems, and after this week, are ready to implement our very own final project! I know that is a bit emotional indeed, but let me give the <strong>disclaimer</strong> one last time, that this series was intended as a guide for thinking about the problems, instead of just providing the solutions. And, as always, it is assumed you have read the problem explanations already. You can find the previous posts in this series in <a href="https://rivea0.github.io/blog/" target="_blank" rel="noopener noreferrer">the archive</a>.</p>
<p>So far, we have been writing our code <a href="https://en.wikipedia.org/wiki/Procedural_programming" target="_blank" rel="noopener noreferrer">procedurally</a>, but this time, we are going to make use of the Object-Oriented programming paradigm, which is definitely exciting as we will explore each problem. Let&#39;s dive in!</p>
<h2>Seasons of Love</h2>
<p>For <a href="https://cs50.harvard.edu/python/2022/psets/8/seasons/" target="_blank" rel="noopener noreferrer">the first problem</a> of this week, we are working with a <code>datetime</code> object, instead of writing our own classes from scratch. We need to convert days to minutes; 365 days for example, results in 525600 minutes.</p>
<p>Many hints are given for this problem, but let&#39;s take a look. For starters, we want our code to be more modular this week as we learn to appreciate the importance of <a href="https://en.wikipedia.org/wiki/Modularity" target="_blank" rel="noopener noreferrer">modularity</a> in programming. The things that we need to do, is to get an input (in the <code>YYYY-MM-DD</code> format), convert the input to a date object, calculate the difference of days between that given date and today, convert days to minutes, and finally convert minutes to words. Well, it may seem like a lot, but thinking this way actually makes our job easier.<br>First, as always we can <em>try</em> to get an input, and if we have a <code>ValueError</code>, we can <em>exit</em> the program with a string like <code>Invalid date</code> which will result in an exit status of 1. If we type <code>help(sys.exit)</code> to get information from the documentation in this case, it literally tells you that:</p>
<pre><code>Help on built-in function exit in module sys:

exit(status=None, /)
    Exit the interpreter by raising SystemExit(status).

    If the status is omitted or None, it defaults to zero (i.e., success).
    If the status is an integer, it will be used as the system exit status.
    If it is another kind of object, it will be printed and the system
    exit status will be one (i.e., failure).
</code></pre>
<p>We have been doing this for many weeks, so, no problem.</p>
<p>If the given format is okay (something like <code>2021-06-02</code>, for example), we calculate how many days have passed from <em>today</em>. Before that, remember that input returns a string, and we need integers to construct a date object, so <em>year</em>, <em>month</em>, and <em>day</em> that are <em>split</em> from the input should be integers.<br>To calculate how many days have passed, <code>datetime.date</code> has some methods that can come in handy here. It is already in the hints section, so if we <em>subtract</em> the given date from <em>today</em>, we have a <code>timedelta</code> object returned, which has its own instance attributes like, say, <em>days</em>.<br>After we have the days, we need to convert it to minutes, and how to do it is also given in the problem explanation. Literally, it is this:</p>
<pre><code class="language-python">def days_to_minutes(days):
    return days * 24 * 60
</code></pre>
<p>After we have our minutes, finally we need to convert it to a nice looking output. The <code>inflect</code> library, which I have come to fall in love with, is tremendously helpful. What we need to do is literally to convert a <em>number to words</em>, but we only want commas and <em>no &quot;and words&quot;</em>.<br>So, instead of looking like this:</p>
<pre><code class="language-python">&#39;five hundred and twenty-five thousand, six hundred&#39;
</code></pre>
<p>Our output should look like this:</p>
<pre><code class="language-python">&#39;Five hundred twenty-five thousand, six hundred minutes&#39;
</code></pre>
<p>Notice that we also want our output to be <em>capitalized</em>. Again, a way too obvious hint, but remember that the documentation is your friend. </p>
<p>After these, we have not much to do except writing our tests for our code. <em>How to Test</em> is also given in the problem explanation, all the test specifications should be enough to implement. We are already familiar with testing, and have been used to it already for many weeks, so it should be quite easy as well. Now, let&#39;s check out the next one.</p>
<h2>Cookie Jar</h2>
<p>Here we are, the time has come to write our first class in this course. In <a href="https://cs50.harvard.edu/python/2022/psets/8/jar/" target="_blank" rel="noopener noreferrer">this problem</a>, we are storing cookies in a jar. Simple, and really fun as it sounds.</p>
<p>We are given a template already, and need to implement the functions <code>__init__</code>, <code>__str__</code>, <code>deposit</code>, <code>withdraw</code>, <code>capacity</code>, and <code>size</code>. First of all, remember that <code>__init__</code> function initializes our object construction. So, let&#39;s say you have just bought a cookie jar from the store, how many cookies are in it when you first bought it? It has a capacity (which in this case, we default to 12), but since there are no cookies in it, its <em>size</em> is 0 when you initially buy it. As you deposit cookies into it, its size increases, and as you withdraw cookies, its size decreases. Therefore, for the initialization, our cookie jar has the capacity of whatever is given as capacity, and the size of 0.</p>
<p>For <code>deposit</code> and <code>withdraw</code> functions, we need to be careful with some edge cases. For example, if the total number of cookies after you deposit is more than the capacity, we should <em>raise</em> a <code>ValueError</code>. Otherwise, we increase the size. And, if the number to withdraw is more than the <em>size</em>, we also <em>raise</em> <code>ValueError</code>. Otherwise, we decrease the size.</p>
<p>Now, here is the interesting part. While working with capacity and size, you realize that we not only read their values, but also <em>set</em> their values. As the template already indicates, we will use <code>@property</code> decorator for the <em>getter</em> functions. How do we do the <em>setters</em>, then? Before answering that question, let&#39;s take a look at an example. Let&#39;s say we have created a class for a Hogwarts homework essay, and we are mainly concerned with the number of words in it. We have a default word limit of 2000 (which, I guess, would be nothing for Hermione), but it can be changed. We can add or remove words, but the important thing is how we handle the word limit and the number of words we have written already. It sounds complicated, but let&#39;s take a look at this:</p>
<pre><code class="language-python">class HogwartsEssay:
    def __init__(self, word_limit=2000):
        self.word_limit = word_limit
        self.words_written = 0

    def __str__(self):
        return f&#39;Number of words written: {self.words_written}&#39;

    def add_words(self, number_of_words_to_add):
        ...

    def remove_words(self, number_of_words_to_remove):
        ...

    @property
    def word_limit(self):
        return self._word_limit

    @word_limit.setter
    def word_limit(self, word_limit):
        if word_limit &lt; 0:
            raise ValueError
        self._word_limit = word_limit

    @property
    def words_written(self):
        return self._words_written

    @words_written.setter
    def words_written(self, words_written):
        self._words_written = words_written
</code></pre>
<p>As you can see, <code>add_words</code> and <code>remove_words</code> functions are omitted so as not to be <em>way too close</em> to the solution. But, the idea is simple. We can <em>get</em> the word limit as well as the number of words written, we can also <em>set</em> the word limit as long as it is not less than 0, and set the number of words written. It might be a weird example, but the idea is similar to the example given in the lecture. If you have seen the lecture, then you are already familiar with using getters and setters. This is really a fun problem, even though at a glance might seem complicated a bit. That is really all we need to do. And, for the tests, <em>How to Test</em> section is again your friend, as it tells you what to do almost step-by-step. </p>
<p>And, before we go into the next one, how to print the cookies? Well, we print a cookie emoji for the number of cookies in the jar, and, <a href="https://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="noopener noreferrer">thank Guido</a> that Python is an amazing language — and has a <em>string operator</em> that helps us <em>repeat</em> our strings.</p>
<p>On to the next (and the last) problem!</p>
<h2>CS50 Shirtificate</h2>
<p>The very <a href="https://cs50.harvard.edu/python/2022/psets/8/shirtificate/" target="_blank" rel="noopener noreferrer">last problem</a> to solve, is kind of customizable. We are making our very own <a href="https://cs50.harvardshop.com/collections/print/products/i-took-cs50-unisex-t-shirt" target="_blank" rel="noopener noreferrer">I took CS50 shirts</a>, with the help of <code>fpdf2</code> library.</p>
<p>Here, the mantra we have for weeks is realized, has taken shape, and stares at us in flesh: &quot;When in doubt, read the documentation.&quot; The problem has only five specifications, and beyond them, you are free to use any methods, and create any kind of shirt that you want to.</p>
<p>To be honest, though, this freedom may be a bit intimidating. Although, the bare minimum solution for this problem takes 15-20 lines of code, finding the right methods and attributes to use can be a bit of a pain. Let&#39;s see how we can manage to create a shirt with only the required specifications.</p>
<p>As the hints section suggests, we can add a subclass that inherits <code>FPDF</code> class itself to write a header. In this case, our header will be the text &quot;CS50 Shirtificate&quot; that is centered horizontally.</p>
<p>The code in the tutorial for header function <em>literally</em> helps you with that, only we <em>do not need to render a logo</em>. Inside our function for header, we can just <em>set our font</em>, <em>move cursor to right</em>, <em>print title</em> with <em>aligning it to center</em> and without a border, and <em>perform a line break</em>. These are already given to you. After the line break, we can call the <code>image</code> method to insert our image (shirtificate.png). In order to do it properly, we can set its width to <strong>e</strong>ffective <strong>p</strong>age <strong>w</strong>idth (which is just the width of the page minus the horizontal margins) to make our job easier. Notice that <a href="https://pyfpdf.github.io/fpdf2/fpdf/fpdf.html#fpdf.fpdf.FPDF.image" target="_blank" rel="noopener noreferrer">the documentation</a> has this to say for the width option for images:</p>
<blockquote>
<p><strong><code>w</code></strong> : <code>float</code></p>
<p>optional width of the image. If not specified or equal to zero, it is automatically calculated from the image size. Pass <code>pdf.epw</code> to scale horizontally to the full page width.</p>
</blockquote>
<p>We also need to put our text <code>{name} took CS50</code>, where <code>name</code> is the return value of <code>input</code>, on our shirt. We need to color our text white here. For that, you might have already checked the <a href="https://pyfpdf.github.io/fpdf2/TextStyling.html" target="_blank" rel="noopener noreferrer">documentation for text styling</a>; however, it might be still a bit confusing. </p>
<p>Now, not to deviate from the subject but, if you are really stuck (which was my experience at some point), the link to the documentation above has also a <a href="https://github.com/PyFPDF/fpdf2/blob/master/test/text/test_text_mode.py" target="_blank" rel="noopener noreferrer">link to a file</a> called <code>test_text_mode.py</code> in the library&#39;s source code. Take a look at this:</p>
<pre><code class="language-python">def test_text_modes(tmp_path):
    pdf = FPDF(format=(350, 150))
    pdf.add_page()
    pdf.set_font(&quot;Helvetica&quot;, size=80)
    with pdf.local_context(fill_color=(255, 128, 0)):
        pdf.cell(txt=&quot;FILL default&quot;)
    with pdf.local_context(text_color=(0, 128, 255)):
        pdf.cell(txt=&quot; text mode&quot;)
    pdf.ln()

    ...
</code></pre>
<p>And here it is, easy-to-use <em>text color</em> for the local context! Remember that our color should be white, whose RGB value represents all the colors to the brim. <em>With local context</em>, we create a cell, this time for the text on the shirt. Its height, as the hints in the problem explanation suggest, can be <em>negative</em> to adjust it properly, say, something like 250ish.  For the width, our old friend <strong>e</strong>ffective <strong>p</strong>age <strong>w</strong>idth is helpful. We also <em>align</em> it to the center, of course.</p>
<p>Now that our class seems to be done, it is time to create an instance, <em>add page</em> with the appropriate <em>orientation</em> and <em>format</em>, and <em>output</em> the <code>shirtificate.pdf</code>. With that, that is the end of our problem and the problem sets! </p>
<p>It has been a really fun and delightful journey, but, now that the problem sets are actually over, it does not mean that we are done, yet. Next week, for the last installment in this series, we are going to think about things we have learned so far, what more to discover, and how to continue onward to the final project and beyond.</p>
<p>Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-8</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-8</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 02 Jun 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 7]]></title>
            <description><![CDATA[<p>We are at <a href="https://cs50.harvard.edu/python/2022/weeks/7/" target="_blank" rel="noopener noreferrer">week 7</a>, and this week&#39;s topic is everyone&#39;s absolute favorite. And, what is it? Regular expressions, of course!</p>
<p>Well, excuse the sarcastic introduction, but indeed, it is pretty sure that regex can slightly be a bit of a nightmare — especially, for beginners. However, have no doubts, it is a superpower in disguise.</p>
<p><img src="https://imgs.xkcd.com/comics/regular_expressions.png" alt="xkcd: Regular Expressions"></p>
<p>Before we start, I have to give the usual <strong>disclaimer</strong> that these posts are mostly about how to approach the problems instead of giving outright the solutions. I also assume you have read the problem explanations given in the course&#39;s website, so that the references I make are clear. And, you can find all the posts on previous problem sets <a href="https://rivea0.github.io/blog/" target="_blank" rel="noopener noreferrer">in the archive</a>.</p>
<p>Without further ado, let&#39;s dive into this week&#39;s problems!</p>
<h2>NUMB3RS</h2>
<p>The first <a href="https://cs50.harvard.edu/python/2022/psets/7/numb3rs/" target="_blank" rel="noopener noreferrer">problem</a> that we need to solve is really fun. We are checking valid IPv4 addresses, which has the format <code>#.#.#.#</code> and has all its numbers in the range between 0 and 255, inclusive. The pattern is literally it; we are looking for a <em>digit</em> that can occur <em>1 to 3 times</em>, then a <em>dot</em>, then another digit 1 to 3 times, then another dot, and then another digit, again 1 to 3 times, then a dot, and finally the last digit which can also occur 1 to 3 times. </p>
<p>One thing we should be careful is that this pattern should be the whole thing — there can be nothing before or after it. So, the input we are given should have this pattern only between the <em>start</em> and the <em>end</em> of it. Getting a digit character, and &quot;1 to 3 times&quot; part is easy if you have checked the documentation, or any other resource online. You are also familiar with the starting and ending restriction characters from the lecture as well. Since we also know how to put those digits into <em>each group</em>, we can check if each of them are within 0 to 255 range inclusive. This can be done with a simple for loop, but I want to show a Python function that can come in handy here.</p>
<p>Let&#39;s say we have a tuple that has Hogwarts houses in it.<br>We want to check if <em>all</em> of the items in it are Ravenclaw, because we do not want to be bothered with any other houses. We can try this:</p>
<pre><code class="language-python">def check_all(houses):
    return all([house == &#39;Ravenclaw&#39; for house in houses])
</code></pre>
<p>It has the same idea as this:</p>
<pre><code class="language-python">def check_all(houses):
    result = []

    for house in houses:
        result.append(house == &#39;Ravenclaw&#39;)

    if False in result:
        return False
    else:
        return True
</code></pre>
<p>Maybe, not literally what is going on with <code>all</code>, but the idea is similar to this one as well, only that we are returning False early here (let&#39;s not call it <code>check_all</code>, but <code>check</code> instead):</p>
<pre><code class="language-python">def check(houses):
    for house in houses:
        if house != &#39;Ravenclaw&#39;:
            return False
    return True
</code></pre>
<p>If <code>houses</code> look like <code>(&#39;Ravenclaw&#39;, &#39;Ravenclaw&#39;, &#39;Gryfindor&#39;, &#39;Ravenclaw&#39;)</code>, <code>check_all()</code> will return <code>False</code>!</p>
<p>Notice that we have a list comprehension inside the <code>all</code> function, and appending to it a conditional. Then we check if that list has any False in it, if so we return False, but otherwise we return True if all the conditionals in our list are True. </p>
<p>Similar idea can be applied with checking if each number in the match <em>groups</em> is within the range of 0 and 255 inclusive. </p>
<p>For the test file, considering only the cases we are given in the problem explanation and <code>check50</code> is sufficient. </p>
<p>This was quite fun. Let&#39;s take a look at the next one.</p>
<h2>Watch on Youtube</h2>
<p>With a graceful Rickroll, in <a href="https://cs50.harvard.edu/python/2022/psets/7/watch/" target="_blank" rel="noopener noreferrer">this problem</a>, we are extracting and parsing YouTube URLs for being able to easily embed them. The template for our program is, again, already given, we have to implement the <code>parse()</code> function for it to be called on <code>main()</code>. For a given string, namely <code>s</code>, how can we start thinking about parsing a YouTube URL?</p>
<p>For starters, we know that in this problem specifically, the link is going to be inside an <code>iframe</code> element. We know that it is going to be look like this in its simplest form:</p>
<pre><code class="language-html">&lt;iframe src=&quot;http://www.youtube.com/embed/xvFZjo5PgG0&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>We know that it has to <em>start</em> with <code>&lt;iframe</code>, followed by a <em>space character</em>, followed by <code>src=&quot;</code>. After that comes the link, as well as the closing quotation marks, closing angle bracket <code>&gt;</code>, and the closing tag <code>&lt;/iframe&gt;</code>.</p>
<p>There is also one more thing, we might have <code>www</code> inside the link — which is to say that there can be <em>zero or more</em> characters before<br>&quot;youtube&quot;. </p>
<p>If you have been following this series, you might notice that I have already given some subtle hints. Finding the corresponding regex characters is up to you to find — which is more fun, and which you can find in <a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener noreferrer">Python&#39;s documentation</a>. Also, there are a lot of ways to implement a regex, so how you come up with a solution will be eventually up to you. </p>
<p>Before going on, you should notice that it is an <code>http</code> link, which we should definitely turn into <code>https</code> for <a href="https://www.eff.org/encrypt-the-web" target="_blank" rel="noopener noreferrer">encryption and security</a> reasons. If you have captured that part as a group, it is easy to do it with a conditional, or replacement, however you would like to do it.</p>
<p>Let&#39;s say we have managed to get the URL <code>http://www.youtube.com/embed/xvFZjo5PgG0</code>, and everything is fine. Or, is it?</p>
<p>That was simple for one <a href="https://www.w3schools.com/tags/tag_iframe.asp" target="_blank" rel="noopener noreferrer">attribute</a>, but what if you have more than one attributes like this:</p>
<pre><code class="language-html">&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/xvFZjo5PgG0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
</code></pre>
<p>You see that <code>src</code> occurs after <code>width</code> and <code>height</code>, and is followed by a bunch of other attributes. Now, if you do not do it in a non-greedy way, you might have something like this result as the URL you get:</p>
<p><code>https://www.youtube.com/embed/xvFZjo5PgG0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture</code></p>
<p>That is definitely not a URL, nor the thing we are looking for. Notice that I mentioned the term &quot;non-greedy&quot;, what does that even mean?</p>
<p>Let&#39;s say we have a string:</p>
<pre><code class="language-python">s = &#39;&quot;A string&quot;, and &quot;another string&quot;.&#39;
</code></pre>
<p>We only want to get <code>&quot;A string&quot;</code>, not <code>&quot;another string&quot;</code>. We are literally looking for a quotation mark, one or more characters in it, and then another quotation mark. For, simplicity sake, let&#39;s do it with this pattern:</p>
<pre><code class="language-python">import re


if matches := re.search(&#39;(&quot;.+&quot;)&#39;, s):
    print(matches.group(1))
</code></pre>
<p>(If you are not familiar with it, see <a href="https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions" target="_blank" rel="noopener noreferrer">assignment expressions</a> for the &quot;walrus operator&quot;).</p>
<p>However, what we see in the terminal is not what we want: <code>&quot;A string&quot;, and &quot;another string&quot;</code>.</p>
<p>What happens is that, <code>.+</code> does a <em>greedy</em> search. However, we can prevent this from turning it into a <em>lazy</em> search with just appending the question mark to it:</p>
<pre><code class="language-python">import re


if matches := re.search(&#39;(&quot;.+?&quot;)&#39;, s):
    print(matches.group(1))
</code></pre>
<p>Now we see <code>&quot;A string&quot;</code>, just like we want. You might be interested in seeing how <a href="https://rivea0.github.io/blog/a-quick-behind-the-scenes-of-greedy-and-lazy-matching/" target="_blank" rel="noopener noreferrer">greedy and lazy matching that actually works</a>.</p>
<p>Using the lazy quantifier helps us get the URL in correct form. After that, we need to turn it into a shorter version. We do that by removing <code>www</code> <em>or</em> <code>embed/</code>, <em>or</em> <code>.com</code>. In other words, we replace — or, <em>substitute</em> — these pieces of text with <em>nothing</em>. We also need to <em>substitute</em> <code>youtube</code> with <code>youtu.be</code> for the resulting string. </p>
<p>How you go on to implement these little puzzle pieces is, again, up to you as there are lots of different ways for a solution. Perhaps, one of the important takeaways is knowing the difference between greedy and lazy matching, and how to work with them. Let&#39;s see what the next one has in store.</p>
<h2>Working 9 to 5</h2>
<p>I think <a href="https://cs50.harvard.edu/python/2022/psets/7/working/" target="_blank" rel="noopener noreferrer">this problem</a> has also many different ways for a solution that you might even have an analysis paralysis (at least, this was my experience). What we need to do here is to convert 12-hour input format to 24-hour format. Our input should be in a certain form, though. For example, it has to have the word &quot;to&quot; in it, something like <code>9 AM to 5 PM</code>. We may or may not be given minutes; our input can be <code>9 AM to 5 PM</code> or <code>9:00 PM to 5:00 PM</code>. Additionally, the input can imply a night shift, so that AM and PM given might be reverse, like <code>10 PM to 8 AM</code>. All of these seem like a lot, especially if you are absolutely new to regular expressions, but again, reading the documentation and poking around might give some insights. I am not extremely satisfied with the solution I came up with, and there is definitely a more elegant way to think about it. But, let&#39;s try to understand a potential approach.</p>
<p>First, we know that we can capture not only the numbers for the hours and minutes, but also AM and PM, since their order matters for our resulting string. For the first number (that is the hour), we know that the number of digits it has can be either 1 or 2 (it could be <code>9</code> or <code>10</code>, for instance). We want a <em>digit</em> that has <em>1 to 2</em> repetitions. After that, <em>optionally</em> we can have a <em>colon</em> followed by another <em>digit</em> that has <em>1 to 2</em> repetitions as well. This second part is for the minutes so that if we are given <code>10:00</code> we can capture the <code>:00</code> part. After that we are supposed to have a <em>space character</em> followed by either <em>AM or PM</em>. This is enough for describing <code>10:00 PM</code>. What we have after that, is another <em>space character</em>, followed by the string <em>&quot;to&quot;</em>, then another <em>space character</em> followed by the pattern that we have just described for <code>10:00 PM</code>. If we capture the hour, minute, and AM/PM as <em>groups</em>, you might remember that we might also have an input where the minutes are not given — in this case, our minute group will result in <code>None</code>. However, we can clean it and replace it with a simple <code>:00</code>, since if the minutes are not given it is assumed 0. If there is no match, we should also <em>raise</em> a <code>ValueError</code>. For determining the night shift (if PM comes before AM), we can check if the AM&#39;s index comes before PM in our cleaned groups list. In that case, we can have a flag variable where we can say that &quot;night shift&quot; is True or False. After that, we need to do the actual converting part. We can separate a conditional branch for &quot;not night shift&quot; (that is to say AM before PM), or night shift (PM before AM), and work our way with the appropriate hour and minute indices. The realization when converting is that, we do not consider minutes here, just the hours. And, for AM, if the hour is 12, we should convert it to 0 instead, otherwise, keep it like it is given. For the PM hour, if it is 12 it should stay 12, but for any other number we should <em>add</em> 12 to it. Because there seem to be a lot of &quot;if conditions&quot;, I like to mention a one-liner way to do it in Python. So, it might look something like this:</p>
<pre><code class="language-python">hours_am = 0 if int(am_hour) == 12 else int(am_hour)
hours_pm = 12 if int(pm_hour) == 12 else int(pm_hour) + 12
</code></pre>
<p>The same as this:</p>
<pre><code class="language-python">if int(am_hour) == 12:
    hours_am = 0
else:
    hours_am = int(am_hour)


if int(pm_hour) == 12:
    hours_pm = 12
else:
    hours_pm = int(pm_hour) + 12
</code></pre>
<p>Of course, if it starts to get complex and reduces readability, you should avoid over-using one-liners, but it makes sense here for a small implementation.</p>
<p>We also need to check if the hours and minutes are valid — if the hours are within 0 and 12 inclusive, and the minutes are within 0 and 59 inclusive range. If either of them is invalid, we also need to <em>raise</em> a <code>ValueError</code> here as well.</p>
<p>One more thing, we also need to create a <code>test_working.py</code> file to test our code. Handling all the cases in &quot;How to Test&quot; section of the problem explanation is quite sufficient here, if not, we know that <code>check50</code> is our friend to guide us on which tests to cover. For testing if our code indeed raises  <code>ValueError</code> in the right cases, we might remember how to do that from the <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-5/" target="_blank" rel="noopener noreferrer">Refueling problem</a> from Week 5.</p>
<p>This one was a bit challenging, and I left some gaps on some points intentionally, but that is really the point of it. The thinking process might differ, this one is just the thinking process of the solution I came up with and hopefully provided you some insight. Let&#39;s look at the next one. </p>
<h2>Regular, um, Expressions</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/7/um/" target="_blank" rel="noopener noreferrer">this one</a>, we are checking if the input we are given has &quot;um&quot; in it, but not counting it inside words like &quot;yummy&quot;. The important idea is that we are looking for a word, therefore it has to have some <em>boundaries</em>. As the problem explanation suggests, it has to be the boundary between a <em>word</em> and a <em>non-word</em> character. Or, it can also be at the beginning or the end of the sentence. But also, we can have an input like <code>um?</code>, which is followed by a <em>non-word</em> character, so we can have that <em>optionally</em> as well. We also need to take care of both uppercase and lowercase characters, and <code>re.IGNORECASE</code> flag takes care of that. </p>
<p>The hints section already mentions <code>re.findall()</code> function, since it returns a list of all the matches it finds, we can return the <em>length</em> of that list from our <code>count()</code> function. For the tests, the edge cases to consider are already given in the problem explanation page, which will be sufficient as well. It looks daunting at first, but really, that is all there is to it. Let&#39;s look at the last problem of this week. </p>
<h2>Response Validation</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/7/response/" target="_blank" rel="noopener noreferrer">This problem</a> emphasizes an important habit to have: relying on <em>well-trusted</em> libraries —no need to mention the importance of reading their documentation— when the time comes. And, that time might come when you need to validate an email address. In this problem, we can choose from two libraries, <a href="https://pypi.org/project/validator-collection/" target="_blank" rel="noopener noreferrer">validator-collection</a> or <a href="https://github.com/kvesteri/validators" target="_blank" rel="noopener noreferrer">validators</a>. We do not even have to use <code>re</code> module ourselves, because these libraries handle everything for us.</p>
<p>Since this problem&#39;s solution depends on which library you use, there is nothing much that I can give a hint about. Documentation really helps you out for each of the libraries, we also do not need to write our own tests for this one as well. It is, of course, a good habit to handle errors, and that is pretty much it. </p>
<p>Dealing with regular expressions might indeed be challenging if you have never used them before. Nevertheless, we have seen that it is a superpower that comes in handy with all kinds of problems. Next week, we are going to take a look at Object-Oriented Programming. Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-7</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-7</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 25 May 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 6]]></title>
            <description><![CDATA[<p>This week on <a href="https://cs50.harvard.edu/python/2022/weeks/6/" target="_blank" rel="noopener noreferrer">File I/O</a>, we have exciting new problems to solve. Working with files programmatically is inevitable, and as always, Python makes our life easier — with many useful libraries. As always, I assume you have read the problem explanations on <a href="https://cs50.harvard.edu/python/2022/psets/6/" target="_blank" rel="noopener noreferrer">this week&#39;s Problem Set</a>, and have to give the <strong>disclaimer</strong> that you are not going to find any full solutions to these problems here, but rather gain some insights into how to think about them.</p>
<p>You can find all the previous posts on past problem sets <a href="https://rivea0.github.io/blog/" target="_blank" rel="noopener noreferrer">here in the archive</a>. Now, let&#39;s dive into this week&#39;s problems!</p>
<h2>Lines of Code</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/6/lines/" target="_blank" rel="noopener noreferrer">This one</a> was really fun to solve, even if it might get a little complicated when we start to think about some edge cases. What we want to do here is to count valid lines of code to have an understanding about the complexity of the program. We have worked with the  <code>sys</code> module, and <code>try...except</code> blocks before, and know that they come in handy in this problem. Handling too many and too few command-line arguments is straightforward, as we have done that before; and we can also catch something like a <code>FileNotFoundError</code> at this point. The hints for the problem already tells you to consider checking if a string <em>ends with</em> a certain substring — which is useful for checking if the filename we are given is indeed a Python file. The main thing to think about here is that considering the file is now valid, we need to count only the valid lines — that being, not blank lines or comments, but just the code itself. Let&#39;s say we want to do exactly that, ignore comments and blank lines, and count the lines of our code. So, let&#39;s say our code looks extremely silly like this:</p>
<pre><code class="language-python">def get_names():
    &quot;&quot;&quot;
    Prints each name in the golden trio.
    Example output:
      1: Harry
      2: Hermione
      3: Ron
    &quot;&quot;&quot;
    # The names of the golden trio
    the_golden_trio = [&#39;Harry&#39;, &#39;Hermione&#39;, &#39;Ron&#39;]
    
    for index, name in enumerate(the_golden_trio):
        print(f&#39;{index + 1}: {name}&#39;)
</code></pre>
<p>The total number of valid lines to count should be four. Remember, we are ignoring the docstring altogether, as well as the comment (<code># The names of the golden trio</code>), and the blank line just after <code>the_golden_trio</code>. A conditional is easy to implement in this case, we are counting lines as long as they do not <em>start with</em> a hashtag, and <em>slice</em> the lines between triple quotation marks. Or, we can calculate the number of lines of docstring and decrease it from the total value of valid lines at the end. However, we need to know the indices (or, indexes) for that job. To get the indices of lines in a file, I already have given the hint of <em>enumerating</em>, which might come in handy. </p>
<p>That is okay. However, it is easy to complicate things. Consider the example below:</p>
<pre><code class="language-python">def summon_item(item):
    result = f&#39;Accio {item}!&#39; # Do the Accio spell
    return result 
</code></pre>
<p>If we were to look for a line with a hashtag in it to ignore it, in this example, we would be ignoring the line where we create the <code>result</code> variable. This is not good. And, although inline comments are <a href="https://peps.python.org/pep-0008/#inline-comments" target="_blank" rel="noopener noreferrer">not very encouraged to use in Python</a>, they exist nonetheless. The one way to get around that, of course, is to look if the <em>left</em> side of the hashtag is <em>whitespace</em> or not — which might look something like this:</p>
<pre><code class="language-python">has_inline_comment = &#39;#&#39; in line and not line.split(&#39;#&#39;)[0].isspace()
</code></pre>
<p>In this case, <code>has_inline_comment</code> is a boolean variable that checks if the left side of the hashtag contains only whitespace characters. </p>
<p>Of course, this is just one way to do it for solving this specific little issue, there are surely better ways to do it. As always, there are many ways to solve a problem, and that is the beauty of programming and computer science in general. Again, at anytime in doubt, <a href="https://docs.python.org/3/index.html" target="_blank" rel="noopener noreferrer">the documentation</a> is your friend.</p>
<h2>Pizza Py</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/6/pizza/" target="_blank" rel="noopener noreferrer">This problem</a> is easy to implement if you have already watched the lecture. This time we work with <code>csv</code> files, with a help from Python&#39;s own <code>csv</code> module. We have two files, <code>regular.csv</code> and <code>sicilian.csv</code> which we can download into our directory with <code>wget</code> command. We are still checking for the too few or too many command-line arguments, as well as checking if the file is in the right format and catching the <code>FileNotFoundError</code>. There is no reason to go over these since we have already done implemented them exactly in the previous problem. Throughout these posts, I constantly remind the importance of the reading the documentation correctly, and again, this problem is another example to remind us of it. The <code>tabulate</code> library&#39;s <a href="https://pypi.org/project/tabulate/" target="_blank" rel="noopener noreferrer">documentation</a> <em>literally</em> tells you how to solve this problem. Using a simple <em>reader</em> object for our <code>csv</code> files — whose <em>first rows</em> we can consider as <em>headers</em> — is more than enough to tabulate it. Remember that we are using the grid <em>table format</em>, and specifying the <em>headers</em>. Enough with the hints, the solution is already <em>literally</em> in the documentation itself. Let&#39;s look at the next problem.</p>
<h2>Scourgify</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/6/scourgify/" target="_blank" rel="noopener noreferrer">this problem</a>, we are casting a spell! Well, you may already be thinking that writing in Python is like magic itself — I mean, it even reads like English. However, let&#39;s not lose ourselves in the appreciation of Python, but take a look at this problem.</p>
<p>We need to clean the data that we are given. In this case, we are again working with a <code>csv</code> file. We take an input file and need to create an output as a &quot;cleaned&quot; version of the input. We have two fields, <code>name</code> and <code>house</code>. The <code>name</code> field has the first and last name of the students all in one place inside a quotation mark, and we need to <em>split</em> them. We have been splitting strings for a while, so we know what to do here. We also have been checking for similar edge cases for the previous problems this week, only remember that this time, our command-line arguments has the length of three — as we include both the input and output filenames. Now, let&#39;s think about it. How to go about creating an output file that has the clean data?</p>
<p>The one thing we need to do is to <em>open</em> up an output file to <em>write</em> on it, create a <code>DictWriter</code> instance with the appropriate <code>fieldnames</code>, and <em>write the header</em>. These are, again, given in the &quot;hints&quot; section of the problem explanation, as well as <em>literally</em> in <a href="https://docs.python.org/3/library/csv.html#csv.DictWriter" target="_blank" rel="noopener noreferrer">the documentation</a>. I mean, the documentation actually provides you with enough knowledge on how to do it, no more no less. At this point, we need to open up the input file in <em>reader</em> mode, and read each <em>row</em> so that we can split the names appropriately. But, as we read each row, we also need to <em>write a row</em> to our output file — which is, again, shown to you in the example in the documentation link above. That is actually all that we need to do. Perhaps what might be tricky is when to open the files. You might already know that using <code>with open()</code> for files closes them automatically so that you do not have to be bothered with closing the files manually. So, at some point in this problem, you may have come across with this beautiful looking error:</p>
<pre><code class="language-shell">ValueError: I/O operation on closed file.
</code></pre>
<p>Well, now that you can guess exactly the reason of that, you may consider using the <code>with open()</code> block inside another. Or, again, you can come up with many ways to solve it, this is just one way to do it. Perhaps with much more practice, we can refine our taste of solutions gradually. But now, let&#39;s take a look at the final problem of this week.</p>
<h2>CS50 P-Shirt</h2>
<p>For <a href="https://cs50.harvard.edu/python/2022/psets/6/shirt/" target="_blank" rel="noopener noreferrer">the last problem</a> of the week, we are to solve a fun problem, where we need to make Muppets wear <a href="https://cs50.harvardshop.com/products/i-took-cs50-unisex-t-shirt" target="_blank" rel="noopener noreferrer">I took CS50</a> shirts. For those who are familiar with the CS50x itself, I am also a fan of <a href="https://cs50.harvardshop.com/collections/limited-run/products/i-finished-tideman-cs50-t-shirt" target="_blank" rel="noopener noreferrer">I finished Tideman shirts</a>, which speaks a lot about <a href="https://cs50.harvard.edu/x/2022/psets/3/tideman/" target="_blank" rel="noopener noreferrer">that famous problem</a>. Passing the tests of <code>check50</code> for it is a kind of spiritual experience which I recommend to anyone who is willing to go through it, but anyway, let&#39;s not digress, and look at our problem at hand.</p>
<p>We are using the <code>Pillow</code> library, perhaps the most handy library for working with images in Python. It is vast, hence its documentation; but we are given pretty much all that we need to do in the hints of the problem explanation itself. Even if this problem looks daunting, fear not, because we are going to have fun, and only barely scratching the surface of the <code>Pillow</code> library.</p>
<p>Since the hints are already quite extensive, let&#39;s take a look at mainly the trickiest part: pasting an image onto another.</p>
<p>Consider this night sky image:</p>
<p><img src="https://images.unsplash.com/photo-1520034475321-cbe63696469a?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1470&q=80" alt="Night sky. Credit: Jack Weirick (@weirick) on Unsplash"></p>
<p>Let&#39;s say we want to paste this <code>png</code> image representing Saturn onto our night sky:</p>
<p><img src="https://cdn.pixabay.com/photo/2012/04/10/17/38/saturn-26618_960_720.png" alt="Saturn png image. Credit: pixabay"></p>
<p>Our code might look like this:</p>
<pre><code class="language-python">from PIL import Image, ImageOps


def main():
    saturn = Image.open(&#39;saturn.png&#39;)
    night_sky = Image.open(&#39;night-sky.jpg&#39;)
    result = ImageOps.fit(night_sky, saturn.size)
    result.paste(saturn, saturn)
    result.save(&#39;result.jpg&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>In this case, our <code>result.jpg</code> will look like this:</p>
<p><img src="/blog/post-images/2022-05-17/result.jpg" alt="Result image with Saturn pasted on Night Sky"></p>
<p>Opening the images is straightforward. If you look in <a href="https://pillow.readthedocs.io/en/stable/reference/ImageOps.html#PIL.ImageOps.fit" target="_blank" rel="noopener noreferrer">the documentation</a> for <code>ImageOps.fit()</code>, it is quite explanatory as well:</p>
<blockquote>
<p>Returns a resized and cropped version of the image, cropped to the requested aspect ratio and size.</p>
</blockquote>
<p>And, the <code>paste()</code> <a href="https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.paste" target="_blank" rel="noopener noreferrer">function</a>, takes three arguments: <code>im</code> to paste, <code>box</code> for the region to paste into, and <code>mask</code> for mask image. Since we adjusted sizes to <em>fit</em>, we do not need to specify <code>box</code>. In <code>result.paste(saturn, saturn)</code>, the first <code>saturn</code> is the image to paste, and the second one is the mask image for updating only the specific pixels in this case. From the documentation: </p>
<blockquote>
<p>If a mask is given, this method updates only the regions indicated by the mask. (...) Where the mask is 255, the given image is copied as is. Where the mask is 0, the current value is preserved.</p>
</blockquote>
<p>Because our <code>png</code> image has <a href="https://en.wikipedia.org/wiki/Alpha_compositing" target="_blank" rel="noopener noreferrer">alpha channel</a> for transparency — value of 0 usually indicates full transparency —, the original image to be pasted on will be preserved for these transparent pixels. Actually, why don&#39;t we look at some of these pixel values of our own Saturn image:</p>
<pre><code class="language-python">print(list(saturn.getdata(band=3))[:100])
</code></pre>
<p><code>band=3</code> indicates the alpha channel, and we are getting the first 100 values. We are also converting it into a <code>list</code> to see it.</p>
<p>The output looks like this:</p>
<pre><code class="language-python">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 2, 0, 0, 0, 0, 0, 0, 3, 22, 42, 62, 82, 111, 135, 147, 160, 173, 186, 199, 211, 224, 237, 244, 242, 241, 239, 237, 236, 234, 233, 231, 230, 221, 206, 192, 179, 165, 150, 136, 122, 108, 94, 81, 67, 51, 35, 19, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 3, 2, 2, 1, 0, 0, 0, 0]
</code></pre>
<p>We have a bunch of zeroes! In this case, we know that the pixels of our original <code>jpg</code> image will not be lost when these transparent pixels are pasted onto it because the &quot;mask&quot; argument exactly takes care of that issue.</p>
<p>Since we also need to implement the error-checking (which we have done a lot and know how to think about and do at this point), and the rest is again <em>literally</em> given in the hints sections in the problem explanation, there is not much left to it at all. Now that we have even seen a little behind-the-scenes of the usage of <code>Pillow</code> library for this problem, there is nothing to stop us from being encouraged to pass the tests for this problem. You can also take a look at <a href="https://realpython.com/image-processing-with-the-python-pillow-library/#superimposition-of-images-using-imagepaste" target="_blank" rel="noopener noreferrer">this Real Python article</a> to learn more about using <code>Pillow</code>.</p>
<p>Next week, we are diving into the world of Regular Expressions, which is, admittedly, can be a bit of a nuisance for beginners. But, have no worries, it is actually a superpower in disguise, and it is going to be fun to use them in the next week&#39;s problem set. </p>
<p>Until then, happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-6</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-6</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 17 May 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 5]]></title>
            <description><![CDATA[<p>It might be true that testing code sometimes seem like a waste of time to a novice programmer. It may seem that you have to put extra effort to write some tests for your code to see if it is working properly. Maybe you have already done some &quot;testing&quot; on your own, plugging different variables here and there. So, why should you even spend another slice of your time to write tests? Well, if you have such thoughts, get ready to appreciate the value of writing tests, because, on <a href="https://cs50.harvard.edu/python/2022/weeks/5/" target="_blank" rel="noopener noreferrer">this week on Unit Tests</a>, we have some exciting problems to solve. </p>
<p>As it is pointed out in the lecture, the earlier you get into the habit of testing your code, the better. Unit tests kind of tell a story about your program, and how it should work. Writing good tests not only makes your program more robust, but it is also an indication that you have precisely defined how your program should behave and what to expect. </p>
<p>This week, we are visiting some old problems we have solved throughout this course to write tests for them. Instead of using Python&#39;s <a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener noreferrer">built-in unittest module</a>, we are going to use the beautiful <a href="https://docs.pytest.org/" target="_blank" rel="noopener noreferrer">pytest library</a> to implement our tests. Actually, you are already given hints weeks ago to solve all the problems of this week, so, in this post, there will be shorter paragraphs under each problem&#39;s header — except for the first one, which we shall see the crux of this week&#39;s problem set. </p>
<p>As always, I assume you have read the problem explanations, and I have to give the <strong>disclaimer</strong> that these posts are intended as a guide, or, (like today) just musings about the problem sets. Let&#39;s begin.</p>
<h2>Testing my twttr</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/5/test_twttr/" target="_blank" rel="noopener noreferrer">this problem</a>, we are reimplementing <a href="https://cs50.harvard.edu/python/2022/psets/2/twttr/" target="_blank" rel="noopener noreferrer">Setting up my twttr</a> from Problem Set 2 to write some tests for it. Since <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-2/" target="_blank" rel="noopener noreferrer">we have already seen</a> how that problem could be solved, there is no need to go over it again. We need to create two files, called <code>twttr.py</code> and <code>test_twttr.py</code>, inside a new directory called <code>test_twttr</code>.<br>We only need to restructure our code if it is different from what is given in the problem explanation, separating <code>shorten</code> and <code>main</code> functions. </p>
<p>It is kind of like you are writing <code>check50</code> for your own code, and, <code>check50</code> checks your own <code>check50</code>!</p>
<p>Now, how can we go about thinking of what kinds of tests to implement? To be honest, the answer to that question is hidden inside the <em>original</em> problem descriptions, specifically, the explanations of <em>how to test</em> them. However, there might be an issue: the tests that you write must catch the same bugs that the staff version looks for. So, this week, <code>check50</code> is the kind of the hint itself: Its tests are actually the edge cases that you should be considering. It is the ultimate test to test your tests! Pretty sure, the CS50 staff wrote tests on their own to check <code>check50</code> as well... But, that is another thing to think about later. For this week, the main thing to consider is to implement the original tests from the original problems themselves. So, if that original problem&#39;s <code>check50</code> was testing certain inputs, you should create your tests similar to those tests that once tested your code for that problem.</p>
<p>I know, it was painful to read and perhaps hard to wrap your mind around, but hopefully the idea is clear. It took me longer to figure that out!</p>
<p>So, in the first problem, we know that the <code>shorten</code> function expects a <code>str</code>, so, we can test it by <em>asserting</em> that for a given string, our function outputs the vowel-stripped version of it. I cannot outright give a hint of what other tests should look like, but you are already given the answer three weeks ago. </p>
<p>The main thing to do here is to write simple <code>assert</code> statements inside our test functions. Say, we want to test if a <code>cast_spell</code> function works:</p>
<pre><code class="language-python"># 📁 spells.py

def cast_spell(incantation):
    return f&#39;{incantation.upper()}!&#39;
</code></pre>
<p>A test for it would be like:</p>
<pre><code class="language-python"># 📁 test_spells.py

from spells import cast_spell

def test_cast_spell():
    assert cast_spell(&#39;lumos&#39;) == &#39;LUMOS!&#39;
    assert cast_spell(&#39;expecto patronum&#39;) == &#39;EXPECTO PATRONUM!&#39;
</code></pre>
<p>Also, we do not need any kind of <code>try...except</code>, because <code>pytest</code> generously takes care of that. Let&#39;s now take a look at the next one.</p>
<h2>Back to the Bank</h2>
<p>Again, in <a href="https://cs50.harvard.edu/python/2022/psets/5/test_bank/" target="_blank" rel="noopener noreferrer">this problem</a>, we are reimplementing another past problem, namely <a href="https://cs50.harvard.edu/python/2022/psets/1/bank/" target="_blank" rel="noopener noreferrer">Home Federal Savings Bank</a>. It was an easy and fun problem to solve, as <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-1/" target="_blank" rel="noopener noreferrer">we have done it before</a>. </p>
<p>We know that the <code>value</code> function should return an <code>int</code>. And, for the tests? Well, the original problem explanation literally tells you that. Three kinds of tests (<em>literally</em> given to you before) — with two variations (for uppercase and lowercase) — should suffice. </p>
<h2>Re-requesting a Vanity Plate</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/5/test_plates/" target="_blank" rel="noopener noreferrer">this problem</a>, we are visiting the good old <a href="https://cs50.harvard.edu/python/2022/psets/2/plates/" target="_blank" rel="noopener noreferrer">Vanity Plates</a> from Problem Set 2. We have already <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-2/" target="_blank" rel="noopener noreferrer">went through it before</a>. The main thing is to use the kinds of tests and inputs that the staff used to check our problem — which is also given in the <em>original</em> problem explanation. If they are not enough, well, remember there was also a test for the full alphabetical string — which should be valid as long as its length is within the limits.</p>
<h2>Refueling</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/5/test_fuel/" target="_blank" rel="noopener noreferrer">the last problem</a> of this week, we go back to <a href="https://cs50.harvard.edu/python/2022/psets/3/fuel/" target="_blank" rel="noopener noreferrer">Fuel Gauge</a>, which <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-3/" target="_blank" rel="noopener noreferrer">we have seen before</a> on the week on Exceptions. Again, we need to implement the same kind of tests as the <code>check50</code> for the original problem, and the cases to consider are clear in the <em>original</em> problem explanation once more. The new thing here is handling the exceptions with <code>pytest</code>. As always, <a href="https://docs.pytest.org/en/latest/how-to/assert.html#assertions-about-expected-exceptions" target="_blank" rel="noopener noreferrer">the documentation</a> itself clearly shows you how to do that. For example, we can look at how to handle a <code>ValueError</code> in our <code>cast_spell</code> function:</p>
<pre><code class="language-python"># 📁 test_spells.py

import pytest

from spells import cast_spell

def test_valid_type():
    with pytest.raises(ValueError):
        cast_spell(62442)
</code></pre>
<p>Now, <code>pytest</code> will make sure that passing <code>62442</code> as the input to <code>cast_spell</code> function results in a <code>ValueError</code>. And, that is pretty much it for this problem as well.</p>
<p>I know, this week was a bit confusing. I cannot give many hints this week, but you have a better place to go for hints: <code>check50</code> itself for the original problems. The CS50 staff has already considered many edge cases, so, you do not even have to come up with your own examples. You are only implementing the same <code>check50</code> tests that once checked your own code! It is quite satisfying to think about.</p>
<p>Next week, we are going to dive into the world of File I/O, and perhaps of some exciting libraries as well. Until then, happy coding!</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-5</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-5</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 11 May 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 4]]></title>
            <description><![CDATA[<p>It is time for another problem set, and this time, we are diving into a very delicious topic: libraries.</p>
<p>When I say delicious, I mean it because of our ability to have a plethora of quality choices when it comes to modules and third-party libraries in Python. Let alone third-parties, Python itself comes with a bunch of <a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener noreferrer">built-in modules</a> that are pretty useful for the problems you are trying to solve. With the package manager as well, these days there is a library almost for anything, and I mean, <em>anything</em>.</p>
<p><img src="https://imgs.xkcd.com/comics/python.png" alt="xkcd: Python (import antigravity)"></p>
<p>Well, maybe you cannot actually import antigravity and fly —yet—, you can at least find a lot of helpful stuff with <a href="https://pypi.org/" target="_blank" rel="noopener noreferrer">the Python Package Index</a>. (And, by the way, <code>antigravity</code> module is an easter egg. So you can actually <a href="https://pypi.org/project/antigravity/" target="_blank" rel="noopener noreferrer">import it</a>).</p>
<p>Before we start, you can find the posts on previous problem sets <a href="https://rivea0.github.io/blog/" target="_blank" rel="noopener noreferrer">here in the archive</a>. And I have to give the usual <strong>disclaimer</strong>, I do not provide full solutions here, so if you are scrolling down trying to find the code block that will make you pass the tests, you are wasting your time, and that is a bit sad, my friend. It is a much stronger dopamine rush when it is <em>you</em> who investigate and find the solutions. I am here to talk about the problem sets and to be a guide along the way.</p>
<p>With all that talk, let&#39;s take a look at the problems we need to tackle this week.</p>
<h2>Emojize</h2>
<p>In each post, I assume you have read the problem explanations already. If you did, <a href="https://cs50.harvard.edu/python/2022/psets/4/emojize/" target="_blank" rel="noopener noreferrer">this one</a> is very easy, considering you already know how to import libraries and use them. And, explanation hints out the library you are going to use, namely <code>emoji</code>. It provides <a href="https://pypi.org/project/emoji/" target="_blank" rel="noopener noreferrer">some examples</a> on how to use it. So in this case, you do not need to hunt for a specific usage, but it is literally in front of you. The main thing not to forget here, is to provide <em>aliases</em> as well.</p>
<h2>Frank, Ian and Glen’s Letters</h2>
<p>As we will see throughout the other problems this week, clear documentation is a very important thing to have when it comes to using third-party libraries. Without the hints that the <a href="https://cs50.harvard.edu/python/2022/psets/4/figlet/" target="_blank" rel="noopener noreferrer">problem explanation</a> gives, you have to look for the usage of the library <code>pyfiglet</code> reading <a href="https://pypi.org/project/pyfiglet/0.7/" target="_blank" rel="noopener noreferrer">the project description</a>. (By the way, I think the reason why CS50 put the link to an older version of the package on PyPI is that the project description is provided there. If you click on the newer version, there is no description given, but you can find <a href="https://github.com/pwaller/pyfiglet/blob/master/README" target="_blank" rel="noopener noreferrer">here on GitHub</a>).</p>
<p>We need to render an input text into a cool ASCII art version. Again, the explanation page gives a lot of hints, but let&#39;s see.</p>
<p>Before everything else, we need to do something <em>only if</em> we have zero or two command line arguments. Since the name of the program is also an argument, we have 1 command line argument by default. Such that:</p>
<pre><code class="language-shell">$ python something.py # len(sys.argv) == 1
</code></pre>
<pre><code class="language-shell">$ python something.py --someflag # len(sys.argv) == 2
</code></pre>
<p>In case of 1 argument —which is just the name of the file—, we need to make a <em>random choice</em> to get a font from all the fonts provided. Getting all the fonts is simple as we are given the hint:</p>
<pre><code class="language-python">f = Figlet()
fonts = f.getFonts() 
</code></pre>
<p>Here, <code>fonts</code> is a list that we can make a <em>random choice</em> out of. As to making that <em>choice</em>, I think I have given enough of a hint already. If you did not get it, remember that <a href="https://docs.python.org/3/library/random.html" target="_blank" rel="noopener noreferrer">the documentation</a> is always there to look things up.</p>
<p>After we have a random font and an input text as well, we just need to instantiate a Figlet, set its font, and render text (which you can just <code>print</code> to see it in terminal):</p>
<pre><code class="language-python">f = Figlet()
f.setFont(font=random_font)
print(f.renderText(text))
</code></pre>
<p>This was for the random font if the user does not provide a font themselves. If they do, we need to do these exact steps with the given font instead of <code>random_font</code> here (which you can get with something like <code>sys.argv[2]</code>). But we do it <em>only if</em> the length of the arguments is 3 (remember the filename also counts), and <code>sys.argv[1]</code> is actually either <code>-f</code> or <code>--font</code>; also as long as <code>sys.argv[2]</code> is <em>in</em> the <code>fonts</code>. You can just do it with one line of conditional, using <code>and</code> and <code>or</code> operators. I cannot give any more hints without giving outright the answer. After all that is done (if the command-line arguments do not fit into these two conditional branches), we just exit the program with <code>sys.exit(&#39;Invalid argument&#39;)</code>. </p>
<p>That was actually fun. Now let&#39;s take a look at the next one.</p>
<h2>Adieu, Adieu</h2>
<p>I cannot believe I have not heard of <a href="https://pypi.org/project/inflect/" target="_blank" rel="noopener noreferrer">this library</a> before. You know, it is just things like these that make you fall in love with Python again, and again. Thank you CS50 for introducing me to it in <a href="https://cs50.harvard.edu/python/2022/psets/4/adieu/" target="_blank" rel="noopener noreferrer">this problem</a>. </p>
<p>These kinds of problems — like joining all names and adding <code>, and</code> for the last item — can be solved in many ways, including recursion. But here, with Python, it is just one line of code. Forget antigravity, this is another kind of superpower. </p>
<p>Borrowing from the ideas of last week&#39;s problem sets, we also need to keep getting input until the user hits control-d. This is an implication of using an infinite loop and handling <code>EOFError</code> exception. And, that is really it. Considering you have looked at the project description for <code>inflect</code>, everything you need is provided for you. Just remember to start the engine for the program like this:</p>
<pre><code class="language-python">import inflect

p = inflect.engine()
</code></pre>
<p>And, all you need to do is to <em>join</em> the names you have been collecting from the inputs. All the methods you can use from the <code>inflect</code> library are in front of you. As always, learn to love the documentation. </p>
<h2>Guessing Game</h2>
<p>The only thing we need to import for <a href="https://cs50.harvard.edu/python/2022/psets/4/game/" target="_blank" rel="noopener noreferrer">this problem</a> is Python&#39;s built-in <code>random</code> module. To be honest, I do not think the solution I came up with was an elegant one. Elegant or not, if we think about it, we need to continually get one input for the level, another one for the guess. When it comes to level, we should keep asking as long as it is not a positive integer; and when it comes to guess, we should keep asking as long as it is not the correct number. There are different ways to implement the solution, the certain thing is that we need to get a <em>random integer</em> between 1 and level — which can be solved easily with Python&#39;s <code>random</code> module. One way to do it is to use a loop and <code>try...except</code> block to ensure our input is of correct value. After we generate a random integer, we can use another loop to keep asking the user for a guess. If the guess matches that number generated, we simply print <code>Just right!</code> and return or break out of the loop. For the cases that guess is less than or more than the number, we provide the appropriate outputs <code>Too small!</code> or <code>Too large!</code>, and keep asking. One thing to keep in mind is that, we need to compare the guess and that randomly generated number as long as the guess is a positive number, or just more than 0. And, that is it.<br>By the way, guessing game has a deep relationship with <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank" rel="noopener noreferrer">binary search algorithm</a>, with which you can guess the answer correctly in <a href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time" target="_blank" rel="noopener noreferrer">log(n) time</a>.</p>
<h2>Little Professor</h2>
<p>I believe, with <a href="https://cs50.harvard.edu/python/2022/psets/4/professor/" target="_blank" rel="noopener noreferrer">this one</a>, this is the time the curve becomes steeper, and the problem sets we will see from now on will become slightly heavier than what we have been seen so far. But, let&#39;s not get caught up in this, and take a look at this problem.<br>We have four specifications to consider. For the first one, we should get an input for level only if it is 1, 2, or 3. Say, we have a <code>valid_inputs</code> tuple, we can check if the input value is in that collection:</p>
<pre><code class="language-python">valid_inputs = (1, 2, 3)
level = int(input(&#39;Level: &#39;)) # Let&#39;s say it is 4
print(level in valid_inputs) # False
</code></pre>
<p>And what do we do with it? After getting the valid level, we need to generate an integer with <em>level</em> number of digits. Like this:</p>
<pre><code>-&gt; level = 1:
-&gt; 0 &lt;= integer &lt;= 9

-&gt; level = 2:
-&gt; 10 &lt;= integer &lt;= 99

-&gt; level = 3:
-&gt; 100 &lt;= integer &lt;= 999
</code></pre>
<p>If the level is 1, the number we need to generate should be between 0 and 9 inclusive, and if the level is 2, the number should be between 10 and 99, and finally if the level is 3, the number should be between 100 and 999. All inclusive of course. Now, it is enticing to use conditionals, but there is always another approach. Let&#39;s try something different.</p>
<p>We want these levels to correspond with these ranges. One data structure that comes to mind for this kind of usage is a dictionary. Something like this, perhaps:</p>
<pre><code class="language-python">range_levels = {
    1: (0, 9),
    2: (10, 99),
    3: (100, 999)
}
</code></pre>
<p>That is alright. When we print <code>range_levels[1]</code> it should output <code>(0, 9)</code>. But what if we want to pass these two values, 0 and 9, separately inside a function. A function that will help us get a <em>random integer</em>. Instead of giving you the answer, I am going to mention a cool thing you can do with Python — namely, <a href="https://geekflare.com/python-unpacking-operators/" target="_blank" rel="noopener noreferrer">unpacking operators</a>. The idea is basically that you can use <code>*</code> operator to unpack an iterable, and <code>**</code> to unpack a key-value pair. Like this:</p>
<pre><code class="language-python">values = [0, 5, 2]
print(*values) # 0 5 2

# Prints 0, 2, 4 respectively
for i in range(*values):
    print(i)


houses = {
    &#39;Gryffindor&#39;: &#39;courage&#39;,
    &#39;Ravenclaw&#39;: &#39;intelligence&#39;,
    &#39;Hufflepuff&#39;: &#39;loyalty&#39;,
    &#39;Slytherin&#39;: &#39;ambition&#39;
}

people = {
    &#39;Harry Potter&#39;: &#39;Gryffindor&#39;,
    &#39;Hermione Granger&#39;: &#39;Gryffindor&#39;,
    &#39;Luna Lovegood&#39;: &#39;Ravenclaw&#39;
}

print({**houses, **people}) # {&#39;Gryffindor&#39;: &#39;courage&#39;, &#39;Ravenclaw&#39;: &#39;intelligence&#39;, &#39;Hufflepuff&#39;: &#39;loyalty&#39;, &#39;Slytherin&#39;: &#39;ambition&#39;, &#39;Harry Potter&#39;: &#39;Gryffindor&#39;, &#39;Hermione Granger&#39;: &#39;Gryffindor&#39;, &#39;Luna Lovegood&#39;: &#39;Ravenclaw&#39;}
</code></pre>
<p>(As you can see, we cannot unpack a dictionary to a single variable, but rather we can use it to merge dictionaries!)</p>
<p>To be honest, you do not need to know about the unpacking feature for this problem. It is just a cool thing to use. And look at how we can use this feature inside the <code>range</code> function for our <code>for</code> loop. <code>range</code> expects three arguments as start, end, and step. In that case, as we see in the example, <code>for i in range(*values)</code> will be the same as <code>for i in range(0, 5, 2)</code>. Amazing!</p>
<p>In the problem, we also need to print <code>EEE</code> for wrong answers, and provide the user with 3 choices in total to get a right answer. But overall, we need to ask 10 questions. So, a double loop might be reasonable to use here. If the outer loop keeps track of 10 questions, the inner loop can keep track of 3 times of the same question asked. If the user gives the correct answer, we can break out of the inner loop. If the inner loop is completely done (which means asked the same question three times), we need to print the correct answer before moving on to another question. Accordingly, we also keep the score of the user. Simply increasing a score count variable when given the correct answer is sufficient. And, there is really nothing much to it if you correctly implement <code>get_level</code> and <code>generate_integer</code>, and are careful with the loops and when you break out of them. The unpacking examples I give here are simply fun to know, even if that is not necessary to use for this problem. Now, finally, on to the last one.</p>
<h2>Bitcoin Price Index</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/4/bitcoin/" target="_blank" rel="noopener noreferrer">This one</a> seems daunting at first, but it is really easy. If the number of command-line arguments is not 2, we need to exit the program with <code>Missing command-line argument</code>. If we cannot convert the second argument into float, we exit with <code>Command-line argument is not a number</code>. After that, using the <code>requests</code> library, we get a response from <a href="https://api.coindesk.com/v1/bpi/currentprice.json" target="_blank" rel="noopener noreferrer">the URL</a> provided in the problem explanation. Since it is in JSON format, it will be reasonable to use just the right method for that. Here is the tricky part: how to convert the <em>rate</em> string, something like 37,769.6060 into float? Well, perhaps getting rid of the comma might help us. And, how to do that? If we think of removing a character as simply <em>replacing</em> it with <em>nothing</em>, we are on the right track. Afterwards, simply calculating the amount with number of bitcoins that are provided as a command-line argument and printing the formatted result is enough to finish this problem. And how to do that is <em>literally</em> given as a hint in the problem explanation.</p>
<p>Finally, this week on libraries has come to an end as well. We have seen somewhat heavier problems this time, and to be honest, I expect the problems in the upcoming weeks to become gradually harder. But it is actually something to be excited for. I hope you have learned lots of new things this week, and —if you are like me— have fallen in love with Python once again. </p>
<p>See you next week for the problem set of Unit Tests. Happy coding!</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-4</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-4</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 03 May 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 3]]></title>
            <description><![CDATA[<p>On this week&#39;s problem set on <a href="https://cs50.harvard.edu/python/2022/psets/3/" target="_blank" rel="noopener noreferrer">Exceptions</a>, we are given four problems this time, instead of five. The problem explanations are quite comprehensive; which I assume you read beforehand. Reminding the <strong>disclaimer</strong> that these blog posts are only for a walkthrough of the problems, let&#39;s tackle them one by one.</p>
<p>You can also read the previous posts on <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-0/" target="_blank" rel="noopener noreferrer">Problem Set 0</a>, <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-1/" target="_blank" rel="noopener noreferrer">Problem Set 1</a>, and <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-2/" target="_blank" rel="noopener noreferrer">Problem Set 2</a>. </p>
<h2>Fuel Gauge</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/3/fuel/" target="_blank" rel="noopener noreferrer">This</a> is a problem where we need to take a user input which we assume to be formatted as <code>X/Y</code>, and display how much fuel left in the tank as a percentage. We are mostly dealing with integer division and exception handling here. Considering we have been getting input from the user for the past problems already, we know how to handle the input accordingly, say, for <em>splitting</em> a string with the format <code>X/Y</code>. Remember that when we split a sentence into words, the default split character is the space character. So if we want to split a string like <code>1+2</code> into two numbers, using <code>&#39;1+2&#39;.split(&#39;+&#39;)</code> will give a list containing <code>1</code>, and <code>2</code>.</p>
<p>Before we do any error checking though, we need to get the result as a percentage. And, before getting the result, it might be a better idea to check if the value of <code>x</code> is not larger than <code>y</code>; then calculating the result accordingly. You must be mostly familiar with converting decimals to percentages from elementary school math. In this case, just multiplying the result of the given fraction with 100 is enough. Then, as the problem explanation says, if the overall result is more than 99, we print <code>F</code> to indicate the fuel tank is full; if it is less than 1, we print <code>E</code> to indicate it is empty. Otherwise, we print the percentage, which is done easier with an f-string. We also need to print it with <em>zero</em> decimal places — remember putting something like <code>:.1f</code> after a float type formats it to have 1 place after the decimal, but in this case, we want <em>zero</em> decimal places.</p>
<p>The main thing to consider is handling the exceptions, of course, wrapping the code in a <code>try...except</code> block. As we also need to keep asking the user if there is a <code>ValueError</code>, or a <code>ZeroDivisionError</code>, what we need to do is similar to the example given in <a href="https://cs50.harvard.edu/python/2022/weeks/3/" target="_blank" rel="noopener noreferrer">this week&#39;s lecture</a> — wrapping the exception handling inside an infinite loop which we can break out of with returning the formatted percentage result. And, that is really all there is to it, let&#39;s look at the next one.</p>
<h2>Felipe&#39;s Taqueria</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/3/taqueria/" target="_blank" rel="noopener noreferrer">Here</a>, we are already given the menu entrées as a dictionary, the only thing for us to do is to get the user input for an item in the menu, and <em>accumulate</em> the total result of each item that they put in. Of course, we also need to print the total result. Similar to the examples in this week&#39;s lecture and the Fuel Gauge problem, we can use an infinite loop to continue getting input from the user. We also need to convert the input into <em>titlecase</em> for it to match the keys in our given dictionary as well. In case of an invalid item which will result in a <code>KeyError</code>, say <code>Burger</code>, we can ignore it (simply, <em>pass</em>) and continue asking the user for an item. If the user hits control-d (a common way to stop the inputs) which will result in an <code>EOFError</code> (end-of-file condition), it is time to stop the program, we can do that by returning from the function after printing a newline.<br>Well, that was easy. On to the next problem.</p>
<h2>Grocery List</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/3/grocery/" target="_blank" rel="noopener noreferrer">This problem</a> is also similar to the ones we did before, and it is very easy to implement if you like using dictionaries. Just like the previous two problems, we need to keep getting input — which we did before by putting the <code>try...except</code> block inside an infinite loop, and returning (if we use it inside a function) at the right time to break out of it. We can use a dictionary to add the items and increment each of the item&#39;s value if it is already in the dictionary. Actually, let&#39;s see something similar in action. Let&#39;s say we want to get the names of spells that Harry Potter has cast in a day, as well as how many times they are used. Perhaps the most intuitive way to do it is similar to this one:</p>
<pre><code class="language-python">spells = {}
while True:
    try:
        spell = input()
        if spell in spells:
            spells[spell] += 1
        else:
            spells[spell] = 0
    except EOFError:
        break
</code></pre>
<p>So, if our input is something like this one:</p>
<pre><code>Accio
Accio
Lumos
Expelliarmus
Expelliarmus
Expelliarmus
</code></pre>
<p>Printing each value and key in our <code>spells</code> dictionary will give this output:</p>
<pre><code>2 Accio
1 Lumos
3 Expelliarmus
</code></pre>
<p>However, we can do a one-liner instead of the one we used with an <code>if...else</code> condition. We can use this version instead:</p>
<pre><code class="language-python">spells = {}
while True:
    try:
        spell = input()
        spells[spell] = spells.get(spell, 0) + 1
    except EOFError:
        break
</code></pre>
<p>What the <code>get</code> function does here is literally getting the <code>spell</code> from the <code>spells</code> dictionary, and providing a default value of <code>0</code> if it is not in the dictionary. We add <code>1</code> to the whatever value that is returned by the <code>get</code> function to increment it. This will give the same output as above if we print each value and key of our dictionary.<br>Of course, as in the problem demo, printing the value and keys is only done after the user hits control-d — in other words, after our program has an <code>EOFError</code>. Checking the documentation as we always do before, there are many useful methods to iterate through the <em>items</em> of a dictionary. And, if we want our output to be <em>sorted</em>, well, we can <em>literally</em> check the documentation. Since I cannot give any more hints without giving out the solution itself, it is time to move on to the next problem.</p>
<h2>Outdated</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/3/outdated/" target="_blank" rel="noopener noreferrer">the last problem</a> of this week, we need to get a user input for a date in the month-day-year format, and output it in the year-month-day format. The input we are given can look like <code>9/8/1636</code>, or <code>September 8, 1636</code> (yes, an Easter egg: the year Harvard University was <a href="https://www.harvard.edu/about/history/" target="_blank" rel="noopener noreferrer">founded</a>). Here, we need to do a bit of splitting and some string formatting. We can use the same idea of an infinite loop like before to keep getting the user input, only returning the result when it is appropriate. Since we have two kinds of inputs to handle — the one with forward slashes (<code>/</code>), and the other with a comma and a space (<code>, </code>) —, we can use two branches for a conditional. Hints in the problem description are quite helpful on splitting a string, which you must be pretty familiar with already. We are also given a list of months in the problem explanation page, and in order to get the value of an inputted month, we can add 1 to the index of that month in that list. Lastly, we can print the formatted result and break — or, if using a function return with the string of our result. But, we need to format the day and month to be two digits, and depending on how you implement it, you can format an int to have two leading zeroes with <code>f&#39;{n:02}&#39;</code>, or a string with a very handy <code>zfill</code> function. Taken from the documentation, what it does is this:</p>
<pre><code class="language-python">&gt;&gt;&gt; &quot;42&quot;.zfill(5)
&#39;00042&#39;
</code></pre>
<p>It is self-explanatory indeed. The main thing we always need to do is error-checking, in this case the problem description does not provide a specific exception to handle and that is mostly because you can implement the solution in many different ways. But, one thing we need to make sure of is that the month and day should be within bounds, say if a user gives an input <code>23</code> in place of the month, we should prompt them again. We can make sure of this by simply returning the result string only when this conditional is met. After that, the exceptions that you need to deal with actually depends on how your code looks like, but, it mostly makes sense that we might have a <code>ValueError</code>, perhaps an <code>IndexError</code> for dealing with the months list. Since it is you as the programmer who will decide what exception to handle, checking the documentation is the first thing to do. And here, checking out the <a href="https://docs.python.org/3/library/exceptions.html" target="_blank" rel="noopener noreferrer">built-in exceptions</a> is the way to go.</p>
<p>We are at the end of the third week, and next week we are going to finish half the course already! I cannot wait to see what problems we are going to solve for the next week on Libraries, and hope you too as well. Until then, happy coding!</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-3</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-3</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 26 Apr 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 2]]></title>
            <description><![CDATA[<p>Another week, another problem set. This time, we are focusing on loops.<br>You can read the previous posts on <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-0/" target="_blank" rel="noopener noreferrer">Problem Set 0</a> and <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-1/" target="_blank" rel="noopener noreferrer">Problem Set 1</a>. To remind you of the <strong>disclaimer</strong>, these are only walkthroughs to think about the problem itself instead of providing the solution right away. With that said, let&#39;s begin!</p>
<h2>Camel Case</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/2/camel/" target="_blank" rel="noopener noreferrer">this problem</a>, we need to turn a string given in camel case <code>likeThis</code> into a snake case <code>like_this</code> which is recommended in Python for variable names.</p>
<p>Well, since this week is on loops, we can loop through each character one by one. You can think of concatenating each character to a result string, which you can initialize as empty at first. When it comes to an uppercase character —you can get help from the documentation to check if a character <em>is upper</em>—, instead of merely concatenating the character to our result string, you can add an underscore and that character in lowercase.</p>
<p>One thing that Python makes it easier to write one-liners, is <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" target="_blank" rel="noopener noreferrer">list comprehensions</a>. Let&#39;s say we want to work with snake case, and turn it into a nice and readable title string. An easy way to do it would be something like this:</p>
<pre><code class="language-python">snake_case_str = &#39;a_very_important_heading&#39;

result = snake_case_str.replace(&#39;_&#39;, &#39; &#39;).title()

print(result) # A Very Important Heading
</code></pre>
<p>Replacing the underscores with spaces, can also be done in a different way:</p>
<pre><code class="language-python">snake_case_str = &#39;a_very_important_heading&#39;

result = &#39;&#39;.join([&#39; &#39; if char == &#39;_&#39; else char for char in snake_case_str]).title()

print(result) # A Very Important Heading
</code></pre>
<p>It is true that it looks uglier, but we can see how list comprehensions work. It is literally the same as this:</p>
<pre><code class="language-python">snake_case_str = &#39;a_very_important_heading&#39;
result = []

for char in snake_case_str:
    if char == &#39;_&#39;:
        result.append(&#39; &#39;)
    else:
        result.append(char)

result = &#39;&#39;.join(result).title()

print(result) # A Very Important Heading
</code></pre>
<p>The code explains itself, in the list comprehension, we simply loop over the given string, if the character is an underscore we append a space character to our <code>result</code> list, else we append the character itself.  In the end, we use <code>join</code> with an empty string to turn the list into a readable string and use <code>title</code> to make it in title case.</p>
<p>You can use a similar approach if you want to solve this one with a list comprehension. And that is all there is to it. </p>
<h2>Coke Machine</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/2/coke/" target="_blank" rel="noopener noreferrer">This one</a> is reminiscent of the <a href="https://cs50.harvard.edu/x/2022/psets/1/cash/" target="_blank" rel="noopener noreferrer">Cash</a> problem in CS50&#39;s own Introduction to Computer Science, only perhaps a simplified version of it. What to do is simple: we, as a machine, will only accept 25 or 10 or 5 cents for a bottle of Coke we sell for 50 cents.</p>
<p>A <code>while</code> loop might sound more reasonable to use on this one, we can simply check if our amount —which is 50— is still more than 0, in this case we can keep asking the user for input and decreasing from the amount accordingly. One important thing to remember is to check for error handling; now that we are working with integers, it is better to remember that <code>input</code> returns a string, and we need to do type casting. Also, we need to check that the user should only insert either 25, or 10, or 5 cents. If that is the case, we can then decrease the given value from our amount. If they give in total 50 cents, our job is done, and we do not owe them any change. But what if the user gives more than 50 cents? In this case, you can see that if we keep decreasing the amount, we will reach a negative number. Well, since the value itself would still be the same, the <em>absolute value</em> of it would enough to solve the problem.<br>For example, if the user enters <code>25</code>, then <code>10</code>, then <code>25</code> again — we know that our change due would be <code>-10</code> if we keep decreasing the value. We need to output <code>Change owed: 10</code>, in this case, we can simply get the absolute value and be done with our work. And how to get the absolute value? Once again, when in doubt, <em>check the documentation</em>.</p>
<h2>Just setting up my twttr</h2>
<p>The title of <a href="https://cs50.harvard.edu/python/2022/psets/2/twttr/" target="_blank" rel="noopener noreferrer">this problem</a> comes from a <a href="https://twitter.com/jack/status/20?s=20&t=EdMJ7PnkB6OXvd_M74qVdQ" target="_blank" rel="noopener noreferrer">tweet</a> from Jack Dorsey back in 2006. What we need to do is get an input string and drop any characters that are vowels. Instead of checking for each vowel though, using a vowels list, and checking if the character is in that list might result in a more elegant solution. Also, list comprehensions would be nice to use as well. Actually, let&#39;s see this elegance.</p>
<p>Let&#39;s say that we do not like spaces and commas. I know it is nonsense, but, for the sake of this example, bear with it for a minute. So, we do not want to see any spaces or any commas in our string, but we are okay with everything else. And, who cares if our string looks squeezed anyway? Let&#39;s see what we can do:</p>
<pre><code class="language-python">hated_ones = [&#39; &#39;, &#39;,&#39;]

input_str = &#39;Eye of rabbit, harp string hum, turn this water into rum&#39;

cleaned = [&#39;&#39; if char in hated_ones else char for char in input_str]

result = &#39;&#39;.join(cleaned)

print(result) # Eyeofrabbitharpstringhumturnthiswaterintorum
</code></pre>
<p>Yes, I know. Sorry, had to give that <a href="https://harrypotter.fandom.com/wiki/Eye_of_rabbit,_harp_string_hum,_turn_this_water_into_rum" target="_blank" rel="noopener noreferrer">reference</a>.</p>
<p>Now that we have seen how to solve a similar looking problem, this one is quite easy as well. Next one.</p>
<h2>Vanity Plates</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/2/plates/" target="_blank" rel="noopener noreferrer">This problem</a> requires us to check some conditionals if the given string is valid to be a vanity plate.<br>This one is slightly hard to explain without giving any spoilers. One thing I can tell you is that list comprehensions are a huge saver and makes it easier to solve the problem in a more clear way. Say, you want to see how many digits a string has. Easy:</p>
<pre><code class="language-python">s = &#39;CS50&#39;
number_of_digits = len([char for char in s if char.isdigit()])

print(number_of_digits) # 2
</code></pre>
<p>Of course, as David Malan would say, I only know the existence of <code>isdigit</code> because I <em>checked the documentation before</em>. </p>
<p>Another gem from the documentation for this problem specifically, is the checking for all the punctuation characters. While we still have not talked about libraries yet —it is coming in week 4—, if you want to go ahead, know that Python has a <a href="https://docs.python.org/3/library/string.html" target="_blank" rel="noopener noreferrer">built-in module specifically for strings</a> which makes life a whole lot easier. </p>
<p>Now, we have four specific conditions to check. The length of the input string must be within the bounds of 2 and 6 — both included. That is easy as we have done that before with a one-liner in <a href="https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-1/" target="_blank" rel="noopener noreferrer">&quot;Meal Time&quot; problem</a> last week. Another condition is to check if the first two characters are <em>alphabetical</em>. It speaks of itself, if you have checked the documentation. Another thing to check is to see if the string is clear of spaces and punctuations. I believe, list comprehensions work pretty well here too. We have actually almost done the same thing in the last problem &quot;Just setting up my twttr&quot;. And lastly, we need to check if the string ends with digits if it contains any — so that we know that the digits are not in the middle or the beginning. </p>
<p>Without giving away too much, one way to think about this would be something like this: We can get the length of the digits in our string, and check if the rest of the string from that index on is only digits. We have done that before, but it might be better understood with an example:</p>
<pre><code class="language-python">s = &#39;CS50&#39;
number_of_digits = len([char for char in s if char.isdigit()])

print(s[-number_of_digits:]) # 50
</code></pre>
<p>Using negative indexing, we can traverse the string backwards from that index which would be the length of the digit characters in this case.</p>
<p>Checking these four cases is all we need to do. I know I have talked about list comprehensions a lot, but they go very well with loops. If that is still not clear, you can always use the normal expanded version as well, as in the Camel Case example. And, to be honest, more complicated loops makes list comprehensions much more complex. Being reasonable is way to go.</p>
<h2>Nutrition Facts</h2>
<p>And, here is the perhaps easiest(?) <a href="https://cs50.harvard.edu/python/2022/psets/2/nutrition/" target="_blank" rel="noopener noreferrer">problem</a> this week, in terms of implementing logic.<br>A dictionary is the most obvious choice to use in this case. All we need to do is to create a dictionary — fruit names as keys, and their calories as values using <a href="https://cs50.harvard.edu/python/2022/psets/2/nutrition/Nutrition-Information-for-Raw-Fruits---small-PDF-Poster.pdf" target="_blank" rel="noopener noreferrer">this poster</a>, and return calories for a given fruit. The lecture video already shows how to do that, so that is it. Also, if we want to return literally nothing instead of <code>None</code>, we can return an empty string. And, this is the end of this problem as well as the end of the Problem Set 2.</p>
<p>Next week&#39;s problem set is going to be on Exceptions, and it is really exciting to wait for what kinds of problems we will be solving.<br>See you next week, and happy coding.</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-2</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-2</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 19 Apr 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 1]]></title>
            <description><![CDATA[<p>This week on Conditionals, we are presented with another five problems to solve for <a href="https://cs50.harvard.edu/python/2022/psets/1/" target="_blank" rel="noopener noreferrer">Problem Set 1</a>. Let&#39;s dive in, but before I start, I should remind you of the <strong>disclaimer</strong>: I do not provide full solutions here, it is more exciting when <em>you</em> yourself come up with the answers (see <a href="https://cs50.harvard.edu/python/2022/honesty/" target="_blank" rel="noopener noreferrer">academic honesty</a>). My plan in this series is only to provide a guide to think about the problems. I also assume you read the problem set explanations, so that the references I make and the things I try to convey is more clear.</p>
<h2>Deep Thought</h2>
<p>In <a href="https://cs50.harvard.edu/python/2022/psets/1/deep/" target="_blank" rel="noopener noreferrer">this problem</a>, we only need to check if the user of our program knows the answer to the Great Question of Life, the Universe, and Everything. Simple as that.</p>
<p>One thing that the last problem set made clear was that <em>checking the documentation</em> —even if it is sometimes hard to find what you are looking for!— is vital to solve the problems. It is still something to keep in mind in this problem set as well.</p>
<p>Now that it is well known that the answer to that great question is <a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)" target="_blank" rel="noopener noreferrer">42</a>, we need to make sure the user gives the correct answer — whether they write it literally as <code>42</code> or <code>forty-two</code>, (or <code>Forty two</code>, etc.).</p>
<p>The main thing to do here is to check for two kinds of way to write it: as <code>42</code>, or a string with letters. It is clear that we will use the <code>input</code> function to get input from the user. Another thing, if you remember from the last problem set, is that the <code>input</code> returns a string even if the user enters a number. </p>
<p>A good habit to have is cleaning user inputs, as they are supposed to be messy, or we should assume them to be so. For example, to make sure that the input is not in <a href="https://en.wikipedia.org/wiki/Alternating_caps" target="_blank" rel="noopener noreferrer">sarcasm case</a> or <a href="https://en.wikipedia.org/wiki/All_caps#Association_with_shouting" target="_blank" rel="noopener noreferrer">yelling case</a>, it is always a good idea to force the string to be in lowercase. That is done easily with <code>lower</code> method. Also, we can <em>strip</em> the input string to make sure there are no unnecessary spaces around. </p>
<p>Let&#39;s say we want our answer with formatting like this: <code>the answer</code>, but the user typed in this: <code>ThE-ansWer </code>. First step to clear it up would be to make it all lowercase and get rid of the space at the end:</p>
<pre><code class="language-python">user_input = user_input.lower().strip() 
print(user_input) # the-answer
</code></pre>
<p>And, it is <code>the-answer</code> now. If we want to get rid of the hyphen (<code>-</code>) as well, we can <em>split</em> the string with that hyphen, and <em>join</em> the resulting list into a string again. Let&#39;s continue step by step:</p>
<pre><code class="language-python">user_input = user_input.split(&#39;-&#39;)
print(user_input) # [&#39;the&#39;, &#39;answer&#39;]
user_input = &#39; &#39;.join(user_input) 
print(user_input) # the answer
</code></pre>
<p>It all depends on what you want to do, and how you would like to see the answer. Because we can accept multiple types of formatting in this problem as the answer, it makes sense to use all these methods on the user input. And the last thing to do afterwards is to check if the answer is correct; <em>if</em> so, returning <code>Yes</code>; <em>else</em>, returning <code>No</code>.</p>
<h2>Home Federal Savings Bank</h2>
<p>In this <a href="https://cs50.harvard.edu/python/2022/psets/1/bank/" target="_blank" rel="noopener noreferrer">problem</a>, we check the greeting. If it has any sign of <code>hello</code> <em>in</em> it, we do not give any money, therefore output <code>$0</code>. If the greeting <em>starts with</em> an <code>h</code> though, we can output <code>$20</code>. And these are our only constraints. To everything else we are quite generous, and output <code>$100</code>.</p>
<p>Actually, Python comes with built-in methods <em>exactly</em> and suitably <em>named</em> to implement our conditions. Again, it is the documentation we should consult. </p>
<p>One thing that might be obvious or not be obvious to beginners, is that strings are also a sequence, much like lists or tuples. What that means is that they are linear and consist of ordered items. You already might have realized it when you use indexing on a <code>str</code> type to access a character, like you use indexing to get an item from a list. The implication is that, sometimes lists —or, any other sequence— behaves similarly to <code>str</code> type, and some operations are applicable to both of them. <code>in</code> for example, is one operator you can use with lists. Enough for a clue, I guess. As to checking if a string <em>starts with</em> some character, that is also self-explanatory. You might also be interested in a <a href="https://rivea0.github.io/blog/custom-endswith-and-startswith-functions/" target="_blank" rel="noopener noreferrer">custom implementation of it</a>.</p>
<h2>File Extensions</h2>
<p>This <a href="https://cs50.harvard.edu/python/2022/psets/1/extensions/" target="_blank" rel="noopener noreferrer">one</a> is probably my favorite so far. It incorporates formatting the <a href="https://en.wikipedia.org/wiki/Media_type" target="_blank" rel="noopener noreferrer">MIME types</a> (or, media types) that are in an <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="noopener noreferrer">HTTP header</a>, which determines how they are displayed on the web. In this problem, we need to get an input for a file name, and return the appropriate MIME type for that file, depending on what extension it has, if it has any.</p>
<p>There are many ways one can solve this problem. The main resource this time —besides the Python documentation, of course—, is the list of <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types" target="_blank" rel="noopener noreferrer">common MIME types</a> from MDN. To start off, you can see that we have two default types: <code>text/plain</code> for textual files (with the extension of <code>txt</code>), and <code>application/octet-stream</code> for everything else. For all the other types to consider in this problem, instead of hard-coding a conditional for each type and extension, we can create a mapping similar to the one below:</p>
<pre><code class="language-python">extensions_mapping = {
    &#39;image&#39;: [&#39;gif&#39;, &#39;jpg&#39;, &#39;jpeg&#39;, &#39;png&#39;],
    &#39;application&#39;: [&#39;pdf&#39;, &#39;zip&#39;],
}
</code></pre>
<p>Of course, first we need to get the extension of the filename. This could be done in different ways, we can <em>slice</em> the string from the index of where the dot is, or <em>split</em> it to get the part after the dot. We also need to clear the input string to handle messy inputs. As we have done that before in Deep Thought, we can <em>lower</em> the string for consistency, <em>strip</em> it to get rid of unnecessary spacing. If we use a mapping, the only thing that is left to do would be to check if the extension is <em>in</em> the values of a type (which would be our <em>key</em>), if so, simply printing the <em>key</em> and the <em>value</em> with the format of <code>[mime_type]/[extension]</code>. For example, if the filename is <code>cat.png</code>, our program should print <code>image/png</code>.</p>
<p>There is one catch, though. For the <code>jpg</code> extension, the MIME type is <code>image/jpeg</code>, instead of <code>image/jpg</code>. We can handle that with a simple conditional as well:</p>
<pre><code class="language-python">if extension == &#39;jpg&#39;:
    return &#39;image/jpeg&#39;
</code></pre>
<p>(Of course, if you do not use a function, you can simply print the string instead of using a return statement.)</p>
<p>And, that is all that necessary to solve the problem. On to the next one.</p>
<h2>Math Interpreter</h2>
<p>Here <a href="https://cs50.harvard.edu/python/2022/psets/1/interpreter/" target="_blank" rel="noopener noreferrer">in this problem</a>, the conditionals <em>if</em>/<em>elif</em>/<em>else</em> really shine. We only need to do simple arithmetic with two operands. We also need to format our output string as a float, having one decimal place. A hint of <em>splitting</em> the input string is already given in the explanation. If the user types in <code>5 + 4</code>, the result of our split would be <code>[&#39;5&#39;, &#39;+&#39;, &#39;4&#39;]</code> (remember, the input always returns a string). The only thing that is left to do is to check the given operator for each of the four operators (<code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>) and do the arithmetic. The float formatting works like below:</p>
<pre><code class="language-python">x = 6.5418
print(f&#39;{x:.2f}&#39;) # 6.54
</code></pre>
<p>Instead of 2, we need to do format it as having <em>one</em> place. This, and a chain of conditions is all that there is to it.</p>
<h2>Meal Time</h2>
<p>This <a href="https://cs50.harvard.edu/python/2022/psets/1/meal/" target="_blank" rel="noopener noreferrer">one</a> was also quite enjoyable, even though at first glance it seems to be more complicated than others before. The first thing to think about is that we only have three options to consider: a time range of <code>7:00 - 8:00</code> which indicates <code>breakfast time</code>, <code>12:00 - 13:00</code> which means <code>lunch time</code>, and finally, <code>18:00 - 19:00</code> which is <code>dinner time</code>. When we ask the time to user, the input might be in the format of <code>#:##</code> or <code>##:##</code>. The program structure is also given to us, with a <code>main</code> function and a <code>convert</code> function, which we can call inside <code>main</code>. Let&#39;s think about how we can do the converting.</p>
<p>For a given time with the formatting <code>#:##</code> or <code>##:##</code>, we need to get the hour and minutes — which indicates that we need to <em>split</em> our string, so that the first item of the result of that split would be the hour, and the second one would be the minutes.</p>
<p>Since the hour can be written as <code>07</code>, we can check if it <em>starts with</em> 0, so that we can <em>slice</em> it appropriately. </p>
<p>Say, the user input is <code>07:30</code>. What does that mean? It is simply 7 hours and a half. Since an hour is 60 minutes, we can denote that part as a division. So, <code>30 / 60</code> in this case, would be <code>0.5</code>.  Then, all we need to do is to add the hour and minutes, converting any of them to <code>int</code> if necessary. But, if the input is <code>07:32</code>, you can imagine doing the division <code>32 / 60</code> would result in a not-so-nice-looking output, namely that of <code>0.5333333333333333</code>. One thing we can do in that case, is to use the <code>round</code> function. Since we are checking clear-cut boundaries for meal hours, we can round the whole operation, so that it would be like:</p>
<pre><code class="language-python">round(hour + minutes / 60)
</code></pre>
<p>(We do not need to put parentheses around <code>minutes / 60</code> since the order of operations takes care of that.) </p>
<p>After that, the rest is easy. We need to check for each meal time to see if the given time is between a certain meal time. Here, Python makes it easy to use comparison operators in one line, and our code is more elegant as a result. An example:</p>
<pre><code class="language-python">time_total = 7.5

print(7 &lt;= time_total &lt;= 8) # True
</code></pre>
<p>We do not need to use an <code>and</code> operator in that case. It is pretty neat.</p>
<p>The only thing left to do is to return the appropriate meal time for each condition. And, that is all. For the challenge part handling time inputs with <code>a.m.</code> and <code>p.m.</code>, you would like to do another split on the minute part after you have already split hours and minutes. You can check for <code>p.m.</code>, and if it is so, you can simply add 12 to the hour variable. Considering you have <strong>already</strong> split the time to hour and minute parts, dealing with <code>p.m.</code> would be similar to this:</p>
<pre><code class="language-python">if &#39; &#39; in minute:
    abbr = minute.split(&#39; &#39;)[1]
    minute = int(minute.split(&#39; &#39;)[0])
    if abbr == &#39;p.m.&#39;:
         hour = int(hour) + 12

print(hour, minute, after) # 19 30 p.m.
</code></pre>
<p>For <code>a.m.</code>, you do not have to do additional arithmetic, just continue as before.</p>
<p>And, that is all for this week&#39;s problem set. Perhaps a bit more slightly challenging than the last week, but entertaining nonetheless. We will see what will the next week&#39;s problems be like.</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-1</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-1</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 12 Apr 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Solving the Problem Sets of CS50's Introduction to Programming with Python — One at a Time: Problem Set 0]]></title>
            <description><![CDATA[<p>Being one of the biggest online courses (and, <a href="https://www.newyorker.com/news/our-local-correspondents/how-harvards-star-computer-science-professor-built-a-distance-learning-empire" target="_blank" rel="noopener noreferrer">one of the most popular courses of Harvard</a>) is not the only thing that defines CS50. Having absolutely zero knowledge on anything related to computer science beforehand, when I finished the course last year with a <a href="https://www.youtube.com/watch?v=atriZIc7y8c" target="_blank" rel="noopener noreferrer">final project</a> that surprisingly exceeded my expectations, and managed to create a <a href="https://heap.pythonanywhere.com/" target="_blank" rel="noopener noreferrer">demo site</a> for it, it was a big dopamine rush. If you literally start taking the course without any prior experience, understanding and finally being able to solve the problem sets of the course is almost like a spiritual experience. David J. Malan is a phenomenal lecturer who helps you internalize concepts that seem difficult for a beginner.</p>
<p>CS50 is now not a single course on Introduction to Computer Programming, but has turned into a bigger ecosystem for different courses with various flavors, be it Web Programming, Artificial Intelligence, or, Mobile App Development.<br>Its latest, Introduction to Programming with Python, does not exactly focus on theoretical computer science concepts, but is a more general programming course using Python. I love Python, and I was really excited to see the new problems that CS50 would provide for us to solve in this new course.</p>
<p>Before I start, here is a disclaimer: <strong>I am not going to provide full solutions to Problem Sets</strong>. See <a href="https://cs50.harvard.edu/python/2022/honesty/" target="_blank" rel="noopener noreferrer">academic honesty</a>. </p>
<p>I am planning to write about how to start thinking about a given problem, maybe as a kind of guidance, and how one might go about solving it. I assume you already read the problem set explanations, as I might allude to them. Generally, the problems start easy and perhaps more friendly, then the curve becomes steeper. It is a nice challenge, though, that is how you realize that you are actually learning.</p>
<h2>Indoor Voice</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/0/indoor/" target="_blank" rel="noopener noreferrer">The first problem</a> seems pretty straightforward. Our given input just has to be &quot;quiet&quot; instead of being in &quot;yelling case&quot;. What that means is, if <code>&#39;THIS IS YELLING&#39;</code>, then <code>&#39;this is not yelling&#39;</code>. And, here is the importance of reading the documentation of the tool that you are using, in this case, Python. Because we work with <code>str</code> data types in the problem, we simply have to look up if Python comes with built-in <code>str</code> methods — and, it does. A lot of them. For example, it has <code>capitalize()</code>, <code>lower()</code>, <code>upper()</code> among many others. Let&#39;s see how these would work:</p>
<pre><code class="language-python">s = &#39;This is CS50.&#39;

print(s.capitalize()) # This is CS50.
print(s.lower()) # this is cs50.
print(s.upper()) # THIS IS CS50.
</code></pre>
<p>With that example, you might already see how to totally &quot;quiet down&quot; a given string. As for the <code>input()</code>, again, the documentation helps. In the Python interpreter, for example, typing <code>help(input)</code> enlightens you on how to use it.</p>
<h2>Playback Speed</h2>
<p><a href="https://cs50.harvard.edu/python/2022/psets/0/playback/" target="_blank" rel="noopener noreferrer">This problem</a> wants us to simulate a slower playback, replacing spaces with <code>...</code> (three dots). What we want to do is to split a given input string into words, and to join them back again with three dots. Or, we can simply <em>replace</em> the space characters with three dots. As with all kinds of problems, there are different ways for a solution. Here, the documentation again is important. We are working with <code>str</code> types again, there are methods named for <em>exactly</em> what we want to do in this case, no matter which method you choose to implement. Simply seek, and you will find them.</p>
<h2>Making Faces</h2>
<p>With <a href="https://cs50.harvard.edu/python/2022/psets/0/faces/" target="_blank" rel="noopener noreferrer">this one</a>, we need to replace any occurrence of <code>:)</code> with the emoji <code>🙂</code> and <code>:(</code> with 🙁. One of the most important things to realize here is that the emojis are also <code>str</code> type in this case. What we want to do is, well, literally <em>replace</em> characters of a given string with other characters. Again, consulting the documentation helps with what we exactly want to do.</p>
<p>This problem set also emphasizes the concept of modularity, splitting code into functions. For example, instead of doing everything on a <code>main()</code> function like this:</p>
<pre><code class="language-python">def main():
    incantation = &#39;Expecto Patronum&#39;
    print(f&#39;{incantation.upper()}!&#39;)

main() # EXPECTO PATRONUM!
</code></pre>
<p>There is a slightly better way to do it:</p>
<pre><code class="language-python">def say_incantation(incantation):
    return f&#39;{incantation.upper()}!&#39;

def main():
    incantation = &#39;Expecto Patronum&#39;
    print(say_incantation(incantation))

main() # EXPECTO PATRONUM!
</code></pre>
<p>And similarly in this problem, we have to split the implementation using a <code>convert</code> function to convert emoticons to emojis, and a <code>main</code> function to call <code>convert</code> inside of it.</p>
<h2>Einstein</h2>
<p>This <a href="https://cs50.harvard.edu/python/2022/psets/0/einstein/" target="_blank" rel="noopener noreferrer">problem set</a> uses Einstein&#39;s mass-energy equivalence formula <code>E = mc^2</code>. For a given mass, we need to output the energy in Joules.<br><code>c</code> in the formula, is the constant speed of light that is measured approximately as 300000000 (meters per second). The main thing to do is to plug in the variables to their equivalents in the formula, but one thing to remember is how the <code>input</code> function works. Because, in this problem we do not mostly do operations with <code>str</code> types this time, but rather with the <code>int</code> data type. So, for any kind of string in our program, <a href="https://en.wikipedia.org/wiki/Type_conversion" target="_blank" rel="noopener noreferrer">type casting</a> is a helpful thing to do as we only want integers. For example:</p>
<pre><code class="language-python"># This would not work
year = &#39;2022&#39;
print(year - 22) # TypeError
</code></pre>
<pre><code class="language-python"># But this would work
year = int(&#39;2022&#39;)
print(year - 22) # 2000
</code></pre>
<p>Perhaps, why the <code>int</code> type is great and not a slight headache like <code>float</code>s can be appreciated more in later problem sets.</p>
<h2>Tip Calculator</h2>
<p>The last <a href="https://cs50.harvard.edu/python/2022/psets/0/tip/" target="_blank" rel="noopener noreferrer">problem</a> is mostly done, only the remaining two functions are waiting for us to be implemented. </p>
<p>What <code>dollars_to_float</code> and <code>percents_to_float</code> expect as inputs are similar in terms of formatting. The first one expects an input like <code>$50.00</code> and the second one needs an input like <code>15%</code>, of course, both being strings. Just like in the Einstein problem, type casting is a useful thing to do in this problem. But, before that, we need to get rid of <code>$</code> (the dollar sign) and <code>%</code> (the percent sign). Realize that what we need to do in the first case is to <em>remove a prefix</em> (leading characters from the left), and in the second case, to <em>remove a suffix</em> (ending characters from the right). There are more than one way to do these things, we can even slice the string ourselves instead of using any built-in method. And, there is really not much to the solution except these. We do not need to think about edge cases yet, as the explanation says that the input values are assumed to be given in expected formats.</p>
<p>I do not want to give away too much, because the crux of these problems is that <em>you</em> should be the investigator. And, I guess the moral of the story for this problem set is a phrase that might sound annoying to some, but it is what it is: <em>read the documentation</em>. Or, simply, look for the thing that you need and learn to find it in the documentation. For the Problem Set 0, looking up built-in <code>str</code> methods, and some type casting would suffice.</p>
<p>We will see what the next problem set will bring. </p>
<p>Until then, happy coding. 💜</p>
]]></description>
            <link>https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-0</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/solving-the-problem-sets-of-cs50s-introduction-to-programming-with-python-problem-set-0</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 05 Apr 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A Quick Behind the Scenes of Greedy and Lazy Matching]]></title>
            <description><![CDATA[<p>Regular expressions can be a bit of a nightmare — if you encounter them for the first time.</p>
<p>That was what I used to think as well, before I eventually started to like them. You could sense the power of regular expressions, and they seemed to be ubiquitous — they show up in all kinds of places, and you know that there is no escaping from a regular expression (or, a regex). And, one of the things you would keep hearing on your encounters is the concept of a <em>greedy</em> versus <em>lazy</em> matching. Just when you think you finally grasp them somehow, they might seem to be those mysterious concepts once again a week later. So, let&#39;s see what is happening here.</p>
<p>Let&#39;s say we have a string: <code>&#39;One said: &quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.&#39;</code>. (If you&#39;re not familiar with the <a href="https://en.wikipedia.org/wiki/Koan" target="_blank" rel="noopener noreferrer">koan</a> — <em>not the wind, not the flag; <a href="https://en.wikisource.org/wiki/The_Gateless_Gate/Not_The_Wind,_Not_The_Flag" target="_blank" rel="noopener noreferrer">mind is moving</a></em>.) </p>
<p>What we want to do is to match each of the quoted sentences: <code>&quot;The flag is moving.&quot;</code> and <code>&quot;The wind is moving.&quot;</code>. Using JavaScript, the first thing comes to mind is to perhaps use something like this regex to get a match:</p>
<pre><code class="language-js">let regex = /&quot;.+&quot;/g;
</code></pre>
<p>However, if you try this, it gets a match for everything after the first quote:</p>
<pre><code class="language-js">let s = &#39;One said: &quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.&#39;;

let regex = /&quot;.+&quot;/g;

s.match(regex);
// -&gt; [ &#39;&quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot;&#39; ]
</code></pre>
<p>This is not what we want. But, why that happens is because of the <em>greedy algorithm</em> that our regex uses. What it does is basically going to the next position if there is no match for a given position. Let&#39;s see what that means.</p>
<p>The first character of the pattern <code>&quot;.+&quot;</code> to match is <code>&quot;</code>.<br>The regex engine starts with the 0th index of the string, which is <code>O</code>, therefore gets no match. If there is no match, remember, it goes to the next position. It is <code>n</code>, still no match. It continues advancing until it finds <code>&quot;</code> at index 10:</p>
<p><em>One said: <mark>&quot;</mark>The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.</em></p>
<p>Now that the regex engine has found it, it tries to match the next part of the pattern, which is the dot (<code>.</code>) character. The dot is a special quantifier that will match &quot;any character except a newline.&quot; The character after the first quote on our string was <code>T</code>, so, it matches. Because of the <code>+</code> quantifier after the dot, it will repeat as long as a character matches the dot — which will be all the rest of the characters in the string in this case:</p>
<p><em>One said: <mark>&quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.</mark></em></p>
<p>Next, the rest of the pattern (<code>&quot;</code> at the end) needs to match as well. However, we are at the end of the string already. So, what happens now is, that the engine <em>backtracks</em>. It goes back one character, and will try to match from that character onwards:</p>
<p><em>One said: <mark>&quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree</mark>.</em></p>
<p>Since the character after the match is not a quote (<code>&quot;</code>), it does not match. Therefore, it backtracks again:</p>
<p><em>One said: <mark>&quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agre</mark>e.</em></p>
<p>Now, <code>e</code> is not <code>&quot;</code> as well. The engine backtracks again and again until it finds the <code>&quot;</code>:</p>
<p><em>One said: <mark>&quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot;</mark> They argued but could not agree.</em></p>
<p>Our regex engine has found it, and is happy now.<br>Though, we have a <code>g</code> flag for global match, and the search would continue searching for the pattern again after the first match. But, the rest of the string (<code>They argued but could not agree.</code>) has no other quotes (<code>&quot;</code>) — therefore, we don&#39;t get any more results.</p>
<p>Now that we know that was not our intention to get this result, let&#39;s take a look at lazy matching.</p>
<p>We can do the lazy match with the quantifier <code>?</code> after the <code>+</code>. So, our new regex would be:</p>
<pre><code class="language-js">let regex = /&quot;.+?&quot;/g;
</code></pre>
<p>It means that we want to repeat as little as possible. Now it works as intended:</p>
<pre><code class="language-js">let s = &#39;One said: &quot;The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.&#39;;

let regex = /&quot;.+?&quot;/g;

s.match(regex);
// -&gt; [ &#39;&quot;The flag is moving.&quot;&#39;, &#39;&quot;The wind is moving.&quot;&#39; ]
</code></pre>
<p>The first thing it does is to look for the quote (<code>&quot;</code>) to match the first character in the pattern <code>&quot;.+?&quot;</code>. Similar to before, it tries until it finds it at index 10:</p>
<p><em>One said: <mark>&quot;</mark>The flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.</em></p>
<p>Next, it matches the dot:</p>
<p><em>One said: <mark>&quot;T</mark>he flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.</em></p>
<p>Now, things are different from greedy search. Instead of matching the dot continually, the engine tries matching the rest of the pattern now. In this case, instead of trying to match <code>h</code> for the dot (<code>.</code>) first, it checks if the <code>h</code> character matches the quote  (<code>&quot;</code>). Since it does not, the engine matches it with the dot and continue:</p>
<p><em>One said: <mark>&quot;Th</mark>e flag is moving.&quot; The other said: &quot;The wind is moving.&quot; They argued but could not agree.</em></p>
<p>Now, it checks <code>e</code> for the quote (<code>&quot;</code>). No match again. It continues until finds the quote:</p>
<p><em>One said: <mark>&quot;The flag is moving.&quot;</mark> The other said: &quot;The wind is moving.&quot; They argued but could not agree.</em></p>
<p>We&#39;ve found the first match! Because of the global flag, it will start again from the end of the first match, and find another result for the pattern again eventually:</p>
<p><em>One said: <mark>&quot;The flag is moving.&quot;</mark> The other said: <mark>&quot;The wind is moving.&quot;</mark> They argued but could not agree.</em></p>
<p>Finally, we&#39;ve got the result we wanted and are now happy — thanks to understanding the difference between greedy and lazy matching.</p>
<p><strong>Note</strong>: If you&#39;re not satisfied with the koan example and still confused, here is a shorter and simpler explanation: <a href="https://stackoverflow.com/a/2301298" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/a/2301298</a>.</p>
]]></description>
            <link>https://rivea0.github.io/blog/a-quick-behind-the-scenes-of-greedy-and-lazy-matching</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/a-quick-behind-the-scenes-of-greedy-and-lazy-matching</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 31 Mar 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Lexical Environment and Closures in JavaScript]]></title>
            <description><![CDATA[<p>When it feels like this is the <a href="https://www.gutenberg.org/files/98/98-h/98-h.htm#link2H_4_0001" target="_blank" rel="noopener noreferrer"><em>worst of times</em> and <em>the age of foolishness</em></a>, and you&#39;re almost certainly sure that there are darker times ahead, you might as well have a certain desire to understand how things work on a deeper level beneath the surface. </p>
<p>One of those things that are beneath the surface of JavaScript is the concept of Lexical Environment. If you&#39;re familiar with closures, it is something that helps you internalize what is really going on.</p>
<p>We can think of the Lexical Environment as an object that every function, code block, even the whole script itself, has. It not only contains the local variables and their values, but also has a reference to an <strong>outer lexical environment</strong>. </p>
<p>When you create a variable, let&#39;s say, something like this:</p>
<pre><code class="language-js">let book = &#39;Harry Potter and the Prisoner of Azkaban&#39;;
</code></pre>
<p>Think of the <code>book</code> as a property of the Lexical Environment, with the value <code>&#39;Harry Potter and the Prisoner of Azkaban&#39;</code>. Since it is inside the global Lexical Environment now, the outer reference is <code>null</code>. Maybe another way to think about this is that the global Lexical Environment is the environment of the whole script, and it has not any reference to anything <em>outer</em> than itself. </p>
<p>How the global Lexical Environment behaves is different for variables and declared functions. Let&#39;s try to understand what we mean by that.</p>
<p>The global Lexical Environment is filled with all the variables, but initially, the variables are &quot;uninitialized&quot; — which means that the engine knows about them, but they cannot be referenced until they&#39;ve been declared. So, let&#39;s say this is our script for now:</p>
<pre><code class="language-js">let book; // (1)
book = &#39;Harry Potter and the Prisoner of Azkaban&#39;; // (2)
book = &#39;Harry Potter and the Goblet of Fire&#39;; // (3)
</code></pre>
<p>What happens when the execution starts, is that the (global) Lexical Environment knows about the variable <code>book</code>, but it is uninitialized.<br>On line (1), <code>book</code> is now <code>undefined</code>.<br>On line (2), <code>book</code> is assigned a value, <code>&#39;Harry Potter and the Prisoner of Azkaban&#39;</code>.<br>On (3), the value of <code>book</code> is changed to <code>&#39;Harry Potter and the Goblet of Fire&#39;</code>.</p>
<p>However, we said that the case is different for function declarations. It also shines light on the &quot;hoisting&quot; aspect of JavaScript. Let&#39;s take a look at it.</p>
<p>When a function is declared (we&#39;re not using a function expression), it is instantly initialized so that it is ready to be used. That&#39;s why it does not matter if we declare the function after we use them — that&#39;s why something like this works:</p>
<pre><code class="language-js">console.log(add(30, 3)); // 33

function add(num, num2) {
  return num + num2;
}
</code></pre>
<p>When we say that JavaScript &quot;hoists&quot; a function, what actually happens is this: declared functions are instantly initialized when the Lexical Environment is created. But, let&#39;s look at this now:</p>
<pre><code class="language-js">let broomstick = &#39;Firebolt&#39;;

function summonItem(spell) {
  return `${spell} ${broomstick}!`;
}

console.log(summonItem(&#39;Accio&#39;)); // Accio Firebolt!
</code></pre>
<p>When the execution of the above code starts, the Lexical Environment knows both <code>broomstick</code> and <code>summonItem</code>; however, <code>broomstick</code> is uninitialized at this stage while <code>summonItem</code> is initialized and ready to use.<br>To visualize, think of the Lexical Environment as an object with properties like below:</p>
<pre><code class="language-js">{
  broomstick: &lt;uninitialized&gt;,
  summonItem: function
}
</code></pre>
<p>Also, of course, <strong>its <code>outer</code> references <code>null</code></strong> because this is the global Lexical Environment.</p>
<p>When a function starts running, a new Lexical Environment is created for it. So, when we call <code>summonItem</code> (inside the <code>console.log</code>), the Lexical Environment of that call only stores <code>spell</code> having the value <code>&#39;Accio&#39;</code>. And, it also has its <code>outer</code> referencing the global Lexical Environment itself, which stores <code>broomstick</code> and <code>summonItem</code>, with its own <code>outer</code> referencing <code>null</code>. The Lexical Environment of our function call (<code>summonItem(&#39;Accio&#39;)</code>)—the <strong>Inner Lexical Environment</strong>— references the <em>outer</em> one, the global Lexical Environment. That is, <code>spell</code> is found locally, but to reach <code>broomstick</code>, the <code>outer</code> reference is followed, and it is found there.</p>
<p>So, it is true to say that:</p>
<blockquote>
<p><strong>When the code wants to access a variable – the inner Lexical Environment is searched first, then the outer one, then the more outer one and so on until the global one.</strong> </p>
</blockquote>
<p>Now, it&#39;s time to catch our breath.</p>
<p>It may be a lot at first, but, that&#39;s learning 💁🏻.</p>
<p>This time, consider this one:</p>
<pre><code class="language-js">function powersOfTwo() {
  let start = 2;
  let count = 0;
  return function() {
    return start ** count++;
  }
}

let twoToThePower = powersOfTwo();

console.log(twoToThePower()); // 1 (2 ** 0)
console.log(twoToThePower()); // 2 (2 ** 1)
console.log(twoToThePower()); // 4 (2 ** 2)
console.log(twoToThePower()); // 8 (2 ** 3)
console.log(twoToThePower()); // 16 (2 ** 4)
console.log(twoToThePower()); // 32 (2 ** 5)
</code></pre>
<p>When the <code>powersOfTwo</code> is called, a Lexical Environment is created for it. It now has <code>start</code> and <code>count</code>, and <code>outer</code> referencing the global Lexical Environment which has <code>powersOfTwo</code> and <code>twoToThePower</code>, as well as its own <code>outer</code> referencing <code>null</code>.</p>
<p>When we call <code>twoToThePower</code> inside <code>console.log</code>, what happens is — you guessed it, a new Lexical Environment is created. Since <code>start</code> and <code>count</code> are not inside this local Lexical Environment, it follows the <code>outer</code> reference (which is the Lexical Environment of <code>powersOfTwo</code>). When it updates the <code>count</code>, it is updated inside the Lexical Environment of <code>powersOfTwo</code>. Another way to put it:</p>
<blockquote>
<p><strong>A variable is updated in the Lexical Environment where it lives.</strong></p>
</blockquote>
<p>Again, <code>start</code> and <code>count</code> lives inside the Lexical Environment of <code>powersOfTwo</code>. When we update <code>count</code>, it is updated there, not inside the Lexical Environment of the returned function which we bind to <code>twoToThePower</code>.</p>
<p>In the first call of <code>twoToThePower</code>, <code>start</code> is 2 and <code>count</code> is 0. In the second call, <code>start</code> is still 2, but <code>count</code> is updated and is now 1. And, it keeps being updated inside the Lexical Environment where it lives (<code>powersOfTwo</code>) as long as we call <code>twoToThePower</code>. </p>
<p>So, <code>twoToThePower</code> has the &quot;power&quot; to access and modify the variables inside of a Lexical Environment that its <code>outer</code> references.</p>
<p>This is what <em>closures</em> are about, a function that has access to its <code>outer</code> scope.</p>
<p>Here comes the enlightenment: Then, <em>are not all functions closures in JavaScript</em>?</p>
<p>I guess the answer is <a href="https://javascript.info/new-function#closure" target="_blank" rel="noopener noreferrer">mostly yes, with an exception</a>.</p>
<p>If you remember the <code>summonItem</code> example, it also accesses a variable (<code>broomstick</code>) from its <code>outer</code> scope, so based on the definition, we can say that it is theoretically a closure. Though, it might be better if we don&#39;t confuse ourselves a lot because when you look up closures, most basic examples you see would be similar in spirit to <code>powersOfTwo</code>. It is nevertheless a nice thing to internalize, as it was our goal all along — to see how things work beneath the surface. It is an abstract surface of course, but good to dive into.</p>
<h3>References</h3>
<ul>
<li><a href="https://javascript.info/closure" target="_blank" rel="noopener noreferrer">javascript.info</a> was my main resource while writing this article, and the quotations are taken from there. It also has great visuals to help you understand Lexical Environments better.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener noreferrer">MDN article for closures</a>. Because, what&#39;s a resources section without MDN?</li>
<li><a href="https://www.youtube.com/watch?v=vKJpN5FAeF4" target="_blank" rel="noopener noreferrer">Closures in 100 Seconds and Beyond</a> for a quick take.</li>
</ul>
]]></description>
            <link>https://rivea0.github.io/blog/lexical-environment-and-closures-in-javascript</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/lexical-environment-and-closures-in-javascript</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 09 Mar 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Custom endsWith and startsWith Functions]]></title>
            <description><![CDATA[<p>When working with strings, there might come a time that you might want to check if the string starts with or ends with another given string. Luckily, JavaScript and Python have their own built-in function to do the job, aptly named <code>startsWith()</code> &amp; <code>endsWith()</code> in JavaScript, and <code>startswith()</code> &amp; <code>endswith()</code> in Python. However, not to reinvent the wheel, but let&#39;s say we want to implement them our own way. Because, why not?</p>
<h2>Negative Indexing</h2>
<p>One thing that might be helpful, before we start off, is the concept of negative indexing. For example, not in all languages, but the last character of a string can be accessed with the index number -1. The second to last character will be -2, and so on. Python allows the use of negative indexes for strings (and for most <a href="https://docs.python.org/3.9/glossary.html#term-iterable" target="_blank" rel="noopener noreferrer">iterables</a>), and JavaScript&#39;s <code>slice</code> method also allows negative indexing. These will come in handy.</p>
<p>Python example:</p>
<pre><code class="language-python">name = &#39;David&#39;
name[-1] # d
name[-2] # i
</code></pre>
<p>We cannot access the character directly with negative indexes in JavaScript as it will return <code>undefined</code>, but we can use <code>slice</code>:</p>
<pre><code class="language-javascript">let name = &#39;David&#39;;
name[-1] // undefined
name.slice(-1) // d
name.slice(-2) // id
</code></pre>
<h2>Implementing endsWith</h2>
<p>Now, let&#39;s check if a string ends with another given string. Now that we know that negative indexes start from the end of the string, we can try something like this:</p>
<p>Python example:</p>
<pre><code class="language-python">name = &#39;David&#39;
target = &#39;vid&#39;

name[-len(target):] == target # True
</code></pre>
<p>JavaScript example:</p>
<pre><code class="language-js">let name = &#39;David&#39;;
let target = &#39;vid&#39;;

name.slice(-target.length) === target // true
</code></pre>
<p>We can take a look at what we did one by one, so that it&#39;s more clear. The first thing we see is that we get <code>target</code>&#39;s length, which will be in our example&#39;s case, 3 (the length of <code>&#39;vid&#39;</code>). And, with negative indexing, we started from -3rd index of our original string and just compared the two. <code>name.slice(-target.length)</code> will start from the -3rd index of <code>name</code> up to the end of the string, which will be <code>&#39;vid&#39;</code> and voilà! — they&#39;re the same.</p>
<p>It is a nice, one-liner way to do it. Now let&#39;s try our hand at <code>startsWith</code>, which will be easier than this one.</p>
<h2>Implementing startsWith</h2>
<p>We&#39;ll use the same components, slicing and using the target string&#39;s length. Let&#39;s do it.</p>
<p>Python example:</p>
<pre><code class="language-python">name = &#39;David&#39;
target = &#39;Dav&#39;
name[:len(target)] == target # True
</code></pre>
<p>JavaScript example:</p>
<pre><code class="language-js">let name = &#39;David&#39;;
let target = &#39;Dav&#39;;
name.slice(0, target.length) === target // true
</code></pre>
<p>Slicing the original string from the start to the length of the target string, gives us the string with the same length of <code>target</code>. So, <code>name.slice(0, target.length)</code> in this case, starts from the start of the string and goes up to the 3rd index (length of <code>&#39;Dav&#39;</code>). We only check if the two strings are the same, and that&#39;s it.</p>
<h2>Dissecting the Implementations</h2>
<p>We have written great one-liners, and just implemented our own way to do <code>startsWith</code> and <code>endsWith</code>. Here are the functions (let&#39;s write the function names in <a href="https://en.wikipedia.org/wiki/Snake_case" target="_blank" rel="noopener noreferrer">snake case</a> so as not to confuse ourselves with the built-in ones):</p>
<p>In Python:</p>
<pre><code class="language-python">def starts_with(string, target):
    return string[:len(target)] == target
</code></pre>
<pre><code class="language-python">def ends_with(string, target):
    return string[-len(target)] == target
</code></pre>
<p>In JavaScript:</p>
<pre><code class="language-js">function starts_with(string, target) {
  return string.slice(0, target.length) === target;
}
</code></pre>
<pre><code class="language-js">function ends_with(string, target) {
  return string.slice(-target.length) === target;
}
</code></pre>
<p>These are fine, but what about implementing the same logic another way?  Maybe, with another language? One that will help us think in lower-level.</p>
<p>My initial thought was that it would be something like this in C (spoiler: it was naive.):</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;

bool starts_with(char *string, char *target) {
  int target_length = strlen(target);
  for (int i = 0; i &lt; target_length; i++) {
    if (string[i] != target[i]) {
      return false;
    }
  }
  return true;
}

bool ends_with(char *string, char *target) {
  int target_length = strlen(target);
  int starting_index = strlen(string) - target_length;
  for (int i = 0; i &lt; target_length; i++) {
    if (string[starting_index + i] != target[i]) {
      return false;
    }
  }
  return true;
}
</code></pre>
<p>However, I was <a href="https://web.archive.org/web/20221225204544/https://dev.to/pauljlucas/comment/1mj0d" target="_blank" rel="noopener noreferrer">corrected</a> that this is indeed problematic.</p>
<p>Here is the simpler and correct versions of <code>starts_with</code> and <code>ends_with</code>:</p>
<pre><code class="language-c">bool starts_with(char const *string, char const *target) {
  for ( ; *target != &#39;\0&#39; &amp;&amp; *target == *string; ++target, ++string );
  return *target == &#39;\0&#39;;
}
</code></pre>
<pre><code class="language-c">bool ends_with(char const *string, char const *target) {
  char const *const t0 = target;
  for ( ; *target != &#39;\0&#39;; ++string, ++target ) {
    if ( *string == &#39;\0&#39; ) return false;
  }
  for ( ; *string != &#39;\0&#39;; ++string );
  size_t const t_len = (size_t)(target - t0);
  return strcmp( string - t_len, t0 ) == 0;
}
</code></pre>
<p>What we do in <code>starts_with</code> is the same idea, only that we compare each character of our original string and the target string until <code>target</code> ends; also handling the case if <code>target</code> is longer than <code>string</code> — in which case it would return false.</p>
<p>In <code>ends_with</code>, we first check to see if <code>target</code> is longer than <code>string</code> (in that case, we would immediately return false). Then, using the <code>target</code>&#39;s length (<code>t_len</code>), we compare the <code>string</code>&#39;s end of <code>t_len</code> characters with our target string (<code>t0</code>).</p>
<p>Here&#39;s the whole code:</p>
<pre><code class="language-c">#include &lt;stdbool.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// Function prototypes
bool starts_with(char const *string, char const *target);
bool ends_with( char const *string, char const *target );

int main(void) {
  char const *str = &quot;David&quot;;
  char const *target_end = &quot;vid&quot;;
  char const *target_start = &quot;D&quot;;

  // prints &quot;true&quot;
  printf(&quot;%s\n&quot;, starts_with(str, target_start) ? &quot;true&quot; : &quot;false&quot;);

  // prints &quot;true&quot;
  printf(&quot;%s\n&quot;, ends_with(str, target_end) ? &quot;true&quot; : &quot;false&quot;);
}

bool starts_with(char const *string, char const *target) {
  for ( ; *target != &#39;\0&#39; &amp;&amp; *target == *string; ++target, ++string );
  return *target == &#39;\0&#39;;
}

bool ends_with( char const *string, char const *target ) {
  char const *const t0 = target;
  for ( ; *target != &#39;\0&#39;; ++string, ++target ) {
    if ( *string == &#39;\0&#39; ) return false;
  }
  for ( ; *string != &#39;\0&#39;; ++string );
  size_t const t_len = (size_t)(target - t0);
  return strcmp( string - t_len, t0 ) == 0;
}
</code></pre>
<p>And now, time for some introspection.</p>
<p>Did we reinvent the wheel? Maybe.</p>
<p>Was it a problem that already been solved? That&#39;s what it was.</p>
<p>But, have we had some fun along the way? Well, depends on you, but I certainly did.</p>
]]></description>
            <link>https://rivea0.github.io/blog/custom-endswith-and-startswith-functions</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/custom-endswith-and-startswith-functions</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Tue, 22 Feb 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Don't Compare Arrays with == in JavaScript]]></title>
            <description><![CDATA[<p>I used to think that if we define two arrays with the same values in the same order, we could compare their equality of value in JavaScript (the vanilla one, that is) using <code>==</code>.</p>
<p>How wrong I was.</p>
<p>What I mean is, when you do something like this:</p>
<pre><code class="language-javascript">let x = [1, 3];
let y = [1, 3];
</code></pre>
<p>You expect something like <code>x == y</code> to be true (remember we&#39;re not using the strict equality yet as we know that they are not the same object —yes, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener noreferrer"><em>arrays are objects</em></a>—, we&#39;re only looking if they are equal value-wise). For example, in Python, while they are not the same object in memory, these two lists would equal true:</p>
<pre><code class="language-python">x = [1, 3]
y = [1, 3]
x == y # True 
x is y # (or `id(x) == id(y)`) False
</code></pre>
<p>Using <code>===</code> in JavaScript for both arrays would, of course, return false as they are not the same objects in memory. That&#39;s expected, but there is also not a special treatment for array comparison by value as there is no item-by-item comparison behind the scenes for <code>==</code> — so, stay away from using it to compare arrays&#39; value equality.</p>
<p>We can use, however, something like this function (as defined in <em>JavaScript: The Definitive Guide</em> by David Flanagan), to compare two arrays for equality:</p>
<pre><code class="language-javascript">function equalArrays(a, b) {
  if (a === b) return true; // Identical arrays are equal
  if (a.length !== b.length) return false; // Different-size arrays are not equal
  for (let i = 0; i &lt; a.length; i++) { // Loop through all elements
    if (a[i] !== b[i]) return false; // If any differ, arrays are not equal
  } return true; // Otherwise they are equal
}
</code></pre>
<p>Of course, this would not work recursively, so it would mostly be useful for simple and one-dimensional arrays.</p>
<p>Quite simple, but, something to keep in mind nonetheless.</p>
<p>Also, to learn more about how the equality operator works with objects, reading about <a href="https://javascript.info/object-toprimitive" target="_blank" rel="noopener noreferrer">object to primitive conversion</a> is a great way to spend some time learning what&#39;s going on behind the scenes.</p>
]]></description>
            <link>https://rivea0.github.io/blog/dont-compare-arrays</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/dont-compare-arrays</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Sat, 19 Feb 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[There is Always a Better Way, Most Likely Waiting as a Built-In Method in the Standard Library]]></title>
            <description><![CDATA[<p>I was reading Al Sweigart&#39;s <em>Beyond the Basic Stuff with Python</em> –which I would recommend if you&#39;re already finished <em>Automate the Boring Stuff</em>– when I had a realization.<br>Consider the following terrible looking code:</p>
<pre><code class="language-python">def check_holiday(season):
    if season == &#39;Winter&#39;:
        holiday = &#39;New Year\&#39;s Day&#39; 
    elif season == &#39;Spring&#39;:
        holiday = &#39;May Day&#39; 
    elif season == &#39;Summer&#39;:
        holiday = &#39;Juneteenth&#39; 
    elif season == &#39;Fall&#39;:
        holiday = &#39;Halloween&#39; 
    else:
        holiday = &#39;Personal day off&#39;

    return holiday
</code></pre>
<p>It looks indeed not that good. Of course, what you would do if you are somewhat a beginner who simply wants to follow best practices, is to come up with a better and more elegant way of writing this same piece of code – even though it might be laughable and pitiable to your future self, and to anyone who would like to pity you anyway.</p>
<p>What I&#39;ve thought at first when I saw the code above was that I would simply use a dictionary to store the seasons as keys and corresponding holidays as their values, and that&#39;s it. And, I would loop over the whole dictionary to compare the seasons and assign the holiday. It would look like this:</p>
<pre><code class="language-python">def check_holiday(season):
    seasons = {&#39;Winter&#39;: &#39;New Year\&#39;s Day&#39;,  
               &#39;Spring&#39;: &#39;May Day&#39;,  
               &#39;Summer&#39;: &#39;Juneteenth&#39;,  
               &#39;Fall&#39;: &#39;Halloween&#39;}

    holiday = &#39;Personal day off&#39;

    for k, v in seasons.items():
        if season == k:
            holiday = v

    return holiday
</code></pre>
<p>At first glance, it seemed okay. It is definitely cleaner than the one with bunch of if-else statements. But, as always, if you have come up with a better way of doing something, know that there is even a better way of doing it. Like this:</p>
<pre><code class="language-python">def check_holiday(season):
    holiday = {&#39;Winter&#39;: &#39;New Year\&#39;s Day&#39;,  
               &#39;Spring&#39;: &#39;May Day&#39;,  
               &#39;Summer&#39;: &#39;Juneteenth&#39;,  
               &#39;Fall&#39;: &#39;Halloween&#39;}.get(season, &#39;Personal day off&#39;)
    return holiday
</code></pre>
<p>It is obvious when you realize that you&#39;ve already had that better tool in your toolkit that comes built-in for you all along, and that&#39;s embarrassing. </p>
<p>So, what this code does is the same thing, only that we use Python&#39;s built-in <code>get</code> method on a dictionary to simply return the season&#39;s value – assigning it to holiday if the season exists, if not, returning &#39;Personal day off&#39; as the default value.</p>
<p>Of course, there might be a better way of doing this, but what I&#39;ve come to realize is that there is always a better choice, and it doesn&#39;t hurt to remember that –in the case of Python– you have already tons of built-in methods in the standard library to use, which would most likely be better and more efficient than what you would write anyway. </p>
<p>This might be a trivial thing, but it is nevertheless good food for thought. So, if you think you have found a better way of doing something, there&#39;s even a better way than that. And it might be under your nose all along, simply waiting for you to remember to use it.</p>
]]></description>
            <link>https://rivea0.github.io/blog/there-is-always-a-better-way</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/there-is-always-a-better-way</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Thu, 17 Feb 2022 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Inaugural Post]]></title>
            <description><![CDATA[<blockquote>
<p>We <em>write</em> and we later <em>read</em>. We <em>save</em> and we later <em>retrieve</em>. We <em>store</em> and we later <em>access</em>. The function of memory is to keep information intact between those two events.</p>
</blockquote>
<p>As with all things, there are advantages and disadvantages to having a beginner&#39;s perspective. But I will simply write for myself to learn, because information is better retained when you write about it. So I intend to keep this blog as mostly notes to myself, but anyone is welcome to read.</p>
]]></description>
            <link>https://rivea0.github.io/blog/inaugural-post</link>
            <guid isPermaLink="false">https://rivea0.github.io/blog/inaugural-post</guid>
            <dc:creator><![CDATA[Eda Eren]]></dc:creator>
            <pubDate>Wed, 16 Feb 2022 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>